<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Remote procedure call functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Remote procedure call functions</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="msg_8c.html">msg.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Message handling functions. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga0">rt_rpc</a> (RT_TASK *task, unsigned int to_do, unsigned int *result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a remote procedure call.  <a href="#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga1">rt_rpc_if</a> (RT_TASK *task, unsigned int to_do, unsigned int *result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a remote procedure call, only if the calling task will not be blocked.  <a href="#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga2">rt_rpc_until</a> (RT_TASK *task, unsigned int to_do, unsigned int *result, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a remote procedure call with an absolute timeout.  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga3">rt_rpc_timed</a> (RT_TASK *task, unsigned int to_do, unsigned int *result, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a remote procedure call with a relative timeout.  <a href="#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga4">rt_isrpc</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if sender waits for reply or not.  <a href="#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga5">rt_return</a> (RT_TASK *task, unsigned int result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return (sends) the result back to the task that made the related remote procedure call.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga6">rt_rpcx_until</a> (RT_TASK *task, void *smsg, void *rmsg, int ssize, int rsize, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an extended remote procedure call with absolute timeout.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga7">rt_rpcx_timed</a> (RT_TASK *task, void *smsg, void *rmsg, int ssize, int rsize, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an extended remote procedure call with a relative timeout.  <a href="#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga8">rt_returnx</a> (RT_TASK *task, void *msg, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return (sends) an extended result back to the task that made the related extended remote procedure call.  <a href="#ga8"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga4" doxytag="msg.c::rt_isrpc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_isrpc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if sender waits for reply or not. 
<p>
<a class="anchor" name="rt_isrpc"></a> <p>
After receiving a message, by calling rt_isrpc a task can figure out whether the sender task <em>task</em> is waiting for a reply or not. Such an inquiry may be needed when a server task must provide services to both rt_sends (FIXME) and rt_rtcs. No answer is required if the message is sent by an <em>rt_send</em> function or the sender called <a class="el" href="group__rpc.html#rt_rpc_timed">rt_rpc_timed</a>() or <a class="el" href="group__rpc.html#rt_rpc_until">rt_rpc_until</a>() but it is already timed out.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>pointer to a task structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>If the task waits for a return reply, a nonzero value is returned. Otherwise 0 is returned.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>rt_isrpc does not perform any check on pointer task. rt_isrpc cannot figure out what RPC result the sender is waiting for.<br>
 <a class="el" href="group__rpc.html#rt_return">rt_return</a>() is intelligent enough to not send an answer to a task which is not waiting for it. Therefore using rt_isrpc might not be necessary. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="msg.c::rt_return"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_return           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return (sends) the result back to the task that made the related remote procedure call. 
<p>
<a class="anchor" name="rt_return"></a> <p>
rt_return sends the result <em>result</em> to the task <em>task</em>. If the task calling rt_rpc is not waiting the answer (i.e. killed or timed out) this return message is silently discarded. The returning task tries to release any previously inheredited priority inherediting the highest priority of any rpcing task still waiting for a return, but only if does not own a resource semaphore. In the latter case it will keep the eighest inheredited priority till it has released the resource ownership and no further message is waiting for a return. That means that in the case priority inheritance is coming only from rpced messages the task will return to its base priority when no further message is queued for a return. Such a scheme automatically sets a dynamic priority ceiling in the case priorities are inheredited both from intertask messaging and resource semaphores ownership.<p>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that is got the reply) is returned. If the reply message has not been sent, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The reply message was not delivered.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.</dd></dl>
See also: notes under <a class="el" href="group__rpc.html#rt_rpc">rt_rpc</a>().     </td>
  </tr>
</table>
<a class="anchor" name="ga8" doxytag="msg.c::rt_returnx"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_returnx           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return (sends) an extended result back to the task that made the related extended remote procedure call. 
<p>
<a class="anchor" name="rt_returnx"></a> <p>
rt_returns sends the result <em>msg</em> of size <em>size</em> to the task <em>task</em>. If the task calling rt_rpcx is not waiting the answer (i.e. killed or timed out) this return message is silently discarded. The returning task tries to release any previously inheredited priority inherediting the highest priority of any rpcing task still waiting for a return, but only if does not own a resource semaphore. In the latter case it will keep the eighest inheredited priority till it has released the resource ownership and no further message is waiting for a return. That means that in the case priority inheritance is coming only from rpced messages the task will return to its base priority when no further message is queued for a return. Such a scheme automatically sets a dynamic priority ceiling in the case priorities are inheredited both from intertask messaging and resource semaphores ownership.<p>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that is got the reply) is returned. If the reply message has not been sent, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The reply message was not delivered.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.</dd></dl>
See also: notes under <a class="el" href="msg_8c.html#rt_rpcx">rt_rpcx</a>().     </td>
  </tr>
</table>
<a class="anchor" name="ga0" doxytag="msg.c::rt_rpc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_rpc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>to_do</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int *&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a remote procedure call. 
<p>
<a class="anchor" name="rt_rpc"></a> <p>
rt_rpc makes a Remote Procedure Call (RPC). rt_rpc is used for synchronous inter task messaging as it sends the message <em>msg</em> to the task <em>task</em> and blocks waiting until a return is received from the called task. So the caller task is always blocked and queued up in priority order while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. The receiver task may get the message with any rt_receive function. It can send an answer with <a class="el" href="group__rpc.html#rt_return">rt_return</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>pointer to a RT_TASK structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>message to send.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reply</em>&nbsp;</td><td>points to a buffer provided by the caller were the returned result message, any 4 bytes integer, is to be place.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that received the message) is returned. If the message has not been sent (e.g. the task <em>task</em> was killed before receiving the message) 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: the receiver task was killed before receiving the message.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
See also: rt_receive_*, <a class="el" href="group__rpc.html#rt_return">rt_return</a>(), <a class="el" href="group__rpc.html#rt_isrpc">rt_isrpc</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.<br>
 The trio <a class="el" href="group__rpc.html#rt_rpc">rt_rpc</a>(), <a class="el" href="group__msg.html#rt_receive">rt_receive</a>(), <a class="el" href="group__rpc.html#rt_return">rt_return</a>() implement functions similar to its peers send-receive-replay found in QNX, except that in RTAI only four bytes messages contained in any integer can be exchanged. That's so because it is more efficient and often enough. If you need to pass arbitrarely long messages see the extended intertask messaging functions. Moreover note also that we prefer the idea of calling a function by using a message and then wait for a return value since it is believed to give a better idea of what is meant for synchronous message passing. For a more truly QNX like way of inter task messaging use the support of the upper cased functions: rt_Send-rt_Recieve-rt_Reply. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="msg.c::rt_rpc_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_rpc_if           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>to_do</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int *&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a remote procedure call, only if the calling task will not be blocked. 
<p>
<a class="anchor" name="rt_rpc_if"></a> <p>
rt_rpc_if tries to make a Remote Procedure Call (RPC). If the receiver task is ready to accept a message rt_rpc_if sends the message <em>msg</em> then it always block until a return is received. In this case the caller task is blocked and queued up in priority order while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. If the receiver is not ready rt_rpc_if returns immediately. The receiver task may get the message with any rt_receive function. It can send the answer with <a class="el" href="group__rpc.html#rt_return">rt_return</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>pointer to a RT_TASK structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>message to send.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reply</em>&nbsp;</td><td>points to a buffer provided by the caller.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The task <em>task</em> was not ready to receive the message or it was killed before sending the reply.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
See also: notes under <a class="el" href="group__rpc.html#rt_rpc">rt_rpc</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="msg.c::rt_rpc_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_rpc_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>to_do</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int *&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a remote procedure call with a relative timeout. 
<p>
<a class="anchor" name="rt_rpc_timed"></a> <p>
rt_rpc_timed makes a Remote Procedure Call. It sends the message <em>msg</em> to the task <em>task</em> then always waits until a return is received or a timeout occurs. So the caller task is always blocked and queued up in priority order while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. The receiver task may get the message with any <a class="el" href="group__msg.html#rt_receive">rt_receive</a>() function. It can send the answer with <a class="el" href="group__rpc.html#rt_return">rt_return</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>pointer to a RT_TASK structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>message to send.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reply</em>&nbsp;</td><td>points to a buffer provided by the caller.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>is a timeout relative to the current time.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent or no answer arrived, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The message could not be sent or the answer did not arrived in time.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
See also: <a class="el" href="group__msg.html#rt_receive">rt_receive</a>(), <a class="el" href="group__rpc.html#rt_return">rt_return</a>(), <a class="el" href="group__rpc.html#rt_isrpc">rt_isrpc</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.<br>
 See also the notes under <a class="el" href="group__rpc.html#rt_rpc">rt_rpc</a>(). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="msg.c::rt_rpc_until"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_rpc_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>to_do</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int *&nbsp;</td>
          <td class="mdname" nowrap> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a remote procedure call with an absolute timeout. 
<p>
<a class="anchor" name="rt_rpc_until"></a> <p>
rt_rpc_until makes a Remote Procedure Call. It sends the message <em>msg</em> to the task <em>task</em> then always waits until a return is received or a timeout occurs. So the caller task is always blocked and queued up in priority order while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. The receiver task may get the message with any <a class="el" href="group__msg.html#rt_receive">rt_receive</a>() function. It can send the answer with <a class="el" href="group__rpc.html#rt_return">rt_return</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>pointer to a RT_TASK structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>message to send.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reply</em>&nbsp;</td><td>points to a buffer provided by the caller.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>is an absolute timeout value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent or no answer arrived, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The message could not be sent or the answer did not arrived in time.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
See also: <a class="el" href="group__msg.html#rt_receive">rt_receive</a>(), <a class="el" href="group__rpc.html#rt_return">rt_return</a>(), <a class="el" href="group__rpc.html#rt_isrpc">rt_isrpc</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.<br>
 See also the notes under <a class="el" href="group__rpc.html#rt_rpc">rt_rpc</a>(). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="msg.c::rt_rpcx_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_rpcx_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>smsg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>rmsg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ssize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>rsize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make an extended remote procedure call with a relative timeout. 
<p>
<a class="anchor" name="rt_rpcx_timed"></a> <p>
rt_rpcx_timed makes an extended Remote Procedure Call (RPC). It sends an arbitrary <em>smsg</em> of size <em>ssize</em> bytes to the task <em>task</em> then it always blocks waiting until a message, of size <em>rsize</em> bytes at most, is returned in <em>rmsg</em> from the called task or a timeout occurs. If the returned message is greater tha rsize it will be truncated. So the caller task is always blocked on the receiver priority queue while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. The receiver task may get the message with any rt_receivex function. It can send an answer with <a class="el" href="group__rpc.html#rt_returnx">rt_returnx</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>pointer to the RT_TASK structure of the receiver.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smsg</em>&nbsp;</td><td>points to the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rmsg</em>&nbsp;</td><td>points to the message to be returned by the receiver.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssize</em>&nbsp;</td><td>size of the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rsize</em>&nbsp;</td><td>maximum allowed size for the message to be received.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>is the relative timeout.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent or no answer arrived, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The message could not be sent or the answer did not arrived in time.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
See also: <a class="el" href="group__msg.html#rt_receive">rt_receive</a>(), <a class="el" href="group__rpc.html#rt_return">rt_return</a>(), <a class="el" href="group__rpc.html#rt_isrpc">rt_isrpc</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.<br>
 See also the notes under <a class="el" href="group__rpc.html#rt_rpc">rt_rpc</a>(). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="msg.c::rt_rpcx_until"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_rpcx_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>smsg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>rmsg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ssize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>rsize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make an extended remote procedure call with absolute timeout. 
<p>
<a class="anchor" name="rt_rpcx_until"></a> <p>
rt_rpcx_until makes an extended Remote Procedure Call (RPC). It sends an arbitrary <em>smsg</em> of size <em>ssize</em> bytes to the task <em>task</em> then it always blocks waiting until a message, of size <em>rsize</em> bytes at most, is returned in <em>rmsg</em> from the called task or a timeout occurs. If the returned message is greater tha rsize it will be truncated. So the caller task is always blocked on the receiver priority queue while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. The receiver task may get the message with any rt_receivex function. It can send an answer with <a class="el" href="group__rpc.html#rt_returnx">rt_returnx</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>pointer to the RT_TASK structure of the receiver.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smsg</em>&nbsp;</td><td>points to the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rmsg</em>&nbsp;</td><td>points to the message to be returned by the receiver.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssize</em>&nbsp;</td><td>size of the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rsize</em>&nbsp;</td><td>maximum allowed size for the message to be received.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>is an absolute timeout value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent or no answer arrived, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The message could not be sent or the answer did not arrived in time.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
See also: <a class="el" href="group__msg.html#rt_receive">rt_receive</a>(), <a class="el" href="group__rpc.html#rt_return">rt_return</a>(), <a class="el" href="group__rpc.html#rt_isrpc">rt_isrpc</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.<br>
 See also the notes under <a class="el" href="group__rpc.html#rt_rpc">rt_rpc</a>(). </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:53 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
