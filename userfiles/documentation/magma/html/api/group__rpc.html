<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTAI API: Remote procedure call functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RTAI API<span id="projectnumber">&#160;5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__rpc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Remote procedure call functions</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Remote procedure call functions:</div>
<div class="dyncontent">
<div class="center"><img src="group__rpc.png" border="0" usemap="#agroup____rpc" alt=""/></div>
<map name="agroup____rpc" id="agroup____rpc">
<area shape="rect" href="group__msg.html" title=" " alt="" coords="243,13,427,38"/>
<area shape="rect" title=" " alt="" coords="5,5,157,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:msg_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msg_8c.html">msg.c</a></td></tr>
<tr class="memdesc:msg_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message handling functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabd87e25d1781c699700ad1c681ccdb62"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#gabd87e25d1781c699700ad1c681ccdb62">rt_rpc</a> (RT_TASK *task, unsigned long to_do, void *result)</td></tr>
<tr class="memdesc:gabd87e25d1781c699700ad1c681ccdb62"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rpc"></a> <a href="group__rpc.html#gabd87e25d1781c699700ad1c681ccdb62">More...</a><br /></td></tr>
<tr class="separator:gabd87e25d1781c699700ad1c681ccdb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3521b77ccf29fc036dccd451f1114f49"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga3521b77ccf29fc036dccd451f1114f49">rt_rpc_if</a> (RT_TASK *task, unsigned long to_do, void *result)</td></tr>
<tr class="memdesc:ga3521b77ccf29fc036dccd451f1114f49"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rpc_if"></a> <a href="group__rpc.html#ga3521b77ccf29fc036dccd451f1114f49">More...</a><br /></td></tr>
<tr class="separator:ga3521b77ccf29fc036dccd451f1114f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07cadfb5db9ef83ec4465038ec4b7ba1"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga07cadfb5db9ef83ec4465038ec4b7ba1">rt_rpc_until</a> (RT_TASK *task, unsigned long to_do, void *result, RTIME time)</td></tr>
<tr class="memdesc:ga07cadfb5db9ef83ec4465038ec4b7ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rpc_until"></a> <a href="group__rpc.html#ga07cadfb5db9ef83ec4465038ec4b7ba1">More...</a><br /></td></tr>
<tr class="separator:ga07cadfb5db9ef83ec4465038ec4b7ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28c72a065a7b2a4a1ceb36b98ad07bee"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga28c72a065a7b2a4a1ceb36b98ad07bee">rt_rpc_timed</a> (RT_TASK *task, unsigned long to_do, void *result, RTIME delay)</td></tr>
<tr class="memdesc:ga28c72a065a7b2a4a1ceb36b98ad07bee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rpc_timed"></a> <a href="group__rpc.html#ga28c72a065a7b2a4a1ceb36b98ad07bee">More...</a><br /></td></tr>
<tr class="separator:ga28c72a065a7b2a4a1ceb36b98ad07bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762f7f28bf2d6db5959aa99c6d2c026d"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga762f7f28bf2d6db5959aa99c6d2c026d">rt_isrpc</a> (RT_TASK *task)</td></tr>
<tr class="memdesc:ga762f7f28bf2d6db5959aa99c6d2c026d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_isrpc"></a> <a href="group__rpc.html#ga762f7f28bf2d6db5959aa99c6d2c026d">More...</a><br /></td></tr>
<tr class="separator:ga762f7f28bf2d6db5959aa99c6d2c026d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1999613bf28d6c00e85a0065f6456f3a"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga1999613bf28d6c00e85a0065f6456f3a">rt_return</a> (RT_TASK *task, unsigned long result)</td></tr>
<tr class="memdesc:ga1999613bf28d6c00e85a0065f6456f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_return"></a> <a href="group__rpc.html#ga1999613bf28d6c00e85a0065f6456f3a">More...</a><br /></td></tr>
<tr class="separator:ga1999613bf28d6c00e85a0065f6456f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c652c1dbaddb1a17f9c94eb75ace80"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga00c652c1dbaddb1a17f9c94eb75ace80">rt_rpcx</a> (RT_TASK *task, void *smsg, void *rmsg, int ssize, int rsize)</td></tr>
<tr class="memdesc:ga00c652c1dbaddb1a17f9c94eb75ace80"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rpcx"></a> <a href="group__rpc.html#ga00c652c1dbaddb1a17f9c94eb75ace80">More...</a><br /></td></tr>
<tr class="separator:ga00c652c1dbaddb1a17f9c94eb75ace80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8912d4c0e9ac249d204d881180bf97e5"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga8912d4c0e9ac249d204d881180bf97e5">rt_rpcx_if</a> (RT_TASK *task, void *smsg, void *rmsg, int ssize, int rsize)</td></tr>
<tr class="memdesc:ga8912d4c0e9ac249d204d881180bf97e5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rpcx_if"></a> <a href="group__rpc.html#ga8912d4c0e9ac249d204d881180bf97e5">More...</a><br /></td></tr>
<tr class="separator:ga8912d4c0e9ac249d204d881180bf97e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e1c6aa1c1a0829c5ecea6c6ede6a9e"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga21e1c6aa1c1a0829c5ecea6c6ede6a9e">rt_rpcx_until</a> (RT_TASK *task, void *smsg, void *rmsg, int ssize, int rsize, RTIME time)</td></tr>
<tr class="memdesc:ga21e1c6aa1c1a0829c5ecea6c6ede6a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rpcx_until"></a> <a href="group__rpc.html#ga21e1c6aa1c1a0829c5ecea6c6ede6a9e">More...</a><br /></td></tr>
<tr class="separator:ga21e1c6aa1c1a0829c5ecea6c6ede6a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50662dad082c4822903c52e7b6afd054"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga50662dad082c4822903c52e7b6afd054">rt_rpcx_timed</a> (RT_TASK *task, void *smsg, void *rmsg, int ssize, int rsize, RTIME delay)</td></tr>
<tr class="memdesc:ga50662dad082c4822903c52e7b6afd054"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rpcx_timed"></a> <a href="group__rpc.html#ga50662dad082c4822903c52e7b6afd054">More...</a><br /></td></tr>
<tr class="separator:ga50662dad082c4822903c52e7b6afd054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb83dc509fe2c603afd547fcdc7a360d"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#gaeb83dc509fe2c603afd547fcdc7a360d">rt_returnx</a> (RT_TASK *task, void *msg, int size)</td></tr>
<tr class="memdesc:gaeb83dc509fe2c603afd547fcdc7a360d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_returnx"></a> <a href="group__rpc.html#gaeb83dc509fe2c603afd547fcdc7a360d">More...</a><br /></td></tr>
<tr class="separator:gaeb83dc509fe2c603afd547fcdc7a360d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga762f7f28bf2d6db5959aa99c6d2c026d" name="ga762f7f28bf2d6db5959aa99c6d2c026d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762f7f28bf2d6db5959aa99c6d2c026d">&#9670;&#160;</a></span>rt_isrpc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_isrpc </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_isrpc"></a></p>
<p >Check if sender waits for reply or not.</p>
<p >After receiving a message, by calling rt_isrpc a task can figure out whether the sender task <em>task</em> is waiting for a reply or not. Such an inquiry may be needed when a server task must provide services to both rt_sends (FIXME) and rt_rtcs. No answer is required if the message is sent by an <em>rt_send</em> function or the sender called rt_rpc_timed() or rt_rpc_until() but it is already timed out.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to a task structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the task waits for a return reply, a nonzero value is returned. Otherwise 0 is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>rt_isrpc does not perform any check on pointer task. rt_isrpc cannot figure out what RPC result the sender is waiting for.<br  />
 rt_return() is intelligent enough to not send an answer to a task which is not waiting for it. Therefore using rt_isrpc might not be necessary. </dd></dl>

</div>
</div>
<a id="ga1999613bf28d6c00e85a0065f6456f3a" name="ga1999613bf28d6c00e85a0065f6456f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1999613bf28d6c00e85a0065f6456f3a">&#9670;&#160;</a></span>rt_return()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK * rt_return </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_return"></a></p>
<p >Return (sends) the result back to the task that made the related remote procedure call.</p>
<p >rt_return sends the result <em>result</em> to the task <em>task</em>. If the task calling rt_rpc is not waiting the answer (i.e. killed or timed out) this return message is silently discarded. The returning task tries to release any previously inheredited priority inherediting the highest priority of any rpcing task still waiting for a return, but only if does not own a resource semaphore. In the latter case it will keep the eighest inheredited priority till it has released the resource ownership and no further message is waiting for a return. That means that in the case priority inheritance is coming only from rpced messages the task will return to its base priority when no further message is queued for a return. Such a scheme automatically sets a dynamic priority ceiling in the case priorities are inheredited both from intertask messaging and resource semaphores ownership.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, task (the pointer to the task that is got the reply) is returned. If the reply message has not been sent, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The reply message was not delivered.</li>
<li><b>0xFFFF:</b> <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.</dd></dl>
<p>See also: notes under rt_rpc(). </p>

<p class="reference">Referenced by <a class="el" href="group__msg.html#ga3681745fbbc9b3c62b238a39932d14fd">rt_receive()</a>, <a class="el" href="group__msg.html#gaa850044aa6274e2b5c63f2cc191e152d">rt_receive_if()</a>, and <a class="el" href="group__msg.html#ga565026ed4b29df86a135bb163a5804bd">rt_receive_until()</a>.</p>

</div>
</div>
<a id="gaeb83dc509fe2c603afd547fcdc7a360d" name="gaeb83dc509fe2c603afd547fcdc7a360d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb83dc509fe2c603afd547fcdc7a360d">&#9670;&#160;</a></span>rt_returnx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK * rt_returnx </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_returnx"></a></p>
<p >Return (sends) an extended result back to the task that made the related extended remote procedure call.</p>
<p >rt_returns sends the result <em>msg</em> of size <em>size</em> to the task <em>task</em>. If the task calling rt_rpcx is not waiting the answer (i.e. killed or timed out) this return message is silently discarded. The returning task tries to release any previously inheredited priority inherediting the highest priority of any rpcing task still waiting for a return, but only if does not own a resource semaphore. In the latter case it will keep the eighest inheredited priority till it has released the resource ownership and no further message is waiting for a return. That means that in the case priority inheritance is coming only from rpced messages the task will return to its base priority when no further message is queued for a return. Such a scheme automatically sets a dynamic priority ceiling in the case priorities are inheredited both from intertask messaging and resource semaphores ownership.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, task (the pointer to the task that is got the reply) is returned. If the reply message has not been sent, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The reply message was not delivered.</li>
<li><b>0xFFFF:</b> <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.</dd></dl>
<p>See also: notes under rt_rpcx(). </p>

</div>
</div>
<a id="gabd87e25d1781c699700ad1c681ccdb62" name="gabd87e25d1781c699700ad1c681ccdb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd87e25d1781c699700ad1c681ccdb62">&#9670;&#160;</a></span>rt_rpc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK * rt_rpc </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>to_do</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rpc"></a></p>
<p >Make a remote procedure call</p>
<p >rt_rpc makes a Remote Procedure Call (RPC). rt_rpc is used for synchronous inter task messaging as it sends the message <em>msg</em> to the task <em>task</em> and blocks waiting until a return is received from the called task. So the caller task is always blocked and queued up in priority order while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. The receiver task may get the message with any rt_receive function. It can send an answer with rt_return().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to a RT_TASK structure.</td></tr>
    <tr><td class="paramname">msg</td><td>message to send.</td></tr>
    <tr><td class="paramname">reply</td><td>points to a buffer provided by the caller were the returned result message, any 4 bytes integer, is to be place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, task (the pointer to the task that received the message) is returned. If the message has not been sent (e.g. the task <em>task</em> was killed before receiving the message) 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: the receiver task was killed before receiving the message.</li>
<li><b>0xFFFF:</b> <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<p>See also: rt_receive_*, rt_return(), rt_isrpc().</p>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.<br  />
 The trio rt_rpc(), rt_receive(), rt_return() implement functions similar to its peers send-receive-replay found in QNX, except that in RTAI only four bytes messages contained in any integer can be exchanged. That's so because it is more efficient and often enough. If you need to pass arbitrarely long messages see the extended intertask messaging functions. Moreover note also that we prefer the idea of calling a function by using a message and then wait for a return value since it is believed to give a better idea of what is meant for synchronous message passing. For a more truly QNX like way of inter task messaging use the support of the upper cased functions: rt_Send-rt_Recieve-rt_Reply. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__rpc.html#ga00c652c1dbaddb1a17f9c94eb75ace80">rt_rpcx()</a>, and <a class="el" href="group__msg.html#ga0e0e31c141eb2e655e34ab9cc9053120">rt_sendx()</a>.</p>

</div>
</div>
<a id="ga3521b77ccf29fc036dccd451f1114f49" name="ga3521b77ccf29fc036dccd451f1114f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3521b77ccf29fc036dccd451f1114f49">&#9670;&#160;</a></span>rt_rpc_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK * rt_rpc_if </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>to_do</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rpc_if"></a></p>
<p >Make a remote procedure call, only if the calling task will not be blocked.</p>
<p >rt_rpc_if tries to make a Remote Procedure Call (RPC). If the receiver task is ready to accept a message rt_rpc_if sends the message <em>msg</em> then it always block until a return is received. In this case the caller task is blocked and queued up in priority order while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. If the receiver is not ready rt_rpc_if returns immediately. The receiver task may get the message with any rt_receive function. It can send the answer with rt_return().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to a RT_TASK structure.</td></tr>
    <tr><td class="paramname">msg</td><td>message to send.</td></tr>
    <tr><td class="paramname">reply</td><td>points to a buffer provided by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The task <em>task</em> was not ready to receive the message or it was killed before sending the reply.</li>
<li><b>0xFFFF:</b> <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<p>See also: notes under rt_rpc().</p>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__rpc.html#ga8912d4c0e9ac249d204d881180bf97e5">rt_rpcx_if()</a>.</p>

</div>
</div>
<a id="ga28c72a065a7b2a4a1ceb36b98ad07bee" name="ga28c72a065a7b2a4a1ceb36b98ad07bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28c72a065a7b2a4a1ceb36b98ad07bee">&#9670;&#160;</a></span>rt_rpc_timed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK * rt_rpc_timed </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>to_do</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rpc_timed"></a></p>
<p >Make a remote procedure call with a relative timeout.</p>
<p >rt_rpc_timed makes a Remote Procedure Call. It sends the message <em>msg</em> to the task <em>task</em> then always waits until a return is received or a timeout occurs. So the caller task is always blocked and queued up in priority order while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. The receiver task may get the message with any rt_receive() function. It can send the answer with rt_return().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to a RT_TASK structure.</td></tr>
    <tr><td class="paramname">msg</td><td>message to send.</td></tr>
    <tr><td class="paramname">reply</td><td>points to a buffer provided by the caller.</td></tr>
    <tr><td class="paramname">delay</td><td>is a timeout relative to the current time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent or no answer arrived, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The message could not be sent or the answer did not arrived in time. <br  />
</li>
<li><b>0xFFFF:</b> <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<p>See also: rt_receive(), rt_return(), rt_isrpc().</p>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.<br  />
 See also the notes under rt_rpc(). </dd></dl>

<p class="reference">References <a class="el" href="group__rpc.html#ga07cadfb5db9ef83ec4465038ec4b7ba1">rt_rpc_until()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__rpc.html#ga50662dad082c4822903c52e7b6afd054">rt_rpcx_timed()</a>, and <a class="el" href="group__msg.html#ga230f31488d73a4aec03d2313ecd6e705">rt_sendx_timed()</a>.</p>

</div>
</div>
<a id="ga07cadfb5db9ef83ec4465038ec4b7ba1" name="ga07cadfb5db9ef83ec4465038ec4b7ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07cadfb5db9ef83ec4465038ec4b7ba1">&#9670;&#160;</a></span>rt_rpc_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK * rt_rpc_until </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>to_do</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rpc_until"></a></p>
<p >Make a remote procedure call with an absolute timeout.</p>
<p >rt_rpc_until makes a Remote Procedure Call. It sends the message <em>msg</em> to the task <em>task</em> then always waits until a return is received or a timeout occurs. So the caller task is always blocked and queued up in priority order while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. The receiver task may get the message with any rt_receive() function. It can send the answer with rt_return().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to a RT_TASK structure.</td></tr>
    <tr><td class="paramname">msg</td><td>message to send.</td></tr>
    <tr><td class="paramname">reply</td><td>points to a buffer provided by the caller.</td></tr>
    <tr><td class="paramname">time</td><td>is an absolute timeout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent or no answer arrived, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The message could not be sent or the answer did not arrived in time. <br  />
</li>
<li><b>0xFFFF:</b> <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<p>See also: rt_receive(), rt_return(), rt_isrpc().</p>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.<br  />
 See also the notes under rt_rpc(). </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__rpc.html#ga28c72a065a7b2a4a1ceb36b98ad07bee">rt_rpc_timed()</a>, <a class="el" href="group__rpc.html#ga21e1c6aa1c1a0829c5ecea6c6ede6a9e">rt_rpcx_until()</a>, and <a class="el" href="group__msg.html#gaa942b83d9f3649d849bbe2fac64ff6e0">rt_sendx_until()</a>.</p>

</div>
</div>
<a id="ga00c652c1dbaddb1a17f9c94eb75ace80" name="ga00c652c1dbaddb1a17f9c94eb75ace80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00c652c1dbaddb1a17f9c94eb75ace80">&#9670;&#160;</a></span>rt_rpcx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK * rt_rpcx </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>smsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ssize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rpcx"></a></p>
<p >Make an extended remote procedure call</p>
<p >rt_rpcx makes an extended Remote Procedure Call (RPC). rt_rpcx is used for synchronous inter task messaging. It sends an arbitrary <em>smsg</em> of size <em>ssize</em> bytes to the task <em>task</em> then it always blocks waiting until a message, of size <em>rsize</em> bytes at most, is returned in <em>rmsg</em> from the called task. If the returned message is greater tha rsize it will be truncated. So the caller task is always blocked on the receiver priority queue while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. The receiver task may get the message with any rt_receivex function. It can send an answer with rt_returnx().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to the RT_TASK structure of the receiver.</td></tr>
    <tr><td class="paramname">smsg</td><td>points to the message to be sent.</td></tr>
    <tr><td class="paramname">rmsg</td><td>points to the message to be returned by the receiver.</td></tr>
    <tr><td class="paramname">ssize</td><td>size of the message to be sent.</td></tr>
    <tr><td class="paramname">rsize</td><td>maximum allowed size for the message to be received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, task (the pointer to the task that received the message) is returned. If the message has not been sent (e.g. the task <em>task</em> was killed before receiving the message) 0 is returned.</dd></dl>
<p>See also: rt_receivex_*, rt_returnx(), rt_isrpc().</p>
<dl class="section note"><dt>Note</dt><dd>The trio rt_rpcx(), rt_receivex(), rt_returnx() implements functions similar to its peers send-receive-reply found in QNX. For a even greater compatibility see rt_Send-rt_Receive-rt_Reply. </dd></dl>

<p class="reference">References <a class="el" href="group__rpc.html#gabd87e25d1781c699700ad1c681ccdb62">rt_rpc()</a>.</p>

</div>
</div>
<a id="ga8912d4c0e9ac249d204d881180bf97e5" name="ga8912d4c0e9ac249d204d881180bf97e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8912d4c0e9ac249d204d881180bf97e5">&#9670;&#160;</a></span>rt_rpcx_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK * rt_rpcx_if </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>smsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ssize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rpcx_if"></a></p>
<p >Make an extended remote procedure call, only if the calling task will not be blocked.</p>
<p >rt_rpcx_if tries to make an extended Remote Procedure Call (RPC). If the receiver task is ready to accept a message rt_rpcx_if sends the message as it will be done by rt_rpcx. If the receiver is not ready rt_rpcx_if returns immediately. The receiver task may get the message with any rt_receivex function. It can send the answer with * rt_returnx().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to the RT_TASK structure of the receiver.</td></tr>
    <tr><td class="paramname">smsg</td><td>points to the message to be sent.</td></tr>
    <tr><td class="paramname">rmsg</td><td>points to the message to be returned by the receiver.</td></tr>
    <tr><td class="paramname">ssize</td><td>size of the message to be sent.</td></tr>
    <tr><td class="paramname">rsize</td><td>maximum allowed size for the message to be received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The task <em>task</em> was not ready to receive the message or it was killed before sending the reply.</li>
<li><b>0xFFFF:</b> <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<p>See also: notes under rt_rpc().</p>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>

<p class="reference">References <a class="el" href="group__rpc.html#ga3521b77ccf29fc036dccd451f1114f49">rt_rpc_if()</a>.</p>

</div>
</div>
<a id="ga50662dad082c4822903c52e7b6afd054" name="ga50662dad082c4822903c52e7b6afd054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50662dad082c4822903c52e7b6afd054">&#9670;&#160;</a></span>rt_rpcx_timed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK * rt_rpcx_timed </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>smsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ssize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rpcx_timed"></a></p>
<p >Make an extended remote procedure call with a relative timeout.</p>
<p >rt_rpcx_timed makes an extended Remote Procedure Call (RPC). It sends an arbitrary <em>smsg</em> of size <em>ssize</em> bytes to the task <em>task</em> then it always blocks waiting until a message, of size <em>rsize</em> bytes at most, is returned in <em>rmsg</em> from the called task or a timeout occurs. If the returned message is greater tha rsize it will be truncated. So the caller task is always blocked on the receiver priority queue while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. The receiver task may get the message with any rt_receivex function. It can send an answer with rt_returnx().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to the RT_TASK structure of the receiver.</td></tr>
    <tr><td class="paramname">smsg</td><td>points to the message to be sent.</td></tr>
    <tr><td class="paramname">rmsg</td><td>points to the message to be returned by the receiver.</td></tr>
    <tr><td class="paramname">ssize</td><td>size of the message to be sent.</td></tr>
    <tr><td class="paramname">rsize</td><td>maximum allowed size for the message to be received.</td></tr>
    <tr><td class="paramname">delay</td><td>is the relative timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent or no answer arrived, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The message could not be sent or the answer did not arrived in time. <br  />
</li>
<li><b>0xFFFF:</b> <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<p>See also: rt_receive(), rt_return(), rt_isrpc().</p>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.<br  />
 See also the notes under rt_rpc(). </dd></dl>

<p class="reference">References <a class="el" href="group__rpc.html#ga28c72a065a7b2a4a1ceb36b98ad07bee">rt_rpc_timed()</a>.</p>

</div>
</div>
<a id="ga21e1c6aa1c1a0829c5ecea6c6ede6a9e" name="ga21e1c6aa1c1a0829c5ecea6c6ede6a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21e1c6aa1c1a0829c5ecea6c6ede6a9e">&#9670;&#160;</a></span>rt_rpcx_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RT_TASK * rt_rpcx_until </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>smsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ssize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rpcx_until"></a></p>
<p >Make an extended remote procedure call with absolute timeout.</p>
<p >rt_rpcx_until makes an extended Remote Procedure Call (RPC). It sends an arbitrary <em>smsg</em> of size <em>ssize</em> bytes to the task <em>task</em> then it always blocks waiting until a message, of size <em>rsize</em> bytes at most, is returned in <em>rmsg</em> from the called task or a timeout occurs. If the returned message is greater tha rsize it will be truncated. So the caller task is always blocked on the receiver priority queue while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. The receiver task may get the message with any rt_receivex function. It can send an answer with rt_returnx().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to the RT_TASK structure of the receiver.</td></tr>
    <tr><td class="paramname">smsg</td><td>points to the message to be sent.</td></tr>
    <tr><td class="paramname">rmsg</td><td>points to the message to be returned by the receiver.</td></tr>
    <tr><td class="paramname">ssize</td><td>size of the message to be sent.</td></tr>
    <tr><td class="paramname">rsize</td><td>maximum allowed size for the message to be received.</td></tr>
    <tr><td class="paramname">time</td><td>is an absolute timeout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent or no answer arrived, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The message could not be sent or the answer did not arrived in time. <br  />
</li>
<li><b>0xFFFF:</b> <em>task</em> does not refer to a valid task.</li>
</ul>
</dd></dl>
<p>See also: rt_receive(), rt_return(), rt_isrpc().</p>
<dl class="section note"><dt>Note</dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.<br  />
 See also the notes under rt_rpc(). </dd></dl>

<p class="reference">References <a class="el" href="group__rpc.html#ga07cadfb5db9ef83ec4465038ec4b7ba1">rt_rpc_until()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
