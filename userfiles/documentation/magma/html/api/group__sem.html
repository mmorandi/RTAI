<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTAI API: Semaphore functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RTAI API<span id="projectnumber">&#160;5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__sem.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Semaphore functions</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:sem_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sem_8c.html">sem.c</a></td></tr>
<tr class="memdesc:sem_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semaphore functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga90d10dab2101b9255399d176077a34eb"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga90d10dab2101b9255399d176077a34eb">rt_typed_sem_init</a> (SEM *sem, int value, int type)</td></tr>
<tr class="memdesc:ga90d10dab2101b9255399d176077a34eb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_typed_sem_init"></a> <a href="group__sem.html#ga90d10dab2101b9255399d176077a34eb">More...</a><br /></td></tr>
<tr class="separator:ga90d10dab2101b9255399d176077a34eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5820b53394952aca2e0199c8d56acd5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga5820b53394952aca2e0199c8d56acd5a">rt_sem_init</a> (SEM *sem, int value)</td></tr>
<tr class="memdesc:ga5820b53394952aca2e0199c8d56acd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_sem_init"></a> <a href="group__sem.html#ga5820b53394952aca2e0199c8d56acd5a">More...</a><br /></td></tr>
<tr class="separator:ga5820b53394952aca2e0199c8d56acd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf75fa284b1b3053c5af2ab3acf47db7d"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gaf75fa284b1b3053c5af2ab3acf47db7d">rt_sem_delete</a> (SEM *sem)</td></tr>
<tr class="memdesc:gaf75fa284b1b3053c5af2ab3acf47db7d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_sem_delete"></a> <a href="group__sem.html#gaf75fa284b1b3053c5af2ab3acf47db7d">More...</a><br /></td></tr>
<tr class="separator:gaf75fa284b1b3053c5af2ab3acf47db7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed92c808684d69057e29ffbab0286c39"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gaed92c808684d69057e29ffbab0286c39">rt_sem_signal</a> (SEM *sem)</td></tr>
<tr class="memdesc:gaed92c808684d69057e29ffbab0286c39"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_sem_signal"></a> <a href="group__sem.html#gaed92c808684d69057e29ffbab0286c39">More...</a><br /></td></tr>
<tr class="separator:gaed92c808684d69057e29ffbab0286c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e707cd96d1c2c522dc61cf8cb29c66"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gab5e707cd96d1c2c522dc61cf8cb29c66">rt_sem_broadcast</a> (SEM *sem)</td></tr>
<tr class="memdesc:gab5e707cd96d1c2c522dc61cf8cb29c66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_sem_broadcast"></a> <a href="group__sem.html#gab5e707cd96d1c2c522dc61cf8cb29c66">More...</a><br /></td></tr>
<tr class="separator:gab5e707cd96d1c2c522dc61cf8cb29c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad588ef05b34947d18ca6a7be2b7e0baf"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gad588ef05b34947d18ca6a7be2b7e0baf">rt_sem_wait</a> (SEM *sem)</td></tr>
<tr class="memdesc:gad588ef05b34947d18ca6a7be2b7e0baf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_sem_wait"></a> <a href="group__sem.html#gad588ef05b34947d18ca6a7be2b7e0baf">More...</a><br /></td></tr>
<tr class="separator:gad588ef05b34947d18ca6a7be2b7e0baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb31cf085f23a80e87fa0c7a62a21bd"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga5fb31cf085f23a80e87fa0c7a62a21bd">rt_sem_wait_if</a> (SEM *sem)</td></tr>
<tr class="memdesc:ga5fb31cf085f23a80e87fa0c7a62a21bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_sem_wait_if"></a> <a href="group__sem.html#ga5fb31cf085f23a80e87fa0c7a62a21bd">More...</a><br /></td></tr>
<tr class="separator:ga5fb31cf085f23a80e87fa0c7a62a21bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee5fca22a77fc834cf9dc245cc916822"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gaee5fca22a77fc834cf9dc245cc916822">rt_sem_wait_until</a> (SEM *sem, RTIME time)</td></tr>
<tr class="memdesc:gaee5fca22a77fc834cf9dc245cc916822"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_sem_wait_until"></a> <a href="group__sem.html#gaee5fca22a77fc834cf9dc245cc916822">More...</a><br /></td></tr>
<tr class="separator:gaee5fca22a77fc834cf9dc245cc916822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b4cbcee4cb5527fa7f3362a857ba7f8"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga5b4cbcee4cb5527fa7f3362a857ba7f8">rt_sem_wait_timed</a> (SEM *sem, RTIME delay)</td></tr>
<tr class="memdesc:ga5b4cbcee4cb5527fa7f3362a857ba7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_sem_wait_timed"></a> <a href="group__sem.html#ga5b4cbcee4cb5527fa7f3362a857ba7f8">More...</a><br /></td></tr>
<tr class="separator:ga5b4cbcee4cb5527fa7f3362a857ba7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad299949ba77f4a7f13daea7325396560"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gad299949ba77f4a7f13daea7325396560">rt_sem_wait_barrier</a> (SEM *sem)</td></tr>
<tr class="memdesc:gad299949ba77f4a7f13daea7325396560"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_sem_wait_barrier"></a> <a href="group__sem.html#gad299949ba77f4a7f13daea7325396560">More...</a><br /></td></tr>
<tr class="separator:gad299949ba77f4a7f13daea7325396560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb07889002d49a3e48f17ffcb6b5a64e"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gabb07889002d49a3e48f17ffcb6b5a64e">rt_cond_signal</a> (CND *cnd)</td></tr>
<tr class="memdesc:gabb07889002d49a3e48f17ffcb6b5a64e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_cond_signal"></a> <a href="group__sem.html#gabb07889002d49a3e48f17ffcb6b5a64e">More...</a><br /></td></tr>
<tr class="separator:gabb07889002d49a3e48f17ffcb6b5a64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa5937d2585f2cfdc9830981c6ce606"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga0fa5937d2585f2cfdc9830981c6ce606">rt_cond_wait</a> (CND *cnd, SEM *mtx)</td></tr>
<tr class="memdesc:ga0fa5937d2585f2cfdc9830981c6ce606"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_cond_wait"></a> <a href="group__sem.html#ga0fa5937d2585f2cfdc9830981c6ce606">More...</a><br /></td></tr>
<tr class="separator:ga0fa5937d2585f2cfdc9830981c6ce606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga936135f2fbf612788c69f3c9001d7358"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga936135f2fbf612788c69f3c9001d7358">rt_cond_wait_until</a> (CND *cnd, SEM *mtx, RTIME time)</td></tr>
<tr class="memdesc:ga936135f2fbf612788c69f3c9001d7358"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_cond_wait_until"></a> <a href="group__sem.html#ga936135f2fbf612788c69f3c9001d7358">More...</a><br /></td></tr>
<tr class="separator:ga936135f2fbf612788c69f3c9001d7358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55938f319a488cb054ba3f4cbed0e698"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga55938f319a488cb054ba3f4cbed0e698">rt_cond_wait_timed</a> (CND *cnd, SEM *mtx, RTIME delay)</td></tr>
<tr class="memdesc:ga55938f319a488cb054ba3f4cbed0e698"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_cond_wait_timed"></a> <a href="group__sem.html#ga55938f319a488cb054ba3f4cbed0e698">More...</a><br /></td></tr>
<tr class="separator:ga55938f319a488cb054ba3f4cbed0e698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62fdb5ac5e42663e4d132114fc8502c3"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga62fdb5ac5e42663e4d132114fc8502c3">rt_typed_rwl_init</a> (RWL *rwl, int type)</td></tr>
<tr class="memdesc:ga62fdb5ac5e42663e4d132114fc8502c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rwl_init"></a> <a href="group__sem.html#ga62fdb5ac5e42663e4d132114fc8502c3">More...</a><br /></td></tr>
<tr class="separator:ga62fdb5ac5e42663e4d132114fc8502c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702d35153ecd5d780000c3ddc48e3cee"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga702d35153ecd5d780000c3ddc48e3cee">rt_rwl_delete</a> (RWL *rwl)</td></tr>
<tr class="memdesc:ga702d35153ecd5d780000c3ddc48e3cee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rwl_delete"></a> <a href="group__sem.html#ga702d35153ecd5d780000c3ddc48e3cee">More...</a><br /></td></tr>
<tr class="separator:ga702d35153ecd5d780000c3ddc48e3cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaca860a7bf803f759c4b1d5494902e88"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gaaca860a7bf803f759c4b1d5494902e88">rt_rwl_rdlock</a> (RWL *rwl)</td></tr>
<tr class="memdesc:gaaca860a7bf803f759c4b1d5494902e88"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rwl_rdlock"></a> <a href="group__sem.html#gaaca860a7bf803f759c4b1d5494902e88">More...</a><br /></td></tr>
<tr class="separator:gaaca860a7bf803f759c4b1d5494902e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae557a69929fe37c6bd5c7c43567da1b8"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gae557a69929fe37c6bd5c7c43567da1b8">rt_rwl_rdlock_if</a> (RWL *rwl)</td></tr>
<tr class="memdesc:gae557a69929fe37c6bd5c7c43567da1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rwl_rdlock_if"></a> <a href="group__sem.html#gae557a69929fe37c6bd5c7c43567da1b8">More...</a><br /></td></tr>
<tr class="separator:gae557a69929fe37c6bd5c7c43567da1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6033decae25c5dd831d2da2e9631d2"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gaeb6033decae25c5dd831d2da2e9631d2">rt_rwl_rdlock_until</a> (RWL *rwl, RTIME time)</td></tr>
<tr class="memdesc:gaeb6033decae25c5dd831d2da2e9631d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rwl_rdlock_until"></a> <a href="group__sem.html#gaeb6033decae25c5dd831d2da2e9631d2">More...</a><br /></td></tr>
<tr class="separator:gaeb6033decae25c5dd831d2da2e9631d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25fc8a34d004aeaf0019f6b079844bb8"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga25fc8a34d004aeaf0019f6b079844bb8">rt_rwl_rdlock_timed</a> (RWL *rwl, RTIME delay)</td></tr>
<tr class="memdesc:ga25fc8a34d004aeaf0019f6b079844bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rwl_rdlock_timed"></a> <a href="group__sem.html#ga25fc8a34d004aeaf0019f6b079844bb8">More...</a><br /></td></tr>
<tr class="separator:ga25fc8a34d004aeaf0019f6b079844bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga020bc9b4c9f543224aeca2999df02b4b"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga020bc9b4c9f543224aeca2999df02b4b">rt_rwl_wrlock</a> (RWL *rwl)</td></tr>
<tr class="memdesc:ga020bc9b4c9f543224aeca2999df02b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rwl_wrlock"></a> <a href="group__sem.html#ga020bc9b4c9f543224aeca2999df02b4b">More...</a><br /></td></tr>
<tr class="separator:ga020bc9b4c9f543224aeca2999df02b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga779dc33b9e7cf64d4c08929fa28c2651"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga779dc33b9e7cf64d4c08929fa28c2651">rt_rwl_wrlock_if</a> (RWL *rwl)</td></tr>
<tr class="memdesc:ga779dc33b9e7cf64d4c08929fa28c2651"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rwl_wrlock_if"></a> <a href="group__sem.html#ga779dc33b9e7cf64d4c08929fa28c2651">More...</a><br /></td></tr>
<tr class="separator:ga779dc33b9e7cf64d4c08929fa28c2651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40fd64e2e02471cf15a01f78f0aa30d4"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga40fd64e2e02471cf15a01f78f0aa30d4">rt_rwl_wrlock_until</a> (RWL *rwl, RTIME time)</td></tr>
<tr class="memdesc:ga40fd64e2e02471cf15a01f78f0aa30d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rwl_wrlock_until"></a> <a href="group__sem.html#ga40fd64e2e02471cf15a01f78f0aa30d4">More...</a><br /></td></tr>
<tr class="separator:ga40fd64e2e02471cf15a01f78f0aa30d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12bf3ec0f977875174e8ba294ebfac16"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga12bf3ec0f977875174e8ba294ebfac16">rt_rwl_wrlock_timed</a> (RWL *rwl, RTIME delay)</td></tr>
<tr class="memdesc:ga12bf3ec0f977875174e8ba294ebfac16"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rwl_wrlock_timed"></a> <a href="group__sem.html#ga12bf3ec0f977875174e8ba294ebfac16">More...</a><br /></td></tr>
<tr class="separator:ga12bf3ec0f977875174e8ba294ebfac16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc088a863437fa6aa57ea3638d68e0f"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gadbc088a863437fa6aa57ea3638d68e0f">rt_rwl_unlock</a> (RWL *rwl)</td></tr>
<tr class="memdesc:gadbc088a863437fa6aa57ea3638d68e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_rwl_unlock"></a> <a href="group__sem.html#gadbc088a863437fa6aa57ea3638d68e0f">More...</a><br /></td></tr>
<tr class="separator:gadbc088a863437fa6aa57ea3638d68e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf070293a2e67d9f9d74760949777035d"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gaf070293a2e67d9f9d74760949777035d">rt_spl_init</a> (SPL *spl)</td></tr>
<tr class="memdesc:gaf070293a2e67d9f9d74760949777035d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_spl_init"></a> <a href="group__sem.html#gaf070293a2e67d9f9d74760949777035d">More...</a><br /></td></tr>
<tr class="separator:gaf070293a2e67d9f9d74760949777035d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf3afe9f696e38646c6504a0bccf54e7"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gadf3afe9f696e38646c6504a0bccf54e7">rt_spl_delete</a> (SPL *spl)</td></tr>
<tr class="memdesc:gadf3afe9f696e38646c6504a0bccf54e7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_spl_delete"></a> <a href="group__sem.html#gadf3afe9f696e38646c6504a0bccf54e7">More...</a><br /></td></tr>
<tr class="separator:gadf3afe9f696e38646c6504a0bccf54e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ecd2d5d16a117bcd47c7c180a6b67e"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gaf6ecd2d5d16a117bcd47c7c180a6b67e">rt_spl_lock</a> (SPL *spl)</td></tr>
<tr class="memdesc:gaf6ecd2d5d16a117bcd47c7c180a6b67e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_spl_lock"></a> <a href="group__sem.html#gaf6ecd2d5d16a117bcd47c7c180a6b67e">More...</a><br /></td></tr>
<tr class="separator:gaf6ecd2d5d16a117bcd47c7c180a6b67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5572b9e662e3f999947bc8b405596ac2"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga5572b9e662e3f999947bc8b405596ac2">rt_spl_lock_if</a> (SPL *spl)</td></tr>
<tr class="memdesc:ga5572b9e662e3f999947bc8b405596ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_spl_lock_if"></a> <a href="group__sem.html#ga5572b9e662e3f999947bc8b405596ac2">More...</a><br /></td></tr>
<tr class="separator:ga5572b9e662e3f999947bc8b405596ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga430300be7be0dc7e237017620490f8d7"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga430300be7be0dc7e237017620490f8d7">rt_spl_lock_timed</a> (SPL *spl, unsigned long ns)</td></tr>
<tr class="memdesc:ga430300be7be0dc7e237017620490f8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_spl_lock_timed"></a> <a href="group__sem.html#ga430300be7be0dc7e237017620490f8d7">More...</a><br /></td></tr>
<tr class="separator:ga430300be7be0dc7e237017620490f8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c348647f040b093266f6c70ca06d211"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga4c348647f040b093266f6c70ca06d211">rt_spl_unlock</a> (SPL *spl)</td></tr>
<tr class="memdesc:ga4c348647f040b093266f6c70ca06d211"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_spl_unlock"></a> <a href="group__sem.html#ga4c348647f040b093266f6c70ca06d211">More...</a><br /></td></tr>
<tr class="separator:ga4c348647f040b093266f6c70ca06d211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga630f67adb4cf3169dbbd20098f50933a"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE SEM *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga630f67adb4cf3169dbbd20098f50933a">_rt_typed_named_sem_init</a> (unsigned long sem_name, int value, int type, unsigned long *handle)</td></tr>
<tr class="memdesc:ga630f67adb4cf3169dbbd20098f50933a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="_rt_typed_named_sem_init"></a> <a href="group__sem.html#ga630f67adb4cf3169dbbd20098f50933a">More...</a><br /></td></tr>
<tr class="separator:ga630f67adb4cf3169dbbd20098f50933a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc2d780b0a0cda1002c61f3ea6c03ed6"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gadc2d780b0a0cda1002c61f3ea6c03ed6">rt_named_sem_delete</a> (SEM *sem)</td></tr>
<tr class="memdesc:gadc2d780b0a0cda1002c61f3ea6c03ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_named_sem_delete"></a> <a href="group__sem.html#gadc2d780b0a0cda1002c61f3ea6c03ed6">More...</a><br /></td></tr>
<tr class="separator:gadc2d780b0a0cda1002c61f3ea6c03ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7abcca83168a9d28b26e216eb02962b"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE RWL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#gab7abcca83168a9d28b26e216eb02962b">_rt_named_rwl_init</a> (unsigned long rwl_name)</td></tr>
<tr class="memdesc:gab7abcca83168a9d28b26e216eb02962b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="_rt_named_rwl_init"></a> <a href="group__sem.html#gab7abcca83168a9d28b26e216eb02962b">More...</a><br /></td></tr>
<tr class="separator:gab7abcca83168a9d28b26e216eb02962b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a17282ab26b613cccb58376092d3e9c"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga4a17282ab26b613cccb58376092d3e9c">rt_named_rwl_delete</a> (RWL *rwl)</td></tr>
<tr class="memdesc:ga4a17282ab26b613cccb58376092d3e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_named_rwl_delete"></a> <a href="group__sem.html#ga4a17282ab26b613cccb58376092d3e9c">More...</a><br /></td></tr>
<tr class="separator:ga4a17282ab26b613cccb58376092d3e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64749a909f8974c977c0fbb2cbef31bb"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE SPL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga64749a909f8974c977c0fbb2cbef31bb">_rt_named_spl_init</a> (unsigned long spl_name)</td></tr>
<tr class="memdesc:ga64749a909f8974c977c0fbb2cbef31bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="_rt_named_spl_init"></a> <a href="group__sem.html#ga64749a909f8974c977c0fbb2cbef31bb">More...</a><br /></td></tr>
<tr class="separator:ga64749a909f8974c977c0fbb2cbef31bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41116755035f6b46f11b1b9913a06f7b"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga41116755035f6b46f11b1b9913a06f7b">rt_named_spl_delete</a> (SPL *spl)</td></tr>
<tr class="memdesc:ga41116755035f6b46f11b1b9913a06f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_named_spl_delete"></a> <a href="group__sem.html#ga41116755035f6b46f11b1b9913a06f7b">More...</a><br /></td></tr>
<tr class="separator:ga41116755035f6b46f11b1b9913a06f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab7abcca83168a9d28b26e216eb02962b" name="gab7abcca83168a9d28b26e216eb02962b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7abcca83168a9d28b26e216eb02962b">&#9670;&#160;</a></span>_rt_named_rwl_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE RWL * _rt_named_rwl_init </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>rwl_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="_rt_named_rwl_init"></a></p>
<p >Initialize a multi readers single writer lock identified by a name.</p>
<p >_rt_named_rwl_init allocate and initializes a multi readers single writer lock (RWL) identified by <em>name</em>. Once the lock structure is allocated the initialization is as for rt_rwl_init. The function returns the handle pointing to the allocated multi readers single writer lock o structure, to be used as the usual lock address in all rwl based services. Named objects are useful for use among different processes, kernel/user space and in distributed applications, see netrpc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwl_name</td><td>is the identifier associated with the returned object.</td></tr>
  </table>
  </dd>
</dl>
<p>Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.</p>
<dl class="section see"><dt>See also</dt><dd>nam2num() and num2nam().</dd></dl>
<p>As for all the named initialization functions it must be remarked that only the very first call to initilize/create a named RTAI object does a real allocation of the object, any following call with the same name will just increase its usage count. In any case the function returns a pointer to the named object, or zero if in error.</p>
<dl class="section return"><dt>Returns</dt><dd>either a valid pointer or 0 if in error. </dd></dl>

<p class="reference">References <a class="el" href="group__lxrt.html#ga2b09f30503a969be7ea781f306015944">rt_register()</a>, and <a class="el" href="group__sem.html#ga702d35153ecd5d780000c3ddc48e3cee">rt_rwl_delete()</a>.</p>

</div>
</div>
<a id="ga64749a909f8974c977c0fbb2cbef31bb" name="ga64749a909f8974c977c0fbb2cbef31bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64749a909f8974c977c0fbb2cbef31bb">&#9670;&#160;</a></span>_rt_named_spl_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE SPL * _rt_named_spl_init </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>spl_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="_rt_named_spl_init"></a></p>
<p >Initialize a spinlock identified by a name.</p>
<p >_rt_named_spl_init allocate and initializes a spinlock (SPL) identified by <em>name</em>. Once the spinlock structure is allocated the initialization is as for rt_spl_init. The function returns the handle pointing to the allocated spinlock structure, to be used as the usual spinlock address in all spinlock based services. Named objects are useful for use among different processes and kernel/user space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spl_name</td><td>is the identifier associated with the returned object.</td></tr>
  </table>
  </dd>
</dl>
<p>Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.</p>
<dl class="section see"><dt>See also</dt><dd>nam2num() and num2nam().</dd></dl>
<p>As for all the named initialization functions it must be remarked that only the very first call to initilize/create a named RTAI object does a real allocation of the object, any following call with the same name will just increase its usage count. In any case the function returns a pointer to the named object, or zero if in error.</p>
<dl class="section return"><dt>Returns</dt><dd>either a valid pointer or 0 if in error. </dd></dl>

<p class="reference">References <a class="el" href="group__lxrt.html#ga2b09f30503a969be7ea781f306015944">rt_register()</a>, <a class="el" href="group__sem.html#gadf3afe9f696e38646c6504a0bccf54e7">rt_spl_delete()</a>, and <a class="el" href="group__sem.html#gaf070293a2e67d9f9d74760949777035d">rt_spl_init()</a>.</p>

</div>
</div>
<a id="ga630f67adb4cf3169dbbd20098f50933a" name="ga630f67adb4cf3169dbbd20098f50933a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga630f67adb4cf3169dbbd20098f50933a">&#9670;&#160;</a></span>_rt_typed_named_sem_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE SEM * _rt_typed_named_sem_init </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>sem_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="_rt_typed_named_sem_init"></a></p>
<p >Initialize a specifically typed (counting, binary, resource) semaphore identified by a name.</p>
<p >_rt_typed_named_sem_init allocate and initializes a semaphore identified by <em>name</em> of type <em>type</em>. Once the semaphore structure is allocated the initialization is as for rt_typed_sem_init. The function returns the handle pointing to the allocated semaphore structure, to be used as the usual semaphore address in all semaphore based services. Named objects are useful for use among different processes, kernel/user space and in distributed applications, see netrpc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem_name</td><td>is the identifier associated with the returned object.</td></tr>
    <tr><td class="paramname">value</td><td>is the initial value of the semaphore, always set to 1 for a resource semaphore.</td></tr>
    <tr><td class="paramname">type</td><td>is the semaphore type and queuing policy. It can be an OR a semaphore kind: CNT_SEM for counting semaphores, BIN_SEM for binary semaphores, RES_SEM for resource semaphores; and queuing policy: FIFO_Q, PRIO_Q for a fifo and priority queueing respectively. Resource semaphores will enforce a PRIO_Q policy anyhow.</td></tr>
  </table>
  </dd>
</dl>
<p>Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.</p>
<dl class="section see"><dt>See also</dt><dd>nam2num() and num2nam().</dd></dl>
<p>See rt_typed_sem_init for further clues.</p>
<p >As for all the named initialization functions it must be remarked that only the very first call to initilize/create a named RTAI object does a real allocation of the object, any following call with the same name will just increase its usage count. In any case the function returns a pointer to the named object, or zero if in error.</p>
<dl class="section return"><dt>Returns</dt><dd>either a valid pointer or 0 if in error. </dd></dl>

<p class="reference">References <a class="el" href="group__lxrt.html#ga2b09f30503a969be7ea781f306015944">rt_register()</a>, <a class="el" href="group__sem.html#gaf75fa284b1b3053c5af2ab3acf47db7d">rt_sem_delete()</a>, and <a class="el" href="group__sem.html#ga90d10dab2101b9255399d176077a34eb">rt_typed_sem_init()</a>.</p>

</div>
</div>
<a id="gabb07889002d49a3e48f17ffcb6b5a64e" name="gabb07889002d49a3e48f17ffcb6b5a64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb07889002d49a3e48f17ffcb6b5a64e">&#9670;&#160;</a></span>rt_cond_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_cond_signal </td>
          <td>(</td>
          <td class="paramtype">CND *&#160;</td>
          <td class="paramname"><em>cnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_cond_signal"></a></p>
<p >Wait for a signal to a conditional variable.</p>
<p >rt_cond_signal resumes one of the tasks that are waiting on the condition semaphore cnd. Nothing happens if no task is waiting on <em>cnd</em>, while it resumed the first queued task blocked on cnd, according to the queueing method set at rt_cond_init.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnd</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga3dbaa1fbd576aaca0cbf8ca3fb5b2e99">rt_cond_init()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

</div>
</div>
<a id="ga0fa5937d2585f2cfdc9830981c6ce606" name="ga0fa5937d2585f2cfdc9830981c6ce606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fa5937d2585f2cfdc9830981c6ce606">&#9670;&#160;</a></span>rt_cond_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_cond_wait </td>
          <td>(</td>
          <td class="paramtype">CND *&#160;</td>
          <td class="paramname"><em>cnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>mtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_cond_wait"></a></p>
<p >Wait for a signal to a conditional variable.</p>
<p >rt_cond_wait atomically unlocks mtx (as for using rt_sem_signal) and waits for the condition semaphore cnd to be signaled. The task execution is suspended until the condition semaphore is signalled. Mtx must be obtained by the calling task, before calling rt_cond_wait is called. Before returning to the calling task rt_cond_wait reacquires mtx by calling rt_sem_wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnd</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga3dbaa1fbd576aaca0cbf8ca3fb5b2e99">rt_cond_init()</a>.</td></tr>
    <tr><td class="paramname">mtx</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga23569ca638cdac31d41a3c7bff820598">rt_sem_init()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, SEM_ERR in case of error. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#gad588ef05b34947d18ca6a7be2b7e0baf">rt_sem_wait()</a>.</p>

</div>
</div>
<a id="ga55938f319a488cb054ba3f4cbed0e698" name="ga55938f319a488cb054ba3f4cbed0e698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55938f319a488cb054ba3f4cbed0e698">&#9670;&#160;</a></span>rt_cond_wait_timed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_cond_wait_timed </td>
          <td>(</td>
          <td class="paramtype">CND *&#160;</td>
          <td class="paramname"><em>cnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_cond_wait_timed"></a></p>
<p >Wait a semaphore with timeout.</p>
<p >rt_cond_wait_timed atomically unlocks mtx (as for using rt_sem_signal) and waits for the condition semaphore cnd to be signalled. The task execution is suspended until the condition semaphore is either signaled or a timeout expires. Mtx must be obtained by the calling task, before calling rt_cond_wait is called. Before returning to the calling task rt_cond_wait_until reacquires mtx by calling rt_sem_wait and returns a value to indicate if it has been signalled pr timedout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnd</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga3dbaa1fbd576aaca0cbf8ca3fb5b2e99">rt_cond_init()</a>.</td></tr>
    <tr><td class="paramname">mtx</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga23569ca638cdac31d41a3c7bff820598">rt_sem_init()</a>.</td></tr>
    <tr><td class="paramname">delay</td><td>is a realtive time values with respect to the current time, in timer count unit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if it was signaled, SEM_TIMOUT if a timeout occured, SEM_ERR if the task has been resumed because of any other action (likely cnd was deleted). </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#ga936135f2fbf612788c69f3c9001d7358">rt_cond_wait_until()</a>.</p>

</div>
</div>
<a id="ga936135f2fbf612788c69f3c9001d7358" name="ga936135f2fbf612788c69f3c9001d7358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga936135f2fbf612788c69f3c9001d7358">&#9670;&#160;</a></span>rt_cond_wait_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_cond_wait_until </td>
          <td>(</td>
          <td class="paramtype">CND *&#160;</td>
          <td class="paramname"><em>cnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_cond_wait_until"></a></p>
<p >Wait a semaphore with timeout.</p>
<p >rt_cond_wait_until atomically unlocks mtx (as for using rt_sem_signal) and waits for the condition semaphore cnd to be signalled. The task execution is suspended until the condition semaphore is either signaled or a timeout expires. Mtx must be obtained by the calling task, before calling rt_cond_wait is called. Before returning to the calling task rt_cond_wait_until reacquires mtx by calling rt_sem_wait and returns a value to indicate if it has been signalled pr timedout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnd</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga3dbaa1fbd576aaca0cbf8ca3fb5b2e99">rt_cond_init()</a>.</td></tr>
    <tr><td class="paramname">mtx</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga23569ca638cdac31d41a3c7bff820598">rt_sem_init()</a>.</td></tr>
    <tr><td class="paramname">time</td><td>is an absolute value to the current time, in timer count unit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if it was signaled, SEM_TIMOUT if a timeout occured, SEM_ERR if the task has been resumed because of any other action (likely cnd was deleted). </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#gad588ef05b34947d18ca6a7be2b7e0baf">rt_sem_wait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__sem.html#ga55938f319a488cb054ba3f4cbed0e698">rt_cond_wait_timed()</a>.</p>

</div>
</div>
<a id="ga4a17282ab26b613cccb58376092d3e9c" name="ga4a17282ab26b613cccb58376092d3e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a17282ab26b613cccb58376092d3e9c">&#9670;&#160;</a></span>rt_named_rwl_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_named_rwl_delete </td>
          <td>(</td>
          <td class="paramtype">RWL *&#160;</td>
          <td class="paramname"><em>rwl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_named_rwl_delete"></a></p>
<p >Delete a multi readers single writer lock in named mode.</p>
<p >rt_named_rwl_delete deletes a multi readers single writer lock previously created with <a class="el" href="group__sem.html#gab7abcca83168a9d28b26e216eb02962b">_rt_named_rwl_init()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwl</td><td>points to the structure pointer returned by a corresponding call to rt_named_rwl_init.</td></tr>
  </table>
  </dd>
</dl>
<p>As it is done by all the named allocation functions delete calls have just the effect of decrementing a usage count till the last is done, as that is the one the really frees the object.</p>
<dl class="section return"><dt>Returns</dt><dd>an int &gt;=0 is returned upon success, SEM_ERR if it failed to delete the multi readers single writer lock, -EFAULT if the lock does not exist anymore. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#ga702d35153ecd5d780000c3ddc48e3cee">rt_rwl_delete()</a>.</p>

</div>
</div>
<a id="gadc2d780b0a0cda1002c61f3ea6c03ed6" name="gadc2d780b0a0cda1002c61f3ea6c03ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc2d780b0a0cda1002c61f3ea6c03ed6">&#9670;&#160;</a></span>rt_named_sem_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_named_sem_delete </td>
          <td>(</td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_named_sem_delete"></a></p>
<p >Delete a semaphore initialized in named mode.</p>
<p >rt_named_sem_delete deletes a semaphore previously created with <a class="el" href="group__sem.html#ga630f67adb4cf3169dbbd20098f50933a">_rt_typed_named_sem_init()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>points to the structure pointer returned by a corresponding call to _rt_typed_named_sem_init.</td></tr>
  </table>
  </dd>
</dl>
<p>Any tasks blocked on this semaphore is returned in error and allowed to run when semaphore is destroyed. As it is done by all the named allocation functions delete calls have just the effect of decrementing a usage count till the last is done, as that is the one the really frees the object.</p>
<dl class="section return"><dt>Returns</dt><dd>an int &gt;=0 is returned upon success, SEM_ERR if it failed to delete the semafore, -EFAULT if the semaphore does not exist anymore. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#gaf75fa284b1b3053c5af2ab3acf47db7d">rt_sem_delete()</a>.</p>

</div>
</div>
<a id="ga41116755035f6b46f11b1b9913a06f7b" name="ga41116755035f6b46f11b1b9913a06f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41116755035f6b46f11b1b9913a06f7b">&#9670;&#160;</a></span>rt_named_spl_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_named_spl_delete </td>
          <td>(</td>
          <td class="paramtype">SPL *&#160;</td>
          <td class="paramname"><em>spl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_named_spl_delete"></a></p>
<p >Delete a spinlock in named mode.</p>
<p >rt_named_spl_delete deletes a spinlock previously created with <a class="el" href="group__sem.html#ga64749a909f8974c977c0fbb2cbef31bb">_rt_named_spl_init()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spl</td><td>points to the structure pointer returned by a corresponding call to rt_named_spl_init.</td></tr>
  </table>
  </dd>
</dl>
<p>As it is done by all the named allocation functions delete calls have just the effect of decrementing a usage count till the last is done, as that is the one the really frees the object.</p>
<dl class="section return"><dt>Returns</dt><dd>an int &gt;=0 is returned upon success, -EFAULT if the spinlock does not exist anymore. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#gadf3afe9f696e38646c6504a0bccf54e7">rt_spl_delete()</a>.</p>

</div>
</div>
<a id="ga702d35153ecd5d780000c3ddc48e3cee" name="ga702d35153ecd5d780000c3ddc48e3cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga702d35153ecd5d780000c3ddc48e3cee">&#9670;&#160;</a></span>rt_rwl_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_rwl_delete </td>
          <td>(</td>
          <td class="paramtype">RWL *&#160;</td>
          <td class="paramname"><em>rwl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rwl_delete"></a></p>
<p >destroys a multi readers single writer lock.</p>
<p >rt_rwl_init destroys a multi readers single writer lock <em>rwl</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwl</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if OK, SEM_ERR if anything went wrong. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#gaf75fa284b1b3053c5af2ab3acf47db7d">rt_sem_delete()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__sem.html#gab7abcca83168a9d28b26e216eb02962b">_rt_named_rwl_init()</a>, and <a class="el" href="group__sem.html#ga4a17282ab26b613cccb58376092d3e9c">rt_named_rwl_delete()</a>.</p>

</div>
</div>
<a id="gaaca860a7bf803f759c4b1d5494902e88" name="gaaca860a7bf803f759c4b1d5494902e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaca860a7bf803f759c4b1d5494902e88">&#9670;&#160;</a></span>rt_rwl_rdlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_rwl_rdlock </td>
          <td>(</td>
          <td class="paramtype">RWL *&#160;</td>
          <td class="paramname"><em>rwl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rwl_rdlock"></a></p>
<p >acquires a multi readers single writer lock for reading.</p>
<p >rt_rwl_rdlock acquires a multi readers single writer lock <em>rwl</em> for reading. The calling task will block only if any writer owns the lock already or there are writers with higher priority waiting to acquire write access.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwl</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if OK, SEM_ERR if anything went wrong after being blocked. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#gad588ef05b34947d18ca6a7be2b7e0baf">rt_sem_wait()</a>.</p>

</div>
</div>
<a id="gae557a69929fe37c6bd5c7c43567da1b8" name="gae557a69929fe37c6bd5c7c43567da1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae557a69929fe37c6bd5c7c43567da1b8">&#9670;&#160;</a></span>rt_rwl_rdlock_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_rwl_rdlock_if </td>
          <td>(</td>
          <td class="paramtype">RWL *&#160;</td>
          <td class="paramname"><em>rwl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rwl_rdlock_if"></a></p>
<p >try to acquire a multi readers single writer lock just for reading.</p>
<p >rt_rwl_rdlock_if tries to acquire a multi readers single writer lock <em>rwl</em> for reading immediately, i.e. without blocking if a writer owns the lock or there are writers with higher priority waiting to acquire write access.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwl</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the lock was acquired, -1 if the lock was already owned. </dd></dl>

</div>
</div>
<a id="ga25fc8a34d004aeaf0019f6b079844bb8" name="ga25fc8a34d004aeaf0019f6b079844bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25fc8a34d004aeaf0019f6b079844bb8">&#9670;&#160;</a></span>rt_rwl_rdlock_timed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_rwl_rdlock_timed </td>
          <td>(</td>
          <td class="paramtype">RWL *&#160;</td>
          <td class="paramname"><em>rwl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rwl_rdlock_timed"></a></p>
<p >try to acquire a multi readers single writer lock for reading within a relative deadline time.</p>
<p >rt_rwl_rdlock_timed tries to acquire a multi readers single writer lock <em>rwl</em> for reading, as for rt_rwl_rdlock, but timing out if the lock has not been acquired within an assigned deadline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwl</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
    <tr><td class="paramname">delay</td><td>is the time delay within which the lock must be acquired, in internal count units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the lock was acquired, SEM_TIMOUT if the deadline expired without acquiring the lock, SEM_ERR in case something went wrong. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#gaeb6033decae25c5dd831d2da2e9631d2">rt_rwl_rdlock_until()</a>.</p>

</div>
</div>
<a id="gaeb6033decae25c5dd831d2da2e9631d2" name="gaeb6033decae25c5dd831d2da2e9631d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb6033decae25c5dd831d2da2e9631d2">&#9670;&#160;</a></span>rt_rwl_rdlock_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_rwl_rdlock_until </td>
          <td>(</td>
          <td class="paramtype">RWL *&#160;</td>
          <td class="paramname"><em>rwl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rwl_rdlock_until"></a></p>
<p >try to acquire a multi readers single writer lock for reading within an absolute deadline time.</p>
<p >rt_rwl_rdlock_untill tries to acquire a multi readers single writer lock <em>rwl</em> for reading, as for rt_rwl_rdlock, but timing out if the lock has not been acquired within an assigned deadline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwl</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
    <tr><td class="paramname">time</td><td>is the time deadline, in internal count units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the lock was acquired, SEM_TIMOUT if the deadline expired without acquiring the lock, SEM_ERR in case something went wrong. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#gaee5fca22a77fc834cf9dc245cc916822">rt_sem_wait_until()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__sem.html#ga25fc8a34d004aeaf0019f6b079844bb8">rt_rwl_rdlock_timed()</a>.</p>

</div>
</div>
<a id="gadbc088a863437fa6aa57ea3638d68e0f" name="gadbc088a863437fa6aa57ea3638d68e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbc088a863437fa6aa57ea3638d68e0f">&#9670;&#160;</a></span>rt_rwl_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_rwl_unlock </td>
          <td>(</td>
          <td class="paramtype">RWL *&#160;</td>
          <td class="paramname"><em>rwl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rwl_unlock"></a></p>
<p >unlock an acquired multi readers single writer lock.</p>
<p >rt_rwl_unlock unlocks an acquired multi readers single writer lock <em>rwl</em>. After releasing the lock any task waiting to acquire it will own the lock according to its priority, whether it is a reader or a writer, otherwise the lock will be fully unlocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwl</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 always. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#gab5e707cd96d1c2c522dc61cf8cb29c66">rt_sem_broadcast()</a>, and <a class="el" href="group__sem.html#gaed92c808684d69057e29ffbab0286c39">rt_sem_signal()</a>.</p>

</div>
</div>
<a id="ga020bc9b4c9f543224aeca2999df02b4b" name="ga020bc9b4c9f543224aeca2999df02b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga020bc9b4c9f543224aeca2999df02b4b">&#9670;&#160;</a></span>rt_rwl_wrlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_rwl_wrlock </td>
          <td>(</td>
          <td class="paramtype">RWL *&#160;</td>
          <td class="paramname"><em>rwl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rwl_wrlock"></a></p>
<p >acquires a multi readers single writer lock for wrtiting.</p>
<p >rt_rwl_rwlock acquires a multi readers single writer lock <em>rwl</em> for writing. The calling task will block if any other task, reader or writer, owns the lock already.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwl</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if OK, SEM_ERR if anything went wrong after being blocked. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#gad588ef05b34947d18ca6a7be2b7e0baf">rt_sem_wait()</a>.</p>

</div>
</div>
<a id="ga779dc33b9e7cf64d4c08929fa28c2651" name="ga779dc33b9e7cf64d4c08929fa28c2651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga779dc33b9e7cf64d4c08929fa28c2651">&#9670;&#160;</a></span>rt_rwl_wrlock_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_rwl_wrlock_if </td>
          <td>(</td>
          <td class="paramtype">RWL *&#160;</td>
          <td class="paramname"><em>rwl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rwl_wrlock_if"></a></p>
<p >acquires a multi readers single writer lock for writing.</p>
<p >rt_rwl_wrlock_if try to acquire a multi readers single writer lock <em>rwl</em> for writing immediately, i.e without blocking if the lock is owned already.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwl</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the lock was acquired, -1 if the lock was already owned. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#ga5fb31cf085f23a80e87fa0c7a62a21bd">rt_sem_wait_if()</a>.</p>

</div>
</div>
<a id="ga12bf3ec0f977875174e8ba294ebfac16" name="ga12bf3ec0f977875174e8ba294ebfac16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12bf3ec0f977875174e8ba294ebfac16">&#9670;&#160;</a></span>rt_rwl_wrlock_timed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_rwl_wrlock_timed </td>
          <td>(</td>
          <td class="paramtype">RWL *&#160;</td>
          <td class="paramname"><em>rwl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rwl_wrlock_timed"></a></p>
<p >try to acquire a multi readers single writer lock for writing within a relative deadline time.</p>
<p >rt_rwl_wrlock_timed tries to acquire a multi readers single writer lock <em>rwl</em> for writing, as for rt_rwl_wrlock, timing out if the lock has not been acquired within an assigned deadline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwl</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
    <tr><td class="paramname">delay</td><td>is the time delay within which the lock must be acquired, in internal count units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the lock was acquired, SEM_TIMOUT if the deadline expired without acquiring the lock, SEM_ERR in case something went wrong. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#ga40fd64e2e02471cf15a01f78f0aa30d4">rt_rwl_wrlock_until()</a>.</p>

</div>
</div>
<a id="ga40fd64e2e02471cf15a01f78f0aa30d4" name="ga40fd64e2e02471cf15a01f78f0aa30d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40fd64e2e02471cf15a01f78f0aa30d4">&#9670;&#160;</a></span>rt_rwl_wrlock_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_rwl_wrlock_until </td>
          <td>(</td>
          <td class="paramtype">RWL *&#160;</td>
          <td class="paramname"><em>rwl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rwl_wrlock_until"></a></p>
<p >try to acquire a multi readers single writer lock for writing within an absolute deadline time.</p>
<p >rt_rwl_rwlock_until tries to acquire a multi readers single writer lock <em>rwl</em> for writing, as for rt_rwl_rwlock, but timing out if the lock has not been acquired within an assigned deadline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwl</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
    <tr><td class="paramname">time</td><td>is the time deadline, in internal count units.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the lock was acquired, SEM_TIMOUT if the deadline expired without acquiring the lock, SEM_ERR in case something went wrong. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#gaee5fca22a77fc834cf9dc245cc916822">rt_sem_wait_until()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__sem.html#ga12bf3ec0f977875174e8ba294ebfac16">rt_rwl_wrlock_timed()</a>.</p>

</div>
</div>
<a id="gab5e707cd96d1c2c522dc61cf8cb29c66" name="gab5e707cd96d1c2c522dc61cf8cb29c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5e707cd96d1c2c522dc61cf8cb29c66">&#9670;&#160;</a></span>rt_sem_broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_sem_broadcast </td>
          <td>(</td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_sem_broadcast"></a></p>
<p >Signaling a semaphore.</p>
<p >rt_sem_broadcast signals an event to a semaphore that unblocks all tasks waiting on it. It is used as a support for RTAI proper conditional variables but can be of help in many other instances. After the broadcast the semaphore counts is set to zero, thus all tasks waiting on it will blocked. rt_sem_broadcast should not be used for resource semaphares.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga23569ca638cdac31d41a3c7bff820598">rt_sem_init()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 always. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__sem.html#gadbc088a863437fa6aa57ea3638d68e0f">rt_rwl_unlock()</a>, and <a class="el" href="group__sem.html#gad299949ba77f4a7f13daea7325396560">rt_sem_wait_barrier()</a>.</p>

</div>
</div>
<a id="gaf75fa284b1b3053c5af2ab3acf47db7d" name="gaf75fa284b1b3053c5af2ab3acf47db7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf75fa284b1b3053c5af2ab3acf47db7d">&#9670;&#160;</a></span>rt_sem_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_sem_delete </td>
          <td>(</td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_sem_delete"></a></p>
<p >Delete a semaphore</p>
<p >rt_sem_delete deletes a semaphore previously created with <a class="el" href="group__lxrt.html#ga23569ca638cdac31d41a3c7bff820598">rt_sem_init()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>points to the structure used in the corresponding call to rt_sem_init.</td></tr>
  </table>
  </dd>
</dl>
<p>Any tasks blocked on this semaphore is returned in error and allowed to run when semaphore is destroyed.</p>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. A negative value is returned on failure as described below:<ul>
<li><b>0xFFFF:</b> <em>sem</em> does not refer to a valid semaphore.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count, so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__sem.html#ga630f67adb4cf3169dbbd20098f50933a">_rt_typed_named_sem_init()</a>, <a class="el" href="group__sem.html#gadc2d780b0a0cda1002c61f3ea6c03ed6">rt_named_sem_delete()</a>, and <a class="el" href="group__sem.html#ga702d35153ecd5d780000c3ddc48e3cee">rt_rwl_delete()</a>.</p>

</div>
</div>
<a id="ga5820b53394952aca2e0199c8d56acd5a" name="ga5820b53394952aca2e0199c8d56acd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5820b53394952aca2e0199c8d56acd5a">&#9670;&#160;</a></span>rt_sem_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_sem_init </td>
          <td>(</td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_sem_init"></a></p>
<p >Initialize a counting semaphore.</p>
<p >rt_sem_init initializes a counting fifo queueing semaphore <em>sem</em>.</p>
<p >A semaphore can be used for communication and synchronization among real time tasks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>must point to an allocated <em>SEM</em> structure.</td></tr>
    <tr><td class="paramname">value</td><td>is the initial value of the semaphore.</td></tr>
  </table>
  </dd>
</dl>
<p>Positive values of the semaphore variable show how many tasks can do a rt_sem_wait() call without blocking. Negative value of a semaphore shows how many tasks are blocked on the semaphore queue, waiting to be awaken by calls to rt_sem_signal().</p>
<dl class="section note"><dt>Note</dt><dd>RTAI counting semaphores assume that their counter will never exceed 0xFFFF, such a number being used to signal returns in error. Thus also the initial count value cannot be greater than 0xFFFF. This is an old legacy functioni, there is also rt_typed_sem_init(), allowing to choose among counting, binary and resource semaphores. Resource semaphores have priority inherithance. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#ga90d10dab2101b9255399d176077a34eb">rt_typed_sem_init()</a>.</p>

</div>
</div>
<a id="gaed92c808684d69057e29ffbab0286c39" name="gaed92c808684d69057e29ffbab0286c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed92c808684d69057e29ffbab0286c39">&#9670;&#160;</a></span>rt_sem_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_sem_signal </td>
          <td>(</td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_sem_signal"></a></p>
<p >Signaling a semaphore.</p>
<p >rt_sem_signal signals an event to a semaphore. It is typically called when the task leaves a critical region. The semaphore value is incremented and tested. If the value is not positive, the first task in semaphore's waiting queue is allowed to run. rt_sem_signal never blocks the caller task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga23569ca638cdac31d41a3c7bff820598">rt_sem_init()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. A negative value is returned on failure as described below:<ul>
<li><b>0xFFFF:</b> <em>sem</em> does not refer to a valid semaphore.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count, so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. See rt_sem_wait() notes for some curiosities. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__sem.html#gadbc088a863437fa6aa57ea3638d68e0f">rt_rwl_unlock()</a>.</p>

</div>
</div>
<a id="gad588ef05b34947d18ca6a7be2b7e0baf" name="gad588ef05b34947d18ca6a7be2b7e0baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad588ef05b34947d18ca6a7be2b7e0baf">&#9670;&#160;</a></span>rt_sem_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_sem_wait </td>
          <td>(</td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_sem_wait"></a></p>
<p >Take a semaphore.</p>
<p >rt_sem_wait waits for a event to be signaled to a semaphore. It is typically called when a task enters a critical region. The semaphore value is decremented and tested. If it is still non-negative rt_sem_wait returns immediately. Otherwise the caller task is blocked and queued up. Queuing may happen in priority order or on FIFO base. This is determined by the compile time option <em>SEM_PRIORD</em>. In this case rt_sem_wait returns if:</p><ul>
<li>The caller task is in the first place of the waiting queue and another task issues a rt_sem_signal() call;</li>
<li>An error occurs (e.g. the semaphore is destroyed);</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga23569ca638cdac31d41a3c7bff820598">rt_sem_init()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of events already signaled upon success. A special value" as described below in case of a failure :
- @b 0xFFFF: @e sem does not refer to a valid semaphore.

@note In principle 0xFFFF could theoretically be a usable
      semaphores events count, so it could be returned also under
      normal circumstances. It is unlikely you are going to count
      up to such number of events, in any case avoid counting up to
      0xFFFF.&lt;br&gt;
      Just for curiosity: the original Dijkstra notation for
      rt_sem_wait was a "P" operation, and rt_sem_signal was a "V"
      operation. The name for P comes from the Dutch "prolagen", a
      combination of "proberen" (to probe) and "verlagen" (to
      decrement). Also from the word "passeren" (to pass).&lt;br&gt;
      The name for V comes from the Dutch "verhogen" (to increase)
      or "vrygeven" (to release).  (Source: Daniel Tabak -
      Multiprocessors, Prentice Hall, 1990).&lt;br&gt;
      It should be also remarked that real time programming
      practitioners were using semaphores a long time before
      Dijkstra formalized P and V. "In Italian semaforo" means a traffic light, so that semaphores have an intuitive appeal and their use and meaning is easily understood. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__sem.html#ga0fa5937d2585f2cfdc9830981c6ce606">rt_cond_wait()</a>, <a class="el" href="group__sem.html#ga936135f2fbf612788c69f3c9001d7358">rt_cond_wait_until()</a>, <a class="el" href="group__sem.html#gaaca860a7bf803f759c4b1d5494902e88">rt_rwl_rdlock()</a>, <a class="el" href="group__sem.html#ga020bc9b4c9f543224aeca2999df02b4b">rt_rwl_wrlock()</a>, and <a class="el" href="group__sem.html#gad299949ba77f4a7f13daea7325396560">rt_sem_wait_barrier()</a>.</p>

</div>
</div>
<a id="gad299949ba77f4a7f13daea7325396560" name="gad299949ba77f4a7f13daea7325396560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad299949ba77f4a7f13daea7325396560">&#9670;&#160;</a></span>rt_sem_wait_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_sem_wait_barrier </td>
          <td>(</td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_sem_wait_barrier"></a></p>
<p >Wait on a semaphore barrier.</p>
<p >rt_sem_wait_barrier is a gang waiting in that a task issuing such a request will be blocked till a number of tasks equal to the semaphore count set at rt_sem_init is reached.</p>
<dl class="section return"><dt>Returns</dt><dd>-1 for tasks that waited on the barrier, 0 for the tasks that completed the barrier count. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#gab5e707cd96d1c2c522dc61cf8cb29c66">rt_sem_broadcast()</a>, and <a class="el" href="group__sem.html#gad588ef05b34947d18ca6a7be2b7e0baf">rt_sem_wait()</a>.</p>

</div>
</div>
<a id="ga5fb31cf085f23a80e87fa0c7a62a21bd" name="ga5fb31cf085f23a80e87fa0c7a62a21bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fb31cf085f23a80e87fa0c7a62a21bd">&#9670;&#160;</a></span>rt_sem_wait_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_sem_wait_if </td>
          <td>(</td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_sem_wait_if"></a></p>
<p >Take a semaphore, only if the calling task is not blocked.</p>
<p >rt_sem_wait_if is a version of the semaphore wait operation is similar to rt_sem_wait() but it is never blocks the caller. If the semaphore is not free, rt_sem_wait_if returns immediately and the semaphore value remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga23569ca638cdac31d41a3c7bff820598">rt_sem_init()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of events already signaled upon success. A special value as described below in case of a failure:<ul>
<li><b>0xFFFF:</b> <em>sem</em> does not refer to a valid semaphore.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__sem.html#ga779dc33b9e7cf64d4c08929fa28c2651">rt_rwl_wrlock_if()</a>.</p>

</div>
</div>
<a id="ga5b4cbcee4cb5527fa7f3362a857ba7f8" name="ga5b4cbcee4cb5527fa7f3362a857ba7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b4cbcee4cb5527fa7f3362a857ba7f8">&#9670;&#160;</a></span>rt_sem_wait_timed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_sem_wait_timed </td>
          <td>(</td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_sem_wait_timed"></a></p>
<p >Wait a semaphore with timeout.</p>
<p >rt_sem_wait_timed, like rt_sem_wait_until(), is a timed version of the standard semaphore wait call. The semaphore value is decremented and tested. If it is still non-negative these functions return immediately. Otherwise the caller task is blocked and queued up. Queuing may happen in priority order or on FIFO base. This is determined by the compile time option <em>SEM_PRIORD</em>. In this case the function returns if:</p><ul>
<li>The caller task is in the first place of the waiting queue and an other task issues a rt_sem_signal() call;</li>
<li>a timeout occurs;</li>
<li>an error occurs (e.g. the semaphore is destroyed);</li>
</ul>
<p >In case of a timeout, the semaphore value is incremented before return. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga23569ca638cdac31d41a3c7bff820598">rt_sem_init()</a>.</td></tr>
    <tr><td class="paramname">delay</td><td>is an absolute value to the current time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of events already signaled upon success. A special value as described below in case of a failure:<ul>
<li><b>0xFFFF:</b> <em>sem</em> does not refer to a valid semaphore.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#gaee5fca22a77fc834cf9dc245cc916822">rt_sem_wait_until()</a>.</p>

</div>
</div>
<a id="gaee5fca22a77fc834cf9dc245cc916822" name="gaee5fca22a77fc834cf9dc245cc916822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee5fca22a77fc834cf9dc245cc916822">&#9670;&#160;</a></span>rt_sem_wait_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_sem_wait_until </td>
          <td>(</td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_sem_wait_until"></a></p>
<p >Wait a semaphore with timeout.</p>
<p >rt_sem_wait_until, like rt_sem_wait_timed() is a timed version of the standard semaphore wait call. The semaphore value is decremented and tested. If it is still non-negative these functions return immediately. Otherwise the caller task is blocked and queued up. Queuing may happen in priority order or on FIFO base. This is determined by the compile time option <em>SEM_PRIORD</em>. In this case the function returns if:</p><ul>
<li>The caller task is in the first place of the waiting queue and an other task issues a <a class="el" href="group__sem.html#rt_sem_signal">rt_sem_signal</a> call();</li>
<li>a timeout occurs;</li>
<li>an error occurs (e.g. the semaphore is destroyed);</li>
</ul>
<p >In case of a timeout, the semaphore value is incremented before return. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga23569ca638cdac31d41a3c7bff820598">rt_sem_init()</a>.</td></tr>
    <tr><td class="paramname">time</td><td>is an absolute value to the current time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of events already signaled upon success. Aa special value" as described below in case of a failure:<ul>
<li><b>0xFFFF:</b> <em>sem</em> does not refer to a valid semaphore.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__sem.html#gaeb6033decae25c5dd831d2da2e9631d2">rt_rwl_rdlock_until()</a>, <a class="el" href="group__sem.html#ga40fd64e2e02471cf15a01f78f0aa30d4">rt_rwl_wrlock_until()</a>, and <a class="el" href="group__sem.html#ga5b4cbcee4cb5527fa7f3362a857ba7f8">rt_sem_wait_timed()</a>.</p>

</div>
</div>
<a id="gadf3afe9f696e38646c6504a0bccf54e7" name="gadf3afe9f696e38646c6504a0bccf54e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf3afe9f696e38646c6504a0bccf54e7">&#9670;&#160;</a></span>rt_spl_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_spl_delete </td>
          <td>(</td>
          <td class="paramtype">SPL *&#160;</td>
          <td class="paramname"><em>spl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_spl_delete"></a></p>
<p >Initialize a spinlock.</p>
<p >rt_spl_delete destroies a spinlock <em>spl</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spl</td><td>must point to an allocated <em>SPL</em> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if always. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__sem.html#ga64749a909f8974c977c0fbb2cbef31bb">_rt_named_spl_init()</a>, and <a class="el" href="group__sem.html#ga41116755035f6b46f11b1b9913a06f7b">rt_named_spl_delete()</a>.</p>

</div>
</div>
<a id="gaf070293a2e67d9f9d74760949777035d" name="gaf070293a2e67d9f9d74760949777035d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf070293a2e67d9f9d74760949777035d">&#9670;&#160;</a></span>rt_spl_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_spl_init </td>
          <td>(</td>
          <td class="paramtype">SPL *&#160;</td>
          <td class="paramname"><em>spl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_spl_init"></a></p>
<p >Initialize a spinlock.</p>
<p >rt_spl_init initializes a spinlock <em>spl</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spl</td><td>must point to an allocated <em>SPL</em> structure.</td></tr>
  </table>
  </dd>
</dl>
<p>A spinlock is an active wait synchronization mechanism useful for multi processors very short synchronization, when it is more efficient to wait at a meeting point instead of being suspended and the reactivated, as by using semaphores, to acquire ownership of any object. Spinlocks can be recursed once acquired, a recurring owner must care of unlocking as many times as he took the spinlock.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if always. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__sem.html#ga64749a909f8974c977c0fbb2cbef31bb">_rt_named_spl_init()</a>.</p>

</div>
</div>
<a id="gaf6ecd2d5d16a117bcd47c7c180a6b67e" name="gaf6ecd2d5d16a117bcd47c7c180a6b67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6ecd2d5d16a117bcd47c7c180a6b67e">&#9670;&#160;</a></span>rt_spl_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_spl_lock </td>
          <td>(</td>
          <td class="paramtype">SPL *&#160;</td>
          <td class="paramname"><em>spl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_spl_lock"></a></p>
<p >Acquire a spinlock.</p>
<p >rt_spl_lock acquires a spinlock <em>spl</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spl</td><td>must point to an allocated <em>SPL</em> structure.</td></tr>
  </table>
  </dd>
</dl>
<p>rt_spl_lock spins on lock till it can be acquired. If a tasks asks for lock it owns already it will acquire it immediately but will have to care to unlock it as many times as it recursed the spinlock ownership.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if always. </dd></dl>

</div>
</div>
<a id="ga5572b9e662e3f999947bc8b405596ac2" name="ga5572b9e662e3f999947bc8b405596ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5572b9e662e3f999947bc8b405596ac2">&#9670;&#160;</a></span>rt_spl_lock_if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_spl_lock_if </td>
          <td>(</td>
          <td class="paramtype">SPL *&#160;</td>
          <td class="paramname"><em>spl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_spl_lock_if"></a></p>
<p >Acquire a spinlock without waiting.</p>
<p >rt_spl_lock_if acquires a spinlock <em>spl</em> without waiting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spl</td><td>must point to an allocated <em>SPL</em> structure.</td></tr>
  </table>
  </dd>
</dl>
<p>rt_spl_lock_if tries to acquire a spinlock but will not spin on it if it is owned already.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if it succeeded, -1 if the lock was owned already. </dd></dl>

</div>
</div>
<a id="ga430300be7be0dc7e237017620490f8d7" name="ga430300be7be0dc7e237017620490f8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga430300be7be0dc7e237017620490f8d7">&#9670;&#160;</a></span>rt_spl_lock_timed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_spl_lock_timed </td>
          <td>(</td>
          <td class="paramtype">SPL *&#160;</td>
          <td class="paramname"><em>spl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_spl_lock_timed"></a></p>
<p >Acquire a spinlock with timeout.</p>
<p >rt_spl_lock_timed acquires a spinlock <em>spl</em>, but waiting spinning only for an allowed time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spl</td><td>must point to an allocated <em>SPL</em> structure.</td></tr>
    <tr><td class="paramname">ns</td><td>timeout</td></tr>
  </table>
  </dd>
</dl>
<p>rt_spl_lock spins on lock till it can be acquired, as for rt_spl_lock, but only for an allowed time. If the spinlock cannot be acquired in time the functions returns in error. This function can be usefull either in itself or as a diagnosis toll during code development.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if the spinlock was acquired, -1 if a timeout occured. </dd></dl>

</div>
</div>
<a id="ga4c348647f040b093266f6c70ca06d211" name="ga4c348647f040b093266f6c70ca06d211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c348647f040b093266f6c70ca06d211">&#9670;&#160;</a></span>rt_spl_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_spl_unlock </td>
          <td>(</td>
          <td class="paramtype">SPL *&#160;</td>
          <td class="paramname"><em>spl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_spl_unlock"></a></p>
<p >Release an owned spinlock.</p>
<p >rt_spl_lock releases an owned spinlock <em>spl</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spl</td><td>must point to an allocated <em>SPL</em> structure.</td></tr>
  </table>
  </dd>
</dl>
<p>rt_spl_unlock releases an owned lock. The spinlock can remain locked and its ownership can remain with the task is the spinlock acquisition was recursed.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if the function was used legally, -1 if a tasks tries to unlock a spinlock it does not own. </dd></dl>

</div>
</div>
<a id="ga62fdb5ac5e42663e4d132114fc8502c3" name="ga62fdb5ac5e42663e4d132114fc8502c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62fdb5ac5e42663e4d132114fc8502c3">&#9670;&#160;</a></span>rt_typed_rwl_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_typed_rwl_init </td>
          <td>(</td>
          <td class="paramtype">RWL *&#160;</td>
          <td class="paramname"><em>rwl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_rwl_init"></a></p>
<p >Initialize a multi readers single writer lock.</p>
<p >rt_rwl_init initializes a multi readers single writer lock <em>rwl</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwl</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
  </dd>
</dl>
<p>A multi readers single writer lock (RWL) is a synchronization mechanism that allows to have simultaneous read only access to an object, while only one task can have write access. A data set which is searched more frequently than it is changed can be usefully controlled by using an rwl. The lock acquisition policy is determined solely on the priority of tasks applying to own a lock.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if always. </dd></dl>

<p class="reference">References <a class="el" href="group__sem.html#ga90d10dab2101b9255399d176077a34eb">rt_typed_sem_init()</a>.</p>

</div>
</div>
<a id="ga90d10dab2101b9255399d176077a34eb" name="ga90d10dab2101b9255399d176077a34eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90d10dab2101b9255399d176077a34eb">&#9670;&#160;</a></span>rt_typed_sem_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE void rt_typed_sem_init </td>
          <td>(</td>
          <td class="paramtype">SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_typed_sem_init"></a></p>
<p >Initialize a specifically typed (counting, binary, resource) semaphore</p>
<p >rt_typed_sem_init initializes a semaphore <em>sem</em> of type <em>type</em>. A semaphore can be used for communication and synchronization among real time tasks. Negative value of a semaphore shows how many tasks are blocked on the semaphore queue, waiting to be awaken by calls to rt_sem_signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>must point to an allocated SEM structure.</td></tr>
    <tr><td class="paramname">value</td><td>is the initial value of the semaphore, always set to 1 for a resource semaphore.</td></tr>
    <tr><td class="paramname">type</td><td>is the semaphore type and queuing policy. It can be an OR a semaphore kind: CNT_SEM for counting semaphores, BIN_SEM for binary semaphores, RES_SEM for resource semaphores; and queuing policy: FIFO_Q, PRIO_Q for a fifo and priority queueing respectively. Resource semaphores will enforce a PRIO_Q policy anyhow.</td></tr>
  </table>
  </dd>
</dl>
<p>Counting semaphores can register up to 0xFFFE events. Binary semaphores do not count signalled events, their count will never exceed 1 whatever number of events is signaled to them. Resource semaphores are special binary semaphores suitable for managing resources. The task that acquires a resource semaphore becomes its owner, also called resource owner, since it is the only one capable of manipulating the resource the semaphore is protecting. The owner has its priority increased to that of any task blocking on a wait to the semaphore. Such a feature, called priority inheritance, ensures that a high priority task is never slaved to a lower priority one, thus allowing to avoid any deadlock due to priority inversion. Resource semaphores can be recursed, i.e. their task owner is not blocked by nested waits placed on an owned resource. The owner must insure that it will signal the semaphore, in reversed order, as many times as he waited on it. Note that that full priority inheritance is supported both for resource semaphores and inter task messages, for a singly owned resource. Instead it becomes an adaptive priority ceiling when a task owns multiple resources, including messages sent to him. In such a case in fact its priority is returned to its base one only when all such resources are released and no message is waiting for being received. This is a compromise design choice aimed at avoiding extensive searches for the new priority to be inherited across multiply owned resources and blocked tasks sending messages to him. Such a solution will be implemented only if it proves necessary. Note also that, to avoid <em>deadlocks</em>, a task owning a resource semaphore cannot be suspended. Any rt_task_suspend() posed on it is just registered. An owner task will go into suspend state only when it releases all the owned resources.</p>
<dl class="section note"><dt>Note</dt><dd>if the legacy error return values scheme is used RTAI counting semaphores assume that their counter will never exceed 0xFFFF, such a number being used to signal returns in error. Thus also the initial count value cannot be greater 0xFFFF. The new error return scheme allows counts in the order of billions instead. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__sem.html#ga630f67adb4cf3169dbbd20098f50933a">_rt_typed_named_sem_init()</a>, <a class="el" href="group__sem.html#ga5820b53394952aca2e0199c8d56acd5a">rt_sem_init()</a>, and <a class="el" href="group__sem.html#ga62fdb5ac5e42663e4d132114fc8502c3">rt_typed_rwl_init()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
