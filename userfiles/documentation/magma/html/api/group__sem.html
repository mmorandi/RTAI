<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Semaphore functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Semaphore functions</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sem_8c.html">sem.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Semaphore functions. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga2">rt_typed_sem_init</a> (SEM *sem, int value, int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a specifically typed (counting, binary, resource) semaphore.  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga3">rt_sem_init</a> (SEM *sem, int value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a counting semaphore.  <a href="#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga4">rt_sem_delete</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a semaphore.  <a href="#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga6">rt_sem_signal</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signaling a semaphore.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga7">rt_sem_broadcast</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signaling a semaphore.  <a href="#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga8">rt_sem_wait</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take a semaphore.  <a href="#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga9">rt_sem_wait_if</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take a semaphore, only if the calling task is not blocked.  <a href="#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga10">rt_sem_wait_until</a> (SEM *sem, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a semaphore with timeout.  <a href="#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga11">rt_sem_wait_timed</a> (SEM *sem, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a semaphore with timeout.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga12">rt_sem_wait_barrier</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on a semaphore barrier.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga13">rt_cond_signal</a> (CND *cnd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a signal to a conditional variable.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga15">rt_cond_wait</a> (CND *cnd, SEM *mtx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a signal to a conditional variable.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga16">rt_cond_wait_until</a> (CND *cnd, SEM *mtx, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a semaphore with timeout.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga17">rt_cond_wait_timed</a> (CND *cnd, SEM *mtx, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait a semaphore with timeout.  <a href="#ga17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga18">rt_rwl_init</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a multi readers single writer lock.  <a href="#ga18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga19">rt_rwl_delete</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">destroys a multi readers single writer lock.  <a href="#ga19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga20">rt_rwl_rdlock</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">acquires a multi readers single writer lock for reading.  <a href="#ga20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga21">rt_rwl_rdlock_if</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to acquire a multi readers single writer lock just for reading.  <a href="#ga21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga22">rt_rwl_rdlock_until</a> (RWL *rwl, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to acquire a multi readers single writer lock for reading within an absolute deadline time.  <a href="#ga22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga23">rt_rwl_rdlock_timed</a> (RWL *rwl, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to acquire a multi readers single writer lock for reading within a relative deadline time.  <a href="#ga23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga24">rt_rwl_wrlock</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">acquires a multi readers single writer lock for wrtiting.  <a href="#ga24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga25">rt_rwl_wrlock_if</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">acquires a multi readers single writer lock for writing.  <a href="#ga25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga26">rt_rwl_wrlock_until</a> (RWL *rwl, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to acquire a multi readers single writer lock for writing within an absolute deadline time.  <a href="#ga26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga27">rt_rwl_wrlock_timed</a> (RWL *rwl, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">try to acquire a multi readers single writer lock for writing within a relative deadline time.  <a href="#ga27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga28">rt_rwl_unlock</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unlock an acquired multi readers single writer lock.  <a href="#ga28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga29">rt_spl_init</a> (SPL *spl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a spinlock.  <a href="#ga29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga30">rt_spl_delete</a> (SPL *spl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a spinlock.  <a href="#ga30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga31">rt_spl_lock</a> (SPL *spl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire a spinlock.  <a href="#ga31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga32">rt_spl_lock_if</a> (SPL *spl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire a spinlock without waiting.  <a href="#ga32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga33">rt_spl_lock_timed</a> (SPL *spl, unsigned long ns)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire a spinlock with timeout.  <a href="#ga33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga34">rt_spl_unlock</a> (SPL *spl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release an owned spinlock.  <a href="#ga34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SEM *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga35">_rt_typed_named_sem_init</a> (unsigned long sem_name, int value, int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a specifically typed (counting, binary, resource) semaphore identified by a name.  <a href="#ga35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga36">rt_named_sem_delete</a> (SEM *sem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a semaphore initialized in named mode.  <a href="#ga36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RWL *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga37">_rt_named_rwl_init</a> (unsigned long rwl_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a multi readers single writer lock identified by a name.  <a href="#ga37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga38">rt_named_rwl_delete</a> (RWL *rwl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a multi readers single writer lock in named mode.  <a href="#ga38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPL *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga39">_rt_named_spl_init</a> (unsigned long spl_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a spinlock identified by a name.  <a href="#ga39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sem.html#ga40">rt_named_spl_delete</a> (SPL *spl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a spinlock in named mode.  <a href="#ga40"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga37" doxytag="sem.c::_rt_named_rwl_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RWL* _rt_named_rwl_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rwl_name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a multi readers single writer lock identified by a name. 
<p>
<a class="anchor" name="_rt_named_rwl_init"></a><p>
_rt_named_rwl_init allocate and initializes a multi readers single writer lock (RWL) identified by <em>name</em>. Once the lock structure is allocated the initialization is as for rt_rwl_init. The function returns the handle pointing to the allocated multi readers single writer lock o structure, to be used as the usual lock address in all rwl based services. Named objects are useful for use among different processes, kernel/user space and in distributed applications, see netrpc.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rwl_name</em>&nbsp;</td><td>is the identifier associated with the returned object.</td></tr>
  </table>
</dl>
Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
As for all the named initialization functions it must be remarked that only the very first call to initilize/create a named RTAI object does a real allocation of the object, any following call with the same name will just increase its usage count. In any case the function returns a pointer to the named object, or zero if in error.<p>
<dl compact><dt><b>Returns:</b></dt><dd>either a valid pointer or 0 if in error. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga39" doxytag="sem.c::_rt_named_spl_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">SPL* _rt_named_spl_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>spl_name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a spinlock identified by a name. 
<p>
<a class="anchor" name="_rt_named_spl_init"></a><p>
_rt_named_spl_init allocate and initializes a spinlock (SPL) identified by <em>name</em>. Once the spinlock structure is allocated the initialization is as for rt_spl_init. The function returns the handle pointing to the allocated spinlock structure, to be used as the usual spinlock address in all spinlock based services. Named objects are useful for use among different processes and kernel/user space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spl_name</em>&nbsp;</td><td>is the identifier associated with the returned object.</td></tr>
  </table>
</dl>
Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
As for all the named initialization functions it must be remarked that only the very first call to initilize/create a named RTAI object does a real allocation of the object, any following call with the same name will just increase its usage count. In any case the function returns a pointer to the named object, or zero if in error.<p>
<dl compact><dt><b>Returns:</b></dt><dd>either a valid pointer or 0 if in error. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga35" doxytag="sem.c::_rt_typed_named_sem_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">SEM* _rt_typed_named_sem_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>sem_name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a specifically typed (counting, binary, resource) semaphore identified by a name. 
<p>
<a class="anchor" name="_rt_typed_named_sem_init"></a><p>
_rt_typed_named_sem_init allocate and initializes a semaphore identified by <em>name</em> of type <em>type</em>. Once the semaphore structure is allocated the initialization is as for rt_typed_sem_init. The function returns the handle pointing to the allocated semaphore structure, to be used as the usual semaphore address in all semaphore based services. Named objects are useful for use among different processes, kernel/user space and in distributed applications, see netrpc.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem_name</em>&nbsp;</td><td>is the identifier associated with the returned object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>is the initial value of the semaphore, always set to 1 for a resource semaphore.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>is the semaphore type and queuing policy. It can be an OR a semaphore kind: CNT_SEM for counting semaphores, BIN_SEM for binary semaphores, RES_SEM for resource semaphores; and queuing policy: FIFO_Q, PRIO_Q for a fifo and priority queueing respectively. Resource semaphores will enforce a PRIO_Q policy anyhow.</td></tr>
  </table>
</dl>
Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
See rt_typed_sem_init for further clues.<p>
As for all the named initialization functions it must be remarked that only the very first call to initilize/create a named RTAI object does a real allocation of the object, any following call with the same name will just increase its usage count. In any case the function returns a pointer to the named object, or zero if in error.<p>
<dl compact><dt><b>Returns:</b></dt><dd>either a valid pointer or 0 if in error. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="sem.c::rt_cond_signal"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_cond_signal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CND *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>cnd</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for a signal to a conditional variable. 
<p>
<a class="anchor" name="rt_cond_signal"></a><p>
rt_cond_signal resumes one of the tasks that are waiting on the condition semaphore cnd. Nothing happens if no task is waiting on <em>cnd</em>, while it resumed the first queued task blocked on cnd, according to the queueing method set at rt_cond_init.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnd</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga383">rt_cond_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="sem.c::rt_cond_wait"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_cond_wait           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CND *&nbsp;</td>
          <td class="mdname" nowrap> <em>cnd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>mtx</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait for a signal to a conditional variable. 
<p>
<a class="anchor" name="rt_cond_wait"></a><p>
rt_cond_wait atomically unlocks mtx (as for using rt_sem_signal) and waits for the condition semaphore cnd to be signaled. The task execution is suspended until the condition semaphore is signalled. Mtx must be obtained by the calling task, before calling rt_cond_wait is called. Before returning to the calling task rt_cond_wait reacquires mtx by calling rt_sem_wait.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnd</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga383">rt_cond_init</a>().</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mtx</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__sem.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on succes, SEM_ERR in case of error. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga17" doxytag="sem.c::rt_cond_wait_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_cond_wait_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CND *&nbsp;</td>
          <td class="mdname" nowrap> <em>cnd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait a semaphore with timeout. 
<p>
<a class="anchor" name="rt_cond_wait_timed"></a><p>
rt_cond_wait_timed atomically unlocks mtx (as for using rt_sem_signal) and waits for the condition semaphore cnd to be signalled. The task execution is suspended until the condition semaphore is either signaled or a timeout expires. Mtx must be obtained by the calling task, before calling rt_cond_wait is called. Before returning to the calling task rt_cond_wait_until reacquires mtx by calling rt_sem_wait and returns a value to indicate if it has been signalled pr timedout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnd</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga383">rt_cond_init</a>().</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mtx</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__sem.html#rt_sem_init">rt_sem_init</a>().</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>is a realtive time values with respect to the current time, in timer count unit.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if it was signaled, SEM_TIMOUT if a timeout occured, SEM_ERR if the task has been resumed because of any other action (likely cnd was deleted). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="sem.c::rt_cond_wait_until"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_cond_wait_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">CND *&nbsp;</td>
          <td class="mdname" nowrap> <em>cnd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait a semaphore with timeout. 
<p>
<a class="anchor" name="rt_cond_wait_until"></a><p>
rt_cond_wait_until atomically unlocks mtx (as for using rt_sem_signal) and waits for the condition semaphore cnd to be signalled. The task execution is suspended until the condition semaphore is either signaled or a timeout expires. Mtx must be obtained by the calling task, before calling rt_cond_wait is called. Before returning to the calling task rt_cond_wait_until reacquires mtx by calling rt_sem_wait and returns a value to indicate if it has been signalled pr timedout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cnd</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__lxrt.html#ga383">rt_cond_init</a>().</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mtx</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__sem.html#rt_sem_init">rt_sem_init</a>().</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>is an absolute value to the current time, in timer count unit.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if it was signaled, SEM_TIMOUT if a timeout occured, SEM_ERR if the task has been resumed because of any other action (likely cnd was deleted). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga38" doxytag="sem.c::rt_named_rwl_delete"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_named_rwl_delete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rwl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a multi readers single writer lock in named mode. 
<p>
<a class="anchor" name="rt_named_rwl_delete"></a><p>
rt_named_rwl_delete deletes a multi readers single writer lock previously created with <a class="el" href="group__sem.html#_rt_named_rwl_init">_rt_named_rwl_init</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rwl</em>&nbsp;</td><td>points to the structure pointer returned by a corresponding call to rt_named_rwl_init.</td></tr>
  </table>
</dl>
As it is done by all the named allocation functions delete calls have just the effect of decrementing a usage count till the last is done, as that is the one the really frees the object.<p>
<dl compact><dt><b>Returns:</b></dt><dd>an int &gt;=0 is returned upon success, SEM_ERR if it failed to delete the multi readers single writer lock, -EFAULT if the lock does not exist anymore. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga36" doxytag="sem.c::rt_named_sem_delete"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_named_sem_delete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a semaphore initialized in named mode. 
<p>
<a class="anchor" name="rt_named_sem_delete"></a><p>
rt_named_sem_delete deletes a semaphore previously created with <a class="el" href="group__sem.html#_rt_typed_named_sem_init">_rt_typed_named_sem_init</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>points to the structure pointer returned by a corresponding call to _rt_typed_named_sem_init.</td></tr>
  </table>
</dl>
Any tasks blocked on this semaphore is returned in error and allowed to run when semaphore is destroyed. As it is done by all the named allocation functions delete calls have just the effect of decrementing a usage count till the last is done, as that is the one the really frees the object.<p>
<dl compact><dt><b>Returns:</b></dt><dd>an int &gt;=0 is returned upon success, SEM_ERR if it failed to delete the semafore, -EFAULT if the semaphore does not exist anymore. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga40" doxytag="sem.c::rt_named_spl_delete"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_named_spl_delete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SPL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>spl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a spinlock in named mode. 
<p>
<a class="anchor" name="rt_named_spl_delete"></a><p>
rt_named_spl_delete deletes a spinlock previously created with <a class="el" href="group__sem.html#_rt_named_spl_init">_rt_named_spl_init</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spl</em>&nbsp;</td><td>points to the structure pointer returned by a corresponding call to rt_named_spl_init.</td></tr>
  </table>
</dl>
As it is done by all the named allocation functions delete calls have just the effect of decrementing a usage count till the last is done, as that is the one the really frees the object.<p>
<dl compact><dt><b>Returns:</b></dt><dd>an int &gt;=0 is returned upon success, -EFAULT if the spinlock does not exist anymore. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga19" doxytag="sem.c::rt_rwl_delete"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_rwl_delete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rwl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
destroys a multi readers single writer lock. 
<p>
<a class="anchor" name="rt_rwl_delete"></a><p>
rt_rwl_init destroys a multi readers single writer lock <em>rwl</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if OK, SEM_ERR if anything went wrong. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga18" doxytag="sem.c::rt_rwl_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_rwl_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rwl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a multi readers single writer lock. 
<p>
<a class="anchor" name="rt_rwl_init"></a><p>
rt_rwl_init initializes a multi readers single writer lock <em>rwl</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
</dl>
A multi readers single writer lock (RWL) is a synchronization mechanism that allows to have simultaneous read only access to an object, while only one task can have write access. A data set which is searched more frequently than it is changed can be usefully controlled by using an rwl. The lock acquisition policy is determined solely on the priority of tasks applying to own a lock.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 if always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga20" doxytag="sem.c::rt_rwl_rdlock"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_rwl_rdlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rwl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
acquires a multi readers single writer lock for reading. 
<p>
<a class="anchor" name="rt_rwl_rdlock"></a><p>
rt_rwl_rdlock acquires a multi readers single writer lock <em>rwl</em> for reading. The calling task will block only if any writer owns the lock already or there are writers with higher priority waiting to acquire write access.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if OK, SEM_ERR if anything went wrong after being blocked. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga21" doxytag="sem.c::rt_rwl_rdlock_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_rwl_rdlock_if           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rwl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
try to acquire a multi readers single writer lock just for reading. 
<p>
<a class="anchor" name="rt_rwl_rdlock_if"></a><p>
rt_rwl_rdlock_if tries to acquire a multi readers single writer lock <em>rwl</em> for reading immediately, i.e. without blocking if a writer owns the lock or there are writers with higher priority waiting to acquire write access.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the lock was acquired, -1 if the lock was already owned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga23" doxytag="sem.c::rt_rwl_rdlock_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_rwl_rdlock_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname" nowrap> <em>rwl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
try to acquire a multi readers single writer lock for reading within a relative deadline time. 
<p>
<a class="anchor" name="rt_rwl_rdlock_timed"></a><p>
rt_rwl_rdlock_timed tries to acquire a multi readers single writer lock <em>rwl</em> for reading, as for rt_rwl_rdlock, but timing out if the lock has not been acquired within an assigned deadline.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>is the time delay within which the lock must be acquired, in internal count units.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the lock was acquired, SEM_TIMOUT if the deadline expired without acquiring the lock, SEM_ERR in case something went wrong. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga22" doxytag="sem.c::rt_rwl_rdlock_until"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_rwl_rdlock_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname" nowrap> <em>rwl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
try to acquire a multi readers single writer lock for reading within an absolute deadline time. 
<p>
<a class="anchor" name="rt_rwl_rdlock_until"></a><p>
rt_rwl_rdlock_untill tries to acquire a multi readers single writer lock <em>rwl</em> for reading, as for rt_rwl_rdlock, but timing out if the lock has not been acquired within an assigned deadline.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>is the time deadline, in internal count units.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the lock was acquired, SEM_TIMOUT if the deadline expired without acquiring the lock, SEM_ERR in case something went wrong. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga28" doxytag="sem.c::rt_rwl_unlock"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_rwl_unlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rwl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
unlock an acquired multi readers single writer lock. 
<p>
<a class="anchor" name="rt_rwl_unlock"></a><p>
rt_rwl_unlock unlocks an acquired multi readers single writer lock <em>rwl</em>. After releasing the lock any task waiting to acquire it will own the lock according to its priority, whether it is a reader or a writer, otherwise the lock will be fully unlocked.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga24" doxytag="sem.c::rt_rwl_wrlock"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_rwl_wrlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rwl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
acquires a multi readers single writer lock for wrtiting. 
<p>
<a class="anchor" name="rt_rwl_wrlock"></a><p>
rt_rwl_rwlock acquires a multi readers single writer lock <em>rwl</em> for writing. The calling task will block if any other task, reader or writer, owns the lock already.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if OK, SEM_ERR if anything went wrong after being blocked. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga25" doxytag="sem.c::rt_rwl_wrlock_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_rwl_wrlock_if           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rwl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
acquires a multi readers single writer lock for writing. 
<p>
<a class="anchor" name="rt_rwl_wrlock_if"></a><p>
rt_rwl_wrlock_if try to acquire a multi readers single writer lock <em>rwl</em> for writing immediately, i.e without blocking if the lock is owned already.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the lock was acquired, -1 if the lock was already owned. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga27" doxytag="sem.c::rt_rwl_wrlock_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_rwl_wrlock_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname" nowrap> <em>rwl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
try to acquire a multi readers single writer lock for writing within a relative deadline time. 
<p>
<a class="anchor" name="rt_rwl_wrlock_timed"></a><p>
rt_rwl_wrlock_timed tries to acquire a multi readers single writer lock <em>rwl</em> for writing, as for rt_rwl_wrlock, timing out if the lock has not been acquired within an assigned deadline.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>is the time delay within which the lock must be acquired, in internal count units.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the lock was acquired, SEM_TIMOUT if the deadline expired without acquiring the lock, SEM_ERR in case something went wrong. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga26" doxytag="sem.c::rt_rwl_wrlock_until"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_rwl_wrlock_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RWL *&nbsp;</td>
          <td class="mdname" nowrap> <em>rwl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
try to acquire a multi readers single writer lock for writing within an absolute deadline time. 
<p>
<a class="anchor" name="rt_rwl_wrlock_until"></a><p>
rt_rwl_rwlock_until tries to acquire a multi readers single writer lock <em>rwl</em> for writing, as for rt_rwl_rwlock, but timing out if the lock has not been acquired within an assigned deadline.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rwl</em>&nbsp;</td><td>must point to an allocated <em>RWL</em> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>is the time deadline, in internal count units.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the lock was acquired, SEM_TIMOUT if the deadline expired without acquiring the lock, SEM_ERR in case something went wrong. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="sem.c::rt_sem_broadcast"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_sem_broadcast           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signaling a semaphore. 
<p>
<a class="anchor" name="rt_sem_broadcast"></a><p>
rt_sem_broadcast signals an event to a semaphore that unblocks all tasks waiting on it. It is used as a support for RTAI proper conditional variables but can be of help in many other instances. After the broadcast the semaphore counts is set to zero, thus all tasks waiting on it will blocked.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__sem.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="sem.c::rt_sem_delete"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_sem_delete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete a semaphore. 
<p>
<a class="anchor" name="rt_sem_delete"></a><p>
rt_sem_delete deletes a semaphore previously created with <a class="el" href="group__sem.html#rt_sem_init">rt_sem_init</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>points to the structure used in the corresponding call to rt_sem_init.</td></tr>
  </table>
</dl>
Any tasks blocked on this semaphore is returned in error and allowed to run when semaphore is destroyed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. A negative value is returned on failure as described below:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count, so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="sem.c::rt_sem_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_sem_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a counting semaphore. 
<p>
<a class="anchor" name="rt_sem_init"></a><p>
rt_sem_init initializes a counting fifo queueing semaphore <em>sem</em>.<p>
A semaphore can be used for communication and synchronization among real time tasks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>must point to an allocated <em>SEM</em> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>is the initial value of the semaphore.</td></tr>
  </table>
</dl>
Positive values of the semaphore variable show how many tasks can do a <a class="el" href="group__sem.html#rt_sem_wait">rt_sem_wait</a>() call without blocking. Negative value of a semaphore shows how many tasks are blocked on the semaphore queue, waiting to be awaken by calls to <a class="el" href="group__sem.html#rt_sem_signal">rt_sem_signal</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>RTAI counting semaphores assume that their counter will never exceed 0xFFFF, such a number being used to signal returns in error. Thus also the initial count value cannot be greater than 0xFFFF. This is an old legacy function. RTAI 24.1.xx has also <a class="el" href="group__sem.html#rt_typed_sem_init">rt_typed_sem_init</a>(), allowing to choose among counting, binary and resource semaphores. Resource semaphores have priority inherithance. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="sem.c::rt_sem_signal"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_sem_signal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Signaling a semaphore. 
<p>
<a class="anchor" name="rt_sem_signal"></a><p>
rt_sem_signal signals an event to a semaphore. It is typically called when the task leaves a critical region. The semaphore value is incremented and tested. If the value is not positive, the first task in semaphore's waiting queue is allowed to run. rt_sem_signal never blocks the caller task.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__sem.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. A negative value is returned on failure as described below:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count, so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. See <a class="el" href="group__sem.html#rt_sem_wait">rt_sem_wait</a>() notes for some curiosities. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga8" doxytag="sem.c::rt_sem_wait"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_sem_wait           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Take a semaphore. 
<p>
<a class="anchor" name="rt_sem_wait"></a><p>
rt_sem_wait waits for a event to be signaled to a semaphore. It is typically called when a task enters a critical region. The semaphore value is decremented and tested. If it is still non-negative rt_sem_wait returns immediately. Otherwise the caller task is blocked and queued up. Queuing may happen in priority order or on FIFO base. This is determined by the compile time option <em>SEM_PRIORD</em>. In this case rt_sem_wait returns if:<ul>
<li>The caller task is in the first place of the waiting queue and another task issues a <a class="el" href="group__sem.html#rt_sem_signal">rt_sem_signal</a>() call;</li><li>An error occurs (e.g. the semaphore is destroyed);</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__sem.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of events already signaled upon success. A special value" as described below in case of a failure :<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count, so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF.<br>
 Just for curiosity: the original Dijkstra notation for rt_sem_wait was a "P" operation, and rt_sem_signal was a "V" operation. The name for P comes from the Dutch "prolagen", a combination of "proberen" (to probe) and "verlagen" (to decrement). Also from the word "passeren" (to pass).<br>
 The name for V comes from the Dutch "verhogen" (to increase) or "vrygeven" (to release). (Source: Daniel Tabak - Multiprocessors, Prentice Hall, 1990).<br>
 It should be also remarked that real time programming practitioners were using semaphores a long time before Dijkstra formalized P and V. "In Italian semaforo" means a traffic light, so that semaphores have an intuitive appeal and their use and meaning is easily understood. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="sem.c::rt_sem_wait_barrier"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_sem_wait_barrier           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait on a semaphore barrier. 
<p>
<a class="anchor" name="rt_sem_wait_barrier"></a><p>
rt_sem_wait_barrier is a gang waiting in that a task issuing such a request will be blocked till a number of tasks equal to the semaphore count set at rt_sem_init is reached.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="sem.c::rt_sem_wait_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_sem_wait_if           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>sem</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Take a semaphore, only if the calling task is not blocked. 
<p>
<a class="anchor" name="rt_sem_wait_if"></a><p>
rt_sem_wait_if is a version of the semaphore wait operation is similar to <a class="el" href="group__sem.html#rt_sem_wait">rt_sem_wait</a>() but it is never blocks the caller. If the semaphore is not free, rt_sem_wait_if returns immediately and the semaphore value remains unchanged.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__sem.html#rt_sem_init">rt_sem_init</a>().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of events already signaled upon success. A special value as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="sem.c::rt_sem_wait_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_sem_wait_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait a semaphore with timeout. 
<p>
<a class="anchor" name="rt_sem_wait_timed"></a><p>
rt_sem_wait_timed, like <a class="el" href="group__sem.html#rt_sem_wait_until">rt_sem_wait_until</a>(), is a timed version of the standard semaphore wait call. The semaphore value is decremented and tested. If it is still non-negative these functions return immediately. Otherwise the caller task is blocked and queued up. Queuing may happen in priority order or on FIFO base. This is determined by the compile time option <em>SEM_PRIORD</em>. In this case the function returns if:<ul>
<li>The caller task is in the first place of the waiting queue and an other task issues a <a class="el" href="group__sem.html#rt_sem_signal">rt_sem_signal</a>() call;</li><li>a timeout occurs;</li><li>an error occurs (e.g. the semaphore is destroyed);</li></ul>
<p>
In case of a timeout, the semaphore value is incremented before return.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__sem.html#rt_sem_init">rt_sem_init</a>().</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>is an absolute value to the current time.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of events already signaled upon success. A special value as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga10" doxytag="sem.c::rt_sem_wait_until"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_sem_wait_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait a semaphore with timeout. 
<p>
<a class="anchor" name="rt_sem_wait_until"></a><p>
rt_sem_wait_until, like <a class="el" href="group__sem.html#rt_sem_wait_timed">rt_sem_wait_timed</a>() is a timed version of the standard semaphore wait call. The semaphore value is decremented and tested. If it is still non-negative these functions return immediately. Otherwise the caller task is blocked and queued up. Queuing may happen in priority order or on FIFO base. This is determined by the compile time option <em>SEM_PRIORD</em>. In this case the function returns if:<ul>
<li>The caller task is in the first place of the waiting queue and an other task issues a <a class="el" href="group__sem.html#rt_sem_signal">rt_sem_signal</a> call();</li><li>a timeout occurs;</li><li>an error occurs (e.g. the semaphore is destroyed);</li></ul>
<p>
In case of a timeout, the semaphore value is incremented before return.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>points to the structure used in the call to <a class="el" href="group__sem.html#rt_sem_init">rt_sem_init</a>().</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>is an absolute value to the current time.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of events already signaled upon success. Aa special value" as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>sem</em> does not refer to a valid semaphore.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>In principle 0xFFFF could theoretically be a usable semaphores events count so it could be returned also under normal circumstances. It is unlikely you are going to count up to such number of events, in any case avoid counting up to 0xFFFF. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga30" doxytag="sem.c::rt_spl_delete"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_spl_delete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SPL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>spl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a spinlock. 
<p>
<a class="anchor" name="rt_spl_delete"></a><p>
rt_spl_delete destroies a spinlock <em>spl</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spl</em>&nbsp;</td><td>must point to an allocated <em>SPL</em> structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga29" doxytag="sem.c::rt_spl_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_spl_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SPL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>spl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a spinlock. 
<p>
<a class="anchor" name="rt_spl_init"></a><p>
rt_spl_init initializes a spinlock <em>spl</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spl</em>&nbsp;</td><td>must point to an allocated <em>SPL</em> structure.</td></tr>
  </table>
</dl>
A spinlock is an active wait synchronization mechanism useful for multi processors very short synchronization, when it is more efficient to wait at a meeting point instead of being suspended and the reactivated, as by using semaphores, to acquire ownership of any object. Spinlocks can be recursed once acquired, a recurring owner must care of unlocking as many times as he took the spinlock.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 if always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga31" doxytag="sem.c::rt_spl_lock"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_spl_lock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SPL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>spl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquire a spinlock. 
<p>
<a class="anchor" name="rt_spl_lock"></a><p>
rt_spl_lock acquires a spinlock <em>spl</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spl</em>&nbsp;</td><td>must point to an allocated <em>SPL</em> structure.</td></tr>
  </table>
</dl>
rt_spl_lock spins on lock till it can be acquired. If a tasks asks for lock it owns already it will acquire it immediately but will have to care to unlock it as many times as it recursed the spinlock ownership.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 if always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga32" doxytag="sem.c::rt_spl_lock_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_spl_lock_if           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SPL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>spl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquire a spinlock without waiting. 
<p>
<a class="anchor" name="rt_spl_lock_if"></a><p>
rt_spl_lock_if acquires a spinlock <em>spl</em> without waiting.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spl</em>&nbsp;</td><td>must point to an allocated <em>SPL</em> structure.</td></tr>
  </table>
</dl>
rt_spl_lock_if tries to acquire a spinlock but will not spin on it if it is owned already.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 if it succeeded, -1 if the lock was owned already. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga33" doxytag="sem.c::rt_spl_lock_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_spl_lock_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SPL *&nbsp;</td>
          <td class="mdname" nowrap> <em>spl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>ns</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquire a spinlock with timeout. 
<p>
<a class="anchor" name="rt_spl_lock_timed"></a><p>
rt_spl_lock_timed acquires a spinlock <em>spl</em>, but waiting spinning only for an allowed time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spl</em>&nbsp;</td><td>must point to an allocated <em>SPL</em> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ns</em>&nbsp;</td><td>timeout</td></tr>
  </table>
</dl>
rt_spl_lock spins on lock till it can be acquired, as for rt_spl_lock, but only for an allowed time. If the spinlock cannot be acquired in time the functions returns in error. This function can be usefull either in itself or as a diagnosis toll during code development.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the spinlock was acquired, -1 if a timeout occured. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga34" doxytag="sem.c::rt_spl_unlock"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_spl_unlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SPL *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>spl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release an owned spinlock. 
<p>
<a class="anchor" name="rt_spl_unlock"></a><p>
rt_spl_lock releases an owned spinlock <em>spl</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spl</em>&nbsp;</td><td>must point to an allocated <em>SPL</em> structure.</td></tr>
  </table>
</dl>
rt_spl_unlock releases an owned lock. The spinlock can remain locked and its ownership can remain with the task is the spinlock acquisition was recursed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the function was used legally, -1 if a tasks tries to unlock a spinlock it does not own. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="sem.c::rt_typed_sem_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_typed_sem_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">SEM *&nbsp;</td>
          <td class="mdname" nowrap> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a specifically typed (counting, binary, resource) semaphore. 
<p>
<a class="anchor" name="rt_typed_sem_init"></a><p>
rt_typed_sem_init initializes a semaphore <em>sem</em> of type <em>type</em>. A semaphore can be used for communication and synchronization among real time tasks. Negative value of a semaphore shows how many tasks are blocked on the semaphore queue, waiting to be awaken by calls to rt_sem_signal.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sem</em>&nbsp;</td><td>must point to an allocated SEM structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>is the initial value of the semaphore, always set to 1 for a resource semaphore.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>is the semaphore type and queuing policy. It can be an OR a semaphore kind: CNT_SEM for counting semaphores, BIN_SEM for binary semaphores, RES_SEM for resource semaphores; and queuing policy: FIFO_Q, PRIO_Q for a fifo and priority queueing respectively. Resource semaphores will enforce a PRIO_Q policy anyhow.</td></tr>
  </table>
</dl>
Counting semaphores can register up to 0xFFFE events. Binary semaphores do not count signalled events, their count will never exceed 1 whatever number of events is signaled to them. Resource semaphores are special binary semaphores suitable for managing resources. The task that acquires a resource semaphore becomes its owner, also called resource owner, since it is the only one capable of manipulating the resource the semaphore is protecting. The owner has its priority increased to that of any task blocking on a wait to the semaphore. Such a feature, called priority inheritance, ensures that a high priority task is never slaved to a lower priority one, thus allowing to avoid any deadlock due to priority inversion. Resource semaphores can be recursed, i.e. their task owner is not blocked by nested waits placed on an owned resource. The owner must insure that it will signal the semaphore, in reversed order, as many times as he waited on it. Note that that full priority inheritance is supported both for resource semaphores and inter task messages, for a singly owned resource. Instead it becomes an adaptive priority ceiling when a task owns multiple resources, including messages sent to him. In such a case in fact its priority is returned to its base one only when all such resources are released and no message is waiting for being received. This is a compromise design choice aimed at avoiding extensive searches for the new priority to be inherited across multiply owned resources and blocked tasks sending messages to him. Such a solution will be implemented only if it proves necessary. Note also that, to avoid <em>deadlocks</em>, a task owning a resource semaphore cannot be suspended. Any <a class="el" href="api_8c.html#rt_task_suspend">rt_task_suspend</a>() posed on it is just registered. An owner task will go into suspend state only when it releases all the owned resources.<p>
<dl compact><dt><b>Note:</b></dt><dd>RTAI counting semaphores assume that their counter will never exceed 0xFFFF, such a number being used to signal returns in error. Thus also the initial count value cannot be greater than 0xFFFF. To be used only with RTAI24.x.xx (FIXME). </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:53 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
