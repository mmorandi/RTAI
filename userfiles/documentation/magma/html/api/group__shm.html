<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Unified RTAI real-time memory management.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Unified RTAI real-time memory management.</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__nam2num_8h.html">rtai_nam2num.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion between characters strings and unsigned long identifiers. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__scb_8h.html">rtai_scb.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SCB stand for Shared (memory) Circular Buffer. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__shm_8h.html">rtai_shm.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface of the <a class="el" href="group__shm.html">RTAI SHM module</a>. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="shm_8c.html">shm.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the <a class="el" href="group__shm.html">RTAI SHM module</a>. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_8c.html">malloc.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamic memory allocation services. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga63">rtai_kmalloc</a>(name, size)&nbsp;&nbsp;&nbsp;rt_shm_alloc(name, size, USE_VMALLOC)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes.  <a href="#ga63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga64">rtai_kfree</a>(name)&nbsp;&nbsp;&nbsp;rt_shm_free(name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes.  <a href="#ga64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga68">rtai_malloc</a>(name, size)&nbsp;&nbsp;&nbsp;_rt_shm_alloc(0, name, size, USE_VMALLOC, 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes.  <a href="#ga68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga69">rt_shm_alloc_adr</a>(start_address, name, size, suprt)&nbsp;&nbsp;&nbsp;_rt_shm_alloc(start_address, name, size, suprt, 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes.  <a href="#ga69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga71">rtai_malloc_adr</a>(start_address, name, size)&nbsp;&nbsp;&nbsp;_rt_shm_alloc(start_address, name, size, USE_VMALLOC, 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes.  <a href="#ga71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga72">rtai_free</a>(name, adr)&nbsp;&nbsp;&nbsp;rt_shm_free(name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes.  <a href="#ga72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga73">rt_heap_close</a>(name, adr)&nbsp;&nbsp;&nbsp;rt_shm_free(name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a real time group heap being shared inter-intra kernel modules and Linux processes.  <a href="#ga73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga83">rt_global_heap_open</a>()&nbsp;&nbsp;&nbsp;rt_heap_open(GLOBAL_HEAP_ID, 0, 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the global real time heap to be shared inter-intra kernel modules and Linux processes.  <a href="#ga83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga84">rt_global_heap_close</a>()&nbsp;&nbsp;&nbsp;rt_heap_close(GLOBAL_HEAP_ID, 0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the global real time heap being shared inter-intra kernel modules and Linux processes.  <a href="#ga84"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga12">rt_shm_free</a> (unsigned long name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga13">rt_halloc</a> (int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of a group real time heap in kernel/user space.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga14">rt_hfree</a> (void *addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a chunk of a group real time heap.  <a href="#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga15">rt_named_halloc</a> (unsigned long name, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of a group real time heap in kernel/user space.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga16">rt_named_hfree</a> (void *addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a chunk of a group real time heap.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga19">rt_named_malloc</a> (unsigned long name, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of the global real time heap in kernel/user space.  <a href="#ga19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga20">rt_named_free</a> (void *addr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a named chunk of the global real time heap.  <a href="#ga20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga24">rt_shm_alloc</a> (unsigned long name, int size, int suprt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes.  <a href="#ga24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga42">rt_heap_open</a> (unsigned long name, int size, int suprt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open/create a named group real time heap to be shared inter-intra kernel modules and Linux processes.  <a href="#ga42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga51">rtheap_init</a> (rtheap_t *heap, void *heapaddr, u_long heapsize, u_long pagesize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a memory heap.  <a href="#ga51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga52">rtheap_destroy</a> (rtheap_t *heap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a memory heap.  <a href="#ga52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga54">rtheap_alloc</a> (rtheap_t *heap, u_long size, int mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a memory block from a memory heap.  <a href="#ga54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga55">rtheap_free</a> (rtheap_t *heap, void *block)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a memory block to a memory heap.  <a href="#ga55"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="ga84" doxytag="rtai_shm.h::rt_global_heap_close"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rt_global_heap_close          </td>
          <td class="md" valign="top">(&nbsp;</td>
&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_heap_close(GLOBAL_HEAP_ID, 0)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close the global real time heap being shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_global_heap_close is used to close the global real time heap.<p>
Closing a global heap in user space has just the effect of deregistering its use and unmapping the related memory from a process address space. In kernel tasks just the deregistration is performed. The global real time heap is destroyed just a the rmmoding of the shared memory module. </p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga83" doxytag="rtai_shm.h::rt_global_heap_open"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rt_global_heap_open          </td>
          <td class="md" valign="top">(&nbsp;</td>
&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_heap_open(GLOBAL_HEAP_ID, 0, 0)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open the global real time heap to be shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_global_heap_open is used to open the global real time heap.<p>
The global heap is created by the shared memory module and its opening is needed in user space to map it to the process address space. In kernel space opening the global heap in a task is not required but should be done anyhow, both for symmetry and to register its usage. </p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga73" doxytag="rtai_shm.h::rt_heap_close"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rt_heap_close          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>adr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_shm_free(name)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close a real time group heap being shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_heap_close is used to close a previously opened real time group heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is the unsigned long identifier used to identify the heap.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>adr</em>&nbsp;</td><td>is not used.</td></tr>
  </table>
</dl>
Analogously to what done by any allocation function this group real time heap closing call have just the effect of decrementing a usage count, unmapping any user space heap being closed, till the last is done, as that is the one the really closes the group heap, freeing any allocated memory.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the size of the succesfully freed heap, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga69" doxytag="rtai_shm.h::rt_shm_alloc_adr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rt_shm_alloc_adr          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">start_address,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>name,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>suprt&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_rt_shm_alloc(start_address, name, size, suprt, 0)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. 
<p>
rt_shm_alloc_adr is used to allocate in user space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_address</em>&nbsp;</td><td>is a user desired address where the allocated memory should be mapped in user space;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the amount of required shared memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>suprt</em>&nbsp;</td><td>is the kernel allocation method to be used, it can be:<ul>
<li>USE_VMALLOC, use vmalloc;</li><li>USE_GFP_KERNEL, use kmalloc with GFP_KERNEL;</li><li>USE_GFP_ATOMIC, use kmalloc with GFP_ATOMIC;</li><li>USE_GFP_DMA, use kmalloc with GFP_DMA.</li></ul>
</td></tr>
  </table>
</dl>
Since <code>name</code> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd>the functions <a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
It must be remarked that only the very first call does a real allocation, any subsequent call to allocate with the same name from anywhere will just increase the usage count and map the area to user space, or return the related pointer to the already allocated space in kernel space. The function returns a pointer to the allocated memory, appropriately mapped to the memory space in use. So if one is really sure that the named shared memory has been allocated already parameters size and suprt are not used and can be assigned any value.<p>
<dl compact><dt><b>Note:</b></dt><dd>If the same process calls rtai_malloc_adr and <a class="el" href="group__shm.html#ga68">rtai_malloc()</a> twice in the same process it get a zero return value on the second call.</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga72" doxytag="rtai_shm.h::rtai_free"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rtai_free          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>adr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_shm_free(name)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes. 
<p>
rtai_free is used to free a shared memory chunk from user space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is the unsigned long identifier used when the memory was allocated;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>adr</em>&nbsp;</td><td>is not used.</td></tr>
  </table>
</dl>
rtai_free is a legacy helper macro, the real job is carried out by a call to rt_shm_free with the same name. This function should not be used in newly developed applications. See rt_shm_alloc_adr for more details.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the size of the succesfully freed memory, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga64" doxytag="rtai_shm.h::rtai_kfree"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rtai_kfree          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_shm_free(name)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes. 
<p>
rtai_kfree is used to free a shared memory chunk from kernel space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is the unsigned long identifier used when the memory was allocated;</td></tr>
  </table>
</dl>
rtai_kfree is a legacy helper macro, the real job is carried out by a call to rt_shm_free with the same name. This function should not be used in newly developed applications. See rt_shm_free for more details.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the size of the succesfully freed memory, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga63" doxytag="rtai_shm.h::rtai_kmalloc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rtai_kmalloc          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_shm_alloc(name, size, USE_VMALLOC)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rtai_kalloc is used to allocate shared memory from kernel space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
  </table>
</dl>
rtai_kmalloc is a legacy helper macro, the real job is carried out by a call to <a class="el" href="group__shm.html#ga24">rt_shm_alloc()</a> with the same name, size and with vmalloc support. This function should not be used in newly developed applications. See rt_shm_alloc for more details.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga68" doxytag="rtai_shm.h::rtai_malloc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rtai_malloc          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_rt_shm_alloc(0, name, size, USE_VMALLOC, 0)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rtai_malloc is used to allocate shared memory from user space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
  </table>
</dl>
rtai_malloc is a legacy helper macro, the real job is carried out by a call to <a class="el" href="group__shm.html#ga24">rt_shm_alloc()</a> with the same name, size and with vmalloc support. This function should not be used in newly developed applications. See rt_shm_alloc fro more details.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga71" doxytag="rtai_shm.h::rtai_malloc_adr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rtai_malloc_adr          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">start_address,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>name,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_rt_shm_alloc(start_address, name, size, USE_VMALLOC, 0)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rtai_malloc_adr is used to allocate shared memory from user space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_address</em>&nbsp;</td><td>is the adr were the shared memory should be mapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
  </table>
</dl>
rtai_malloc_adr is a legacy helper macro, the real job is carried out by a call to <a class="el" href="group__shm.html#ga69">rt_shm_alloc_adr()</a> with the same name, size and with vmalloc support. This function should not be used in newly developed applications. See rt_shm_alloc_adr for more details.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga13" doxytag="rtai_shm.h::rt_halloc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void * rt_halloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of a group real time heap in kernel/user space. 
<p>
Since it is not named there is no chance to retrieve and share it elsewhere.<p><b>For internal use only.</b></p>
<p>
rt_halloc is used to allocate a non sharable piece of a group real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the size of the requested memory in bytes;</td></tr>
  </table>
</dl>
A process/task must have opened the real time group heap to use and can use just one real time group heap. Be careful and avoid opening more than one group real time heap per process/task. If more than one is opened then just the last will used.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the pointer to the allocated memory, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga42" doxytag="shm.c::rt_heap_open"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* rt_heap_open           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>suprt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open/create a named group real time heap to be shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_heap_open is used to allocate open/create a shared real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>suprt</em>&nbsp;</td><td>is the kernel allocation method to be used, it can be:<ul>
<li>USE_VMALLOC, use vmalloc;</li><li>USE_GFP_KERNEL, use kmalloc with GFP_KERNEL;</li><li>USE_GFP_ATOMIC, use kmalloc with GFP_ATOMIC;</li><li>USE_GFP_DMA, use kmalloc with GFP_DMA.</li></ul>
</td></tr>
  </table>
</dl>
Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
It must be remarked that only the very first open does a real allocation, any subsequent one with the same name from anywhere will just map the area to the user space, or return the related pointer to the already allocated memory in kernel space. In any case the functions return a pointer to the allocated memory, appropriately mapped to the memory space in use. Be careful and avoid opening more than one group heap per process/task, if more than one is opened then just the last will used.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="rtai_shm.h::rt_hfree"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_hfree           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>adr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a chunk of a group real time heap. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_hfree is used to free a previously allocated chunck of a group real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>adr</em>&nbsp;</td><td>is the addr of the memory to be freed. </td></tr>
  </table>
</dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga20" doxytag="rtai_shm.h::rt_named_free"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_named_free           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>adr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a named chunk of the global real time heap. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_named_free is used to free a previously allocated chunk of the global real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>adr</em>&nbsp;</td><td>is the addr of the memory to be freed.</td></tr>
  </table>
</dl>
Analogously to what done by all the named allocation functions the freeing calls of named memory chunks have just the effect of decrementing its usage count, any shared piece of the global heap being freed only when the last is done, as that is the one the really frees any allocated memory. So one must be carefull not to use rt_free on a named global heap chunk, since it will force its unconditional immediate freeing. </p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="rtai_shm.h::rt_named_halloc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void * rt_named_halloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of a group real time heap in kernel/user space. 
<p>
Since it is named it can be retrieved and shared everywhere among the group peers, i.e all processes/tasks that have opened the same group heap.<p><b>For internal use only.</b></p>
<p>
rt_named_halloc is used to allocate a sharable piece of a group real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
  </table>
</dl>
Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
A process/task must have opened the real time group heap to use and can use just one real time group heap. Be careful and avoid opening more than one group real time heap per process/task. If more than one is opened then just the last will used. It must be remarked that only the very first call does a real allocation, any subsequent call with the same name will just increase the usage count and receive the appropriate pointer to the already allocated memory having the same name.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="rtai_shm.h::rt_named_hfree"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_named_hfree           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>adr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a chunk of a group real time heap. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_named_hfree is used to free a previously allocated chunk of the global real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>adr</em>&nbsp;</td><td>is the address of the memory to be freed.</td></tr>
  </table>
</dl>
Analogously to what done by all the named allocation functions the freeing calls of named memory chunks have just the effect of decrementing a usage count, any shared piece of the global heap being freed only when the last is done, as that is the one the really frees any allocated memory. So one must be carefull not to use rt_hfree on a named global heap chunk, since it will force its unconditional immediate freeing. </p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga19" doxytag="rtai_shm.h::rt_named_malloc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void * rt_named_malloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of the global real time heap in kernel/user space. 
<p>
Since it is named it can be retrieved and shared everywhere.<p><b>For internal use only.</b></p>
<p>
rt_named_malloc is used to allocate a sharable piece of the global real time heap.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
  </table>
</dl>
Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
It must be remarked that only the very first call does a real allocation, any subsequent call to allocate with the same name will just increase the usage count and return the appropriate pointer to the already allocated memory having the same name. So if one is really sure that the named chunk has been allocated already the size parameter is not used and can be assigned any value.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga24" doxytag="shm.c::rt_shm_alloc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* rt_shm_alloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>suprt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_shm_alloc is used to allocate shared memory.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the amount of required shared memory;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>suprt</em>&nbsp;</td><td>is the kernel allocation method to be used, it can be:<ul>
<li>USE_VMALLOC, use vmalloc;</li><li>USE_GFP_KERNEL, use kmalloc with GFP_KERNEL;</li><li>USE_GFP_ATOMIC, use kmalloc with GFP_ATOMIC;</li><li>USE_GFP_DMA, use kmalloc with GFP_DMA.</li></ul>
</td></tr>
  </table>
</dl>
Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
It must be remarked that only the very first call does a real allocation, any following call to allocate with the same name from anywhere will just increase the usage count and maps the area to the user space, or return the related pointer to the already allocated space in kernel space. In any case the functions return a pointer to the allocated memory, appropriately mapped to the memory space in use. So if one is really sure that the named shared memory has been allocated already parameters size and suprt are not used and can be assigned any value.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="rtai_shm.h::rt_shm_free"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_shm_free           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_shm_free is used to free a previously allocated shared memory.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is the unsigned long identifier used when the memory was allocated;</td></tr>
  </table>
</dl>
Analogously to what done by all the named allocation functions the freeing calls have just the effect of decrementing a usage count, unmapping any user space shared memory being freed, till the last is done, as that is the one the really frees any allocated memory.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the size of the succesfully freed memory, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga54" doxytag="malloc.c::rtheap_alloc"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void * rtheap_alloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtheap_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u_long&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate a memory block from a memory heap. 
<p>
Allocates a contiguous region of memory from an active memory heap. Such allocation is guaranteed to be time-bounded if the heap is non-extendable (see <a class="el" href="group__shm.html#ga51">rtheap_init()</a>). Otherwise, it might trigger a dynamic extension of the storage area through an internal request to the Linux allocation service (kmalloc/vmalloc).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The descriptor address of the heap to get memory from.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size in bytes of the requested block. Sizes lower or equal to the page size are rounded either to the minimum allocation size if lower than this value, or to the minimum alignment size if greater or equal to this value. In the current implementation, with MINALLOC = 16 and MINALIGN = 16, a 15 bytes request will be rounded to 16 bytes, and a 17 bytes request will be rounded to 32.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>A set of flags affecting the operation. Unless RTHEAP_EXTEND is passed and the heap is extendable, this service will return NULL without attempting to extend the heap dynamically upon memory starvation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The address of the allocated region upon success, or NULL if no memory is available from the specified non-extendable heap, or no memory can be obtained from Linux to extend the heap.</dd></dl>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine can always be called on behalf of a thread context. It can also be called on behalf of an IST context if the heap storage area has been statically-defined at initialization time (see <a class="el" href="group__shm.html#ga51">rtheap_init()</a>).     </td>
  </tr>
</table>
<a class="anchor" name="ga52" doxytag="malloc.c::rtheap_destroy"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rtheap_destroy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtheap_t *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>heap</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroys a memory heap. 
<p>
Destroys a memory heap. Dynamically allocated extents are returned to Linux.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The descriptor address of the destroyed heap.</td></tr>
  </table>
</dl>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine must be called on behalf of a thread context.     </td>
  </tr>
</table>
<a class="anchor" name="ga55" doxytag="malloc.c::rtheap_free"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtheap_free           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtheap_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>block</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release a memory block to a memory heap. 
<p>
Releases a memory region to the memory heap it was previously allocated from.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The descriptor address of the heap to release memory to.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>The address of the region to release returned by a previous call to <a class="el" href="group__shm.html#ga54">rtheap_alloc()</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success, or RTHEAP_PARAM is returned whenever the block is not a valid region of the specified heap.</dd></dl>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine can be called on behalf of a thread or IST context     </td>
  </tr>
</table>
<a class="anchor" name="ga51" doxytag="malloc.c::rtheap_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtheap_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">rtheap_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>heap</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>heapaddr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u_long&nbsp;</td>
          <td class="mdname" nowrap> <em>heapsize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u_long&nbsp;</td>
          <td class="mdname" nowrap> <em>pagesize</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a memory heap. 
<p>
Initializes a memory heap suitable for dynamic memory allocation requests. The heap manager can operate in two modes, whether time-bounded if the heap storage area and size are statically defined at initialization time, or dynamically extendable at the expense of a less deterministic behaviour.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>heap</em>&nbsp;</td><td>The address of a heap descriptor the memory manager will use to store the allocation data. This descriptor must always be valid while the heap is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>heapaddr</em>&nbsp;</td><td>The address of a statically-defined heap storage area. If this parameter is non-zero, all allocations will be made from the given area in fully time-bounded mode. In such a case, the heap is non-extendable. If a null address is passed, the heap manager will attempt to extend the heap each time a memory starvation is encountered. In the latter case, the heap manager will request additional chunks of core memory to Linux when needed, voiding the real-time guarantee for the caller.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>heapsize</em>&nbsp;</td><td>If heapaddr is non-zero, heapsize gives the size in bytes of the statically-defined storage area. Otherwise, heapsize defines the standard length of each extent that will be requested to Linux when a memory starvation is encountered for the heap. heapsize must be a multiple of pagesize and lower than 16 Mbytes. Depending on the Linux allocation service used, requests for extent memory might be limited in size. For instance, heapsize must be lower than 128Kb for kmalloc()-based allocations. In the current implementation, heapsize must be large enough to contain an internal header. The following formula gives the size of this header: hdrsize = (sizeof(rtextent_t) + ((heapsize - sizeof(rtextent_t))) / (pagesize + 1) + 15) &amp; ~15;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pagesize</em>&nbsp;</td><td>The size in bytes of the fundamental memory page which will be used to subdivide the heap internally. Choosing the right page size is important regarding performance and memory fragmentation issues, so it might be a good idea to take a look at <a href="http://docs.FreeBSD.org/44doc/papers/kernmalloc.pdf">http://docs.FreeBSD.org/44doc/papers/kernmalloc.pdf</a> to pick the best one for your needs. In the current implementation, pagesize must be a power of two in the range [ 8 .. 32768] inclusive.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned upon success, or one of the following error codes:<ul>
<li>RTHEAP_PARAM is returned whenever a parameter is invalid.</li><li>RTHEAP_NOMEM is returned if no initial extent can be allocated for a dynamically extendable heap (i.e. heapaddr == NULL).</li></ul>
</dd></dl>
Side-effect: This routine does not call the rescheduling procedure.<p>
Context: This routine must be called on behalf of a thread context.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:53 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
