<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTAI API: Unified RTAI real-time memory management.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RTAI API<span id="projectnumber">&#160;5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__shm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Unified RTAI real-time memory management.</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Unified RTAI real-time memory management.:</div>
<div class="dyncontent">
<div class="center"><img src="group__shm.png" border="0" usemap="#agroup____shm" alt=""/></div>
<map name="agroup____shm" id="agroup____shm">
<area shape="rect" href="group__lxrt.html" title="LXRT services (soft&#45;hard real time in user space)" alt="" coords="305,5,411,31"/>
<area shape="rect" title=" " alt="" coords="5,23,163,63"/>
<area shape="rect" href="group__tasklets.html" title="The tasklets module adds an interesting feature along the line, pioneered by RTAI,..." alt="" coords="326,55,390,80"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:rtai__nam2num_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__nam2num_8h.html">rtai_nam2num.h</a></td></tr>
<tr class="memdesc:rtai__nam2num_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion between 6 characters strings and unsigned long identifiers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rtai__scb_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__scb_8h.html">rtai_scb.h</a></td></tr>
<tr class="memdesc:rtai__scb_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">SCB stand for Shared (memory) Circular Buffer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rtai__shm_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__shm_8h.html">rtai_shm.h</a></td></tr>
<tr class="memdesc:rtai__shm_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the <a class="el" href="group__shm.html">RTAI SHM module</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:shm_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shm_8c.html">shm.c</a></td></tr>
<tr class="memdesc:shm_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <a class="el" href="group__shm.html">RTAI SHM module</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:malloc_2malloc_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_2malloc_8c.html">malloc.c</a></td></tr>
<tr class="memdesc:malloc_2malloc_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic memory allocation services. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:malloc_2malloc_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_2malloc_8c.html">malloc.c</a></td></tr>
<tr class="memdesc:malloc_2malloc_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic memory allocation services. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:malloc_2malloc_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="malloc_2malloc_8c.html">malloc.c</a></td></tr>
<tr class="memdesc:malloc_2malloc_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic memory allocation services. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sched_2malloc_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sched_2malloc_8c.html">malloc.c</a></td></tr>
<tr class="memdesc:sched_2malloc_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic memory allocation services. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sched_2malloc_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sched_2malloc_8c.html">malloc.c</a></td></tr>
<tr class="memdesc:sched_2malloc_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic memory allocation services. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:sched_2malloc_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sched_2malloc_8c.html">malloc.c</a></td></tr>
<tr class="memdesc:sched_2malloc_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic memory allocation services. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf446b5af7eabba29ee2496c9b87d76b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#gaf446b5af7eabba29ee2496c9b87d76b2">rtai_kmalloc</a>(name,  size)&#160;&#160;&#160;	rt_shm_alloc(name, size, USE_VMALLOC)</td></tr>
<tr class="memdesc:gaf446b5af7eabba29ee2496c9b87d76b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes.  <a href="group__shm.html#gaf446b5af7eabba29ee2496c9b87d76b2">More...</a><br /></td></tr>
<tr class="separator:gaf446b5af7eabba29ee2496c9b87d76b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga292d88432ece22d87842cc78bbdb649d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga292d88432ece22d87842cc78bbdb649d">rtai_kfree</a>(name)&#160;&#160;&#160;	<a class="el" href="group__shm.html#ga168f63856f8c4f51a92979481f0cc4ad">rt_shm_free</a>(name)</td></tr>
<tr class="memdesc:ga292d88432ece22d87842cc78bbdb649d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes.  <a href="group__shm.html#ga292d88432ece22d87842cc78bbdb649d">More...</a><br /></td></tr>
<tr class="separator:ga292d88432ece22d87842cc78bbdb649d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8786c6bea3dd90c3bc25e3513e72f54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#gaf8786c6bea3dd90c3bc25e3513e72f54">rtai_malloc</a>(name,  size)&#160;&#160;&#160;	_rt_shm_alloc(0, name, size, USE_VMALLOC, 0)</td></tr>
<tr class="memdesc:gaf8786c6bea3dd90c3bc25e3513e72f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes.  <a href="group__shm.html#gaf8786c6bea3dd90c3bc25e3513e72f54">More...</a><br /></td></tr>
<tr class="separator:gaf8786c6bea3dd90c3bc25e3513e72f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6eaf480b9ff4ecdf11932e0cd303baa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#gad6eaf480b9ff4ecdf11932e0cd303baa">rt_shm_alloc_adr</a>(start_address,  name,  size,  suprt)&#160;&#160;&#160;	_rt_shm_alloc(start_address, name, size, suprt, 0)</td></tr>
<tr class="memdesc:gad6eaf480b9ff4ecdf11932e0cd303baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes.  <a href="group__shm.html#gad6eaf480b9ff4ecdf11932e0cd303baa">More...</a><br /></td></tr>
<tr class="separator:gad6eaf480b9ff4ecdf11932e0cd303baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1335274141bb4a7e52dc5942781a546e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga1335274141bb4a7e52dc5942781a546e">rtai_malloc_adr</a>(start_address,  name,  size)&#160;&#160;&#160;	_rt_shm_alloc(start_address, name, size, USE_VMALLOC, 0)</td></tr>
<tr class="memdesc:ga1335274141bb4a7e52dc5942781a546e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes.  <a href="group__shm.html#ga1335274141bb4a7e52dc5942781a546e">More...</a><br /></td></tr>
<tr class="separator:ga1335274141bb4a7e52dc5942781a546e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe18026e98e8ba9ad90339a200d04270"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#gafe18026e98e8ba9ad90339a200d04270">rtai_free</a>(name,  adr)&#160;&#160;&#160;	<a class="el" href="group__shm.html#ga168f63856f8c4f51a92979481f0cc4ad">rt_shm_free</a>(name)</td></tr>
<tr class="memdesc:gafe18026e98e8ba9ad90339a200d04270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes.  <a href="group__shm.html#gafe18026e98e8ba9ad90339a200d04270">More...</a><br /></td></tr>
<tr class="separator:gafe18026e98e8ba9ad90339a200d04270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96ca3e7de9c209deda010afc29a94cf0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga96ca3e7de9c209deda010afc29a94cf0">rt_heap_close</a>(name,  adr)&#160;&#160;&#160;<a class="el" href="group__shm.html#ga168f63856f8c4f51a92979481f0cc4ad">rt_shm_free</a>(name)</td></tr>
<tr class="memdesc:ga96ca3e7de9c209deda010afc29a94cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a real time group heap being shared inter-intra kernel modules and Linux processes.  <a href="group__shm.html#ga96ca3e7de9c209deda010afc29a94cf0">More...</a><br /></td></tr>
<tr class="separator:ga96ca3e7de9c209deda010afc29a94cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac80f554c34f276056d1ccf7fe4097f77"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#gac80f554c34f276056d1ccf7fe4097f77">rt_global_heap_open</a>()&#160;&#160;&#160;rt_heap_open(GLOBAL_HEAP_ID, 0, 0)</td></tr>
<tr class="memdesc:gac80f554c34f276056d1ccf7fe4097f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the global real time heap to be shared inter-intra kernel modules and Linux processes.  <a href="group__shm.html#gac80f554c34f276056d1ccf7fe4097f77">More...</a><br /></td></tr>
<tr class="separator:gac80f554c34f276056d1ccf7fe4097f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8679aca31bbd076bc0edbd778e411a4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga8679aca31bbd076bc0edbd778e411a4f">rt_global_heap_close</a>()&#160;&#160;&#160;<a class="el" href="group__shm.html#ga96ca3e7de9c209deda010afc29a94cf0">rt_heap_close</a>(GLOBAL_HEAP_ID, 0)</td></tr>
<tr class="memdesc:ga8679aca31bbd076bc0edbd778e411a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the global real time heap being shared inter-intra kernel modules and Linux processes.  <a href="group__shm.html#ga8679aca31bbd076bc0edbd778e411a4f">More...</a><br /></td></tr>
<tr class="separator:ga8679aca31bbd076bc0edbd778e411a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga168f63856f8c4f51a92979481f0cc4ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga168f63856f8c4f51a92979481f0cc4ad">rt_shm_free</a> (unsigned long name)</td></tr>
<tr class="memdesc:ga168f63856f8c4f51a92979481f0cc4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes.  <a href="group__shm.html#ga168f63856f8c4f51a92979481f0cc4ad">More...</a><br /></td></tr>
<tr class="separator:ga168f63856f8c4f51a92979481f0cc4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef5850e60beac5393d1bd7c3c6e55d1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#gaeef5850e60beac5393d1bd7c3c6e55d1">rt_halloc</a> (int size)</td></tr>
<tr class="memdesc:gaeef5850e60beac5393d1bd7c3c6e55d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a chunk of a group real time heap in kernel/user space.  <a href="group__shm.html#gaeef5850e60beac5393d1bd7c3c6e55d1">More...</a><br /></td></tr>
<tr class="separator:gaeef5850e60beac5393d1bd7c3c6e55d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb8a5d5b8997ed3794d760f163749c11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#gacb8a5d5b8997ed3794d760f163749c11">rt_hfree</a> (void *adr)</td></tr>
<tr class="memdesc:gacb8a5d5b8997ed3794d760f163749c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a chunk of a group real time heap.  <a href="group__shm.html#gacb8a5d5b8997ed3794d760f163749c11">More...</a><br /></td></tr>
<tr class="separator:gacb8a5d5b8997ed3794d760f163749c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1dd90cd24afb131c7fae1093804311b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#gad1dd90cd24afb131c7fae1093804311b">rt_named_halloc</a> (unsigned long name, int size)</td></tr>
<tr class="memdesc:gad1dd90cd24afb131c7fae1093804311b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a chunk of a group real time heap in kernel/user space.  <a href="group__shm.html#gad1dd90cd24afb131c7fae1093804311b">More...</a><br /></td></tr>
<tr class="separator:gad1dd90cd24afb131c7fae1093804311b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553eb894b9fd68ca34d78abd4a51e281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga553eb894b9fd68ca34d78abd4a51e281">rt_named_hfree</a> (void *adr)</td></tr>
<tr class="memdesc:ga553eb894b9fd68ca34d78abd4a51e281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a chunk of a group real time heap.  <a href="group__shm.html#ga553eb894b9fd68ca34d78abd4a51e281">More...</a><br /></td></tr>
<tr class="separator:ga553eb894b9fd68ca34d78abd4a51e281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga236ce8b3172511a70be74e462eba1970"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga236ce8b3172511a70be74e462eba1970">rt_named_malloc</a> (unsigned long name, int size)</td></tr>
<tr class="memdesc:ga236ce8b3172511a70be74e462eba1970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a chunk of the global real time heap in kernel/user space.  <a href="group__shm.html#ga236ce8b3172511a70be74e462eba1970">More...</a><br /></td></tr>
<tr class="separator:ga236ce8b3172511a70be74e462eba1970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa12541902b0d38764afb958d10532c10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#gaa12541902b0d38764afb958d10532c10">rt_named_free</a> (void *adr)</td></tr>
<tr class="memdesc:gaa12541902b0d38764afb958d10532c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a named chunk of the global real time heap.  <a href="group__shm.html#gaa12541902b0d38764afb958d10532c10">More...</a><br /></td></tr>
<tr class="separator:gaa12541902b0d38764afb958d10532c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0a5908d521a90c20bb81f0688e13ebb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#gad0a5908d521a90c20bb81f0688e13ebb">rt_shm_alloc</a> (unsigned long name, int size, int suprt)</td></tr>
<tr class="memdesc:gad0a5908d521a90c20bb81f0688e13ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes.  <a href="group__shm.html#gad0a5908d521a90c20bb81f0688e13ebb">More...</a><br /></td></tr>
<tr class="separator:gad0a5908d521a90c20bb81f0688e13ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb748f06167dd8b4d8ac69f7dc15b651"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#gaeb748f06167dd8b4d8ac69f7dc15b651">rt_heap_open</a> (unsigned long name, int size, int suprt)</td></tr>
<tr class="memdesc:gaeb748f06167dd8b4d8ac69f7dc15b651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open/create a named group real time heap to be shared inter-intra kernel modules and Linux processes.  <a href="group__shm.html#gaeb748f06167dd8b4d8ac69f7dc15b651">More...</a><br /></td></tr>
<tr class="separator:gaeb748f06167dd8b4d8ac69f7dc15b651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4e1013dd611c50a93d52886f795411"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga0d4e1013dd611c50a93d52886f795411">rtheap_init</a> (rtheap_t *heap, void *heapaddr, u_long heapsize, u_long pagesize, int suprt)</td></tr>
<tr class="memdesc:ga0d4e1013dd611c50a93d52886f795411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a memory heap.  <a href="group__shm.html#ga0d4e1013dd611c50a93d52886f795411">More...</a><br /></td></tr>
<tr class="separator:ga0d4e1013dd611c50a93d52886f795411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1fd23da0a751a6857f2f2ad4a33128"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#ga7c1fd23da0a751a6857f2f2ad4a33128">rtheap_alloc</a> (rtheap_t *heap, u_long size, int mode)</td></tr>
<tr class="memdesc:ga7c1fd23da0a751a6857f2f2ad4a33128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a memory block from a memory heap.  <a href="group__shm.html#ga7c1fd23da0a751a6857f2f2ad4a33128">More...</a><br /></td></tr>
<tr class="separator:ga7c1fd23da0a751a6857f2f2ad4a33128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbe9195c92d9718e700c4b32dad785d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shm.html#gacbe9195c92d9718e700c4b32dad785d0">rtheap_free</a> (rtheap_t *heap, void *block)</td></tr>
<tr class="memdesc:gacbe9195c92d9718e700c4b32dad785d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a memory block to a memory heap.  <a href="group__shm.html#gacbe9195c92d9718e700c4b32dad785d0">More...</a><br /></td></tr>
<tr class="separator:gacbe9195c92d9718e700c4b32dad785d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga8679aca31bbd076bc0edbd778e411a4f" name="ga8679aca31bbd076bc0edbd778e411a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8679aca31bbd076bc0edbd778e411a4f">&#9670;&#160;</a></span>rt_global_heap_close</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rt_global_heap_close</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__shm.html#ga96ca3e7de9c209deda010afc29a94cf0">rt_heap_close</a>(GLOBAL_HEAP_ID, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the global real time heap being shared inter-intra kernel modules and Linux processes. </p>
<p >rt_global_heap_close is used to close the global real time heap.</p>
<p >Closing a global heap in user space has just the effect of deregistering its use and unmapping the related memory from a process address space. In kernel tasks just the deregistration is performed. The global real time heap is destroyed just a the rmmoding of the shared memory module. </p>

</div>
</div>
<a id="gac80f554c34f276056d1ccf7fe4097f77" name="gac80f554c34f276056d1ccf7fe4097f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac80f554c34f276056d1ccf7fe4097f77">&#9670;&#160;</a></span>rt_global_heap_open</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rt_global_heap_open</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;rt_heap_open(GLOBAL_HEAP_ID, 0, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the global real time heap to be shared inter-intra kernel modules and Linux processes. </p>
<p >rt_global_heap_open is used to open the global real time heap.</p>
<p >The global heap is created by the shared memory module and its opening is needed in user space to map it to the process address space. In kernel space opening the global heap in a task is not required but should be done anyhow, both for symmetry and to register its usage. </p>

</div>
</div>
<a id="ga96ca3e7de9c209deda010afc29a94cf0" name="ga96ca3e7de9c209deda010afc29a94cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96ca3e7de9c209deda010afc29a94cf0">&#9670;&#160;</a></span>rt_heap_close</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rt_heap_close</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__shm.html#ga168f63856f8c4f51a92979481f0cc4ad">rt_shm_free</a>(name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a real time group heap being shared inter-intra kernel modules and Linux processes. </p>
<p >rt_heap_close is used to close a previously opened real time group heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the unsigned long identifier used to identify the heap.</td></tr>
    <tr><td class="paramname">adr</td><td>is not used.</td></tr>
  </table>
  </dd>
</dl>
<p>Analogously to what done by any allocation function this group real time heap closing call have just the effect of decrementing a usage count, unmapping any user space heap being closed, till the last is done, as that is the one the really closes the group heap, freeing any allocated memory.</p>
<dl class="section return"><dt>Returns</dt><dd>the size of the succesfully freed heap, 0 on failure. </dd></dl>

</div>
</div>
<a id="gad6eaf480b9ff4ecdf11932e0cd303baa" name="gad6eaf480b9ff4ecdf11932e0cd303baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6eaf480b9ff4ecdf11932e0cd303baa">&#9670;&#160;</a></span>rt_shm_alloc_adr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rt_shm_alloc_adr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start_address, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">suprt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	_rt_shm_alloc(start_address, name, size, suprt, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. </p>
<p >rt_shm_alloc_adr is used to allocate in user space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_address</td><td>is a user desired address where the allocated memory should be mapped in user space;</td></tr>
    <tr><td class="paramname">name</td><td>is an unsigned long identifier;</td></tr>
    <tr><td class="paramname">size</td><td>is the amount of required shared memory.</td></tr>
    <tr><td class="paramname">suprt</td><td>is the kernel allocation method to be used, it can be:<ul>
<li>USE_VMALLOC, use vmalloc;</li>
<li>USE_GFP_KERNEL, use kmalloc with GFP_KERNEL;</li>
<li>USE_GFP_ATOMIC, use kmalloc with GFP_ATOMIC;</li>
<li>USE_GFP_DMA, use kmalloc with GFP_DMA.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Since <code>name</code> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.</p>
<dl class="section see"><dt>See also</dt><dd>the functions nam2num() and num2nam().</dd></dl>
<p>It must be remarked that only the very first call does a real allocation, any subsequent call to allocate with the same name from anywhere will just increase the usage count and map the area to user space, or return the related pointer to the already allocated space in kernel space. The function returns a pointer to the allocated memory, appropriately mapped to the memory space in use. So if one is really sure that the named shared memory has been allocated already parameters size and suprt are not used and can be assigned any value.</p>
<dl class="section note"><dt>Note</dt><dd>If the same process calls rtai_malloc_adr and <a class="el" href="group__shm.html#gaf8786c6bea3dd90c3bc25e3513e72f54" title="Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes.">rtai_malloc()</a> twice in the same process it get a zero return value on the second call.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a valid address on succes, on failure: 0 if it was unable to allocate any memory, MAP_FAILED if it was possible to allocate the required memory but failed to mmap it to user space, in which case the allocated memory is freed anyhow. </dd></dl>

</div>
</div>
<a id="gafe18026e98e8ba9ad90339a200d04270" name="gafe18026e98e8ba9ad90339a200d04270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe18026e98e8ba9ad90339a200d04270">&#9670;&#160;</a></span>rtai_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtai_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	<a class="el" href="group__shm.html#ga168f63856f8c4f51a92979481f0cc4ad">rt_shm_free</a>(name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes. </p>
<p >rtai_free is used to free a shared memory chunk from user space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the unsigned long identifier used when the memory was allocated;</td></tr>
    <tr><td class="paramname">adr</td><td>is not used.</td></tr>
  </table>
  </dd>
</dl>
<p>rtai_free is a legacy helper macro, the real job is carried out by a call to rt_shm_free with the same name. This function should not be used in newly developed applications. See rt_shm_alloc_adr for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>the size of the succesfully freed memory, 0 on failure. </dd></dl>

</div>
</div>
<a id="ga292d88432ece22d87842cc78bbdb649d" name="ga292d88432ece22d87842cc78bbdb649d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga292d88432ece22d87842cc78bbdb649d">&#9670;&#160;</a></span>rtai_kfree</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtai_kfree</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;	<a class="el" href="group__shm.html#ga168f63856f8c4f51a92979481f0cc4ad">rt_shm_free</a>(name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes. </p>
<p >rtai_kfree is used to free a shared memory chunk from kernel space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the unsigned long identifier used when the memory was allocated;</td></tr>
  </table>
  </dd>
</dl>
<p>rtai_kfree is a legacy helper macro, the real job is carried out by a call to rt_shm_free with the same name. This function should not be used in newly developed applications. See rt_shm_free for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>the size of the succesfully freed memory, 0 on failure. </dd></dl>

</div>
</div>
<a id="gaf446b5af7eabba29ee2496c9b87d76b2" name="gaf446b5af7eabba29ee2496c9b87d76b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf446b5af7eabba29ee2496c9b87d76b2">&#9670;&#160;</a></span>rtai_kmalloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtai_kmalloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	rt_shm_alloc(name, size, USE_VMALLOC)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. </p>
<p >rtai_kalloc is used to allocate shared memory from kernel space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is an unsigned long identifier;</td></tr>
    <tr><td class="paramname">size</td><td>is the amount of required shared memory;</td></tr>
  </table>
  </dd>
</dl>
<p>rtai_kmalloc is a legacy helper macro, the real job is carried out by a call to rt_shm_alloc() with the same name, size and with vmalloc support. This function should not be used in newly developed applications. See rt_shm_alloc for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>a valid address on succes, 0 on failure. </dd></dl>

</div>
</div>
<a id="gaf8786c6bea3dd90c3bc25e3513e72f54" name="gaf8786c6bea3dd90c3bc25e3513e72f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8786c6bea3dd90c3bc25e3513e72f54">&#9670;&#160;</a></span>rtai_malloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtai_malloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	_rt_shm_alloc(0, name, size, USE_VMALLOC, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. </p>
<p >rtai_malloc is used to allocate shared memory from user space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is an unsigned long identifier;</td></tr>
    <tr><td class="paramname">size</td><td>is the amount of required shared memory;</td></tr>
  </table>
  </dd>
</dl>
<p>rtai_malloc is a legacy helper macro, the real job is carried out by a call to rt_shm_alloc() with the same name, size and with vmalloc support. This function should not be used in newly developed applications. See rt_shm_alloc fro more details.</p>
<dl class="section return"><dt>Returns</dt><dd>a valid address on succes, on failure: 0 if it was unable to allocate any memory, MAP_FAILED if it was possible to allocate the required memory but failed to mmap it to user space, in which case the allocated memory is freed anyhow. </dd></dl>

</div>
</div>
<a id="ga1335274141bb4a7e52dc5942781a546e" name="ga1335274141bb4a7e52dc5942781a546e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1335274141bb4a7e52dc5942781a546e">&#9670;&#160;</a></span>rtai_malloc_adr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtai_malloc_adr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start_address, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	_rt_shm_alloc(start_address, name, size, USE_VMALLOC, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. </p>
<p >rtai_malloc_adr is used to allocate shared memory from user space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_address</td><td>is the adr were the shared memory should be mapped.</td></tr>
    <tr><td class="paramname">name</td><td>is an unsigned long identifier;</td></tr>
    <tr><td class="paramname">size</td><td>is the amount of required shared memory;</td></tr>
  </table>
  </dd>
</dl>
<p>rtai_malloc_adr is a legacy helper macro, the real job is carried out by a call to <a class="el" href="group__shm.html#gad6eaf480b9ff4ecdf11932e0cd303baa" title="Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes.">rt_shm_alloc_adr()</a> with the same name, size and with vmalloc support. This function should not be used in newly developed applications. See rt_shm_alloc_adr for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>a valid address on succes, 0 on failure. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaeef5850e60beac5393d1bd7c3c6e55d1" name="gaeef5850e60beac5393d1bd7c3c6e55d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeef5850e60beac5393d1bd7c3c6e55d1">&#9670;&#160;</a></span>rt_halloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE void * rt_halloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a chunk of a group real time heap in kernel/user space. </p>
<p >Since it is not named there is no chance to retrieve and share it elsewhere.</p>
<p >rt_halloc is used to allocate a non sharable piece of a group real time heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>is the size of the requested memory in bytes;</td></tr>
  </table>
  </dd>
</dl>
<p>A process/task must have opened the real time group heap to use and can use just one real time group heap. Be careful and avoid opening more than one group real time heap per process/task. If more than one is opened then just the last will used.</p>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the allocated memory, 0 on failure. </dd></dl>

</div>
</div>
<a id="gaeb748f06167dd8b4d8ac69f7dc15b651" name="gaeb748f06167dd8b4d8ac69f7dc15b651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb748f06167dd8b4d8ac69f7dc15b651">&#9670;&#160;</a></span>rt_heap_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * rt_heap_open </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>suprt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open/create a named group real time heap to be shared inter-intra kernel modules and Linux processes. </p>
<p >rt_heap_open is used to allocate open/create a shared real time heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is an unsigned long identifier;</td></tr>
    <tr><td class="paramname">size</td><td>is the amount of required shared memory;</td></tr>
    <tr><td class="paramname">suprt</td><td>is the kernel allocation method to be used, it can be:<ul>
<li>USE_VMALLOC, use vmalloc;</li>
<li>USE_GFP_KERNEL, use kmalloc with GFP_KERNEL;</li>
<li>USE_GFP_ATOMIC, use kmalloc with GFP_ATOMIC;</li>
<li>USE_GFP_DMA, use kmalloc with GFP_DMA.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.</p>
<dl class="section see"><dt>See also</dt><dd>nam2num() and num2nam().</dd></dl>
<p>It must be remarked that only the very first open does a real allocation, any subsequent one with the same name from anywhere will just map the area to the user space, or return the related pointer to the already allocated memory in kernel space. In any case the functions return a pointer to the allocated memory, appropriately mapped to the memory space in use. Be careful and avoid opening more than one group heap per process/task, if more than one is opened then just the last will used.</p>
<dl class="section return"><dt>Returns</dt><dd>a valid address on succes, 0 on failure. </dd></dl>

</div>
</div>
<a id="gacb8a5d5b8997ed3794d760f163749c11" name="gacb8a5d5b8997ed3794d760f163749c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb8a5d5b8997ed3794d760f163749c11">&#9670;&#160;</a></span>rt_hfree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE void rt_hfree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>adr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a chunk of a group real time heap. </p>
<p >rt_hfree is used to free a previously allocated chunck of a group real time heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adr</td><td>is the addr of the memory to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa12541902b0d38764afb958d10532c10" name="gaa12541902b0d38764afb958d10532c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa12541902b0d38764afb958d10532c10">&#9670;&#160;</a></span>rt_named_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_named_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>adr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a named chunk of the global real time heap. </p>
<p >rt_named_free is used to free a previously allocated chunk of the global real time heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adr</td><td>is the addr of the memory to be freed.</td></tr>
  </table>
  </dd>
</dl>
<p>Analogously to what done by all the named allocation functions the freeing calls of named memory chunks have just the effect of decrementing its usage count, any shared piece of the global heap being freed only when the last is done, as that is the one the really frees any allocated memory. So one must be carefull not to use rt_free on a named global heap chunk, since it will force its unconditional immediate freeing. </p>

</div>
</div>
<a id="gad1dd90cd24afb131c7fae1093804311b" name="gad1dd90cd24afb131c7fae1093804311b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1dd90cd24afb131c7fae1093804311b">&#9670;&#160;</a></span>rt_named_halloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE void * rt_named_halloc </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a chunk of a group real time heap in kernel/user space. </p>
<p >Since it is named it can be retrieved and shared everywhere among the group peers, i.e all processes/tasks that have opened the same group heap.</p>
<p >rt_named_halloc is used to allocate a sharable piece of a group real time heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is an unsigned long identifier;</td></tr>
    <tr><td class="paramname">size</td><td>is the amount of required shared memory;</td></tr>
  </table>
  </dd>
</dl>
<p>Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.</p>
<dl class="section see"><dt>See also</dt><dd>nam2num() and num2nam().</dd></dl>
<p>A process/task must have opened the real time group heap to use and can use just one real time group heap. Be careful and avoid opening more than one group real time heap per process/task. If more than one is opened then just the last will used. It must be remarked that only the very first call does a real allocation, any subsequent call with the same name will just increase the usage count and receive the appropriate pointer to the already allocated memory having the same name.</p>
<dl class="section return"><dt>Returns</dt><dd>a valid address on succes, 0 on failure. </dd></dl>

</div>
</div>
<a id="ga553eb894b9fd68ca34d78abd4a51e281" name="ga553eb894b9fd68ca34d78abd4a51e281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga553eb894b9fd68ca34d78abd4a51e281">&#9670;&#160;</a></span>rt_named_hfree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE void rt_named_hfree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>adr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a chunk of a group real time heap. </p>
<p >rt_named_hfree is used to free a previously allocated chunk of the global real time heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adr</td><td>is the address of the memory to be freed.</td></tr>
  </table>
  </dd>
</dl>
<p>Analogously to what done by all the named allocation functions the freeing calls of named memory chunks have just the effect of decrementing a usage count, any shared piece of the global heap being freed only when the last is done, as that is the one the really frees any allocated memory. So one must be carefull not to use rt_hfree on a named global heap chunk, since it will force its unconditional immediate freeing. </p>

</div>
</div>
<a id="ga236ce8b3172511a70be74e462eba1970" name="ga236ce8b3172511a70be74e462eba1970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga236ce8b3172511a70be74e462eba1970">&#9670;&#160;</a></span>rt_named_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * rt_named_malloc </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a chunk of the global real time heap in kernel/user space. </p>
<p >Since it is not named there is no chance of retrieving and sharing it elsewhere.</p>
<p >rt_malloc is used to allocate a non sharable piece of the global real time heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>is the size of the requested memory in bytes;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the allocated memory, 0 on failure. Free a chunk of the global real time heap.</dd></dl>
<p >rt_free is used to free a previously allocated chunck of the global real time heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the addr of the memory to be freed. Allocate a chunk of the global real time heap in kernel/user space. Since it is named it can be retrieved and shared everywhere.</td></tr>
  </table>
  </dd>
</dl>
<p >rt_named_malloc is used to allocate a sharable piece of the global real time heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is an unsigned long identifier;</td></tr>
    <tr><td class="paramname">size</td><td>is the amount of required shared memory;</td></tr>
  </table>
  </dd>
</dl>
<p>Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.</p>
<dl class="section see"><dt>See also</dt><dd>nam2num() and num2nam().</dd></dl>
<p>It must be remarked that only the very first call does a real allocation, any subsequent call to allocate with the same name will just increase the usage count and return the appropriate pointer to the already allocated memory having the same name. So if one is really sure that the named chunk has been allocated already the size parameter is not used and can be assigned any value.</p>
<dl class="section return"><dt>Returns</dt><dd>a valid address on succes, 0 on failure. </dd></dl>

</div>
</div>
<a id="gad0a5908d521a90c20bb81f0688e13ebb" name="gad0a5908d521a90c20bb81f0688e13ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0a5908d521a90c20bb81f0688e13ebb">&#9670;&#160;</a></span>rt_shm_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * rt_shm_alloc </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>suprt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a chunk of memory to be shared inter-intra kernel modules and Linux processes. </p>
<p >rt_shm_alloc is used to allocate shared memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is an unsigned long identifier;</td></tr>
    <tr><td class="paramname">size</td><td>is the amount of required shared memory;</td></tr>
    <tr><td class="paramname">suprt</td><td>is the kernel allocation method to be used, it can be:<ul>
<li>USE_VMALLOC, use vmalloc;</li>
<li>USE_GFP_KERNEL, use kmalloc with GFP_KERNEL;</li>
<li>USE_GFP_ATOMIC, use kmalloc with GFP_ATOMIC;</li>
<li>USE_GFP_DMA, use kmalloc with GFP_DMA.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.</p>
<dl class="section see"><dt>See also</dt><dd>nam2num() and num2nam().</dd></dl>
<p>It must be remarked that only the very first call does a real allocation, any following call to allocate with the same name from anywhere will just increase the usage count and maps the area to the user space, or return the related pointer to the already allocated space in kernel space. In any case the functions return a pointer to the allocated memory, appropriately mapped to the memory space in use. So if one is really sure that the named shared memory has been allocated already parameters size and suprt are not used and can be assigned any value.</p>
<dl class="section return"><dt>Returns</dt><dd>a valid address on succes, 0 on failure. </dd></dl>

</div>
</div>
<a id="ga168f63856f8c4f51a92979481f0cc4ad" name="ga168f63856f8c4f51a92979481f0cc4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga168f63856f8c4f51a92979481f0cc4ad">&#9670;&#160;</a></span>rt_shm_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_shm_free </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a chunk of shared memory being shared inter-intra kernel modules and Linux processes. </p>
<p >rt_shm_free is used to free a previously allocated shared memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the unsigned long identifier used when the memory was allocated;</td></tr>
  </table>
  </dd>
</dl>
<p>Analogously to what done by all the named allocation functions the freeing calls have just the effect of decrementing a usage count, unmapping any user space shared memory being freed, till the last is done, as that is the one the really frees any allocated memory.</p>
<dl class="section return"><dt>Returns</dt><dd>the size of the succesfully freed memory, 0 on failure. </dd></dl>

</div>
</div>
<a id="ga7c1fd23da0a751a6857f2f2ad4a33128" name="ga7c1fd23da0a751a6857f2f2ad4a33128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c1fd23da0a751a6857f2f2ad4a33128">&#9670;&#160;</a></span>rtheap_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * rtheap_alloc </td>
          <td>(</td>
          <td class="paramtype">rtheap_t *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_long&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a memory block from a memory heap. </p>
<p >Allocates a contiguous region of memory from an active memory heap. Such allocation is guaranteed to be time-bounded if the heap is non-extendable (see <a class="el" href="group__shm.html#ga0d4e1013dd611c50a93d52886f795411" title="Initialize a memory heap.">rtheap_init()</a>). Otherwise, it might trigger a dynamic extension of the storage area through an internal request to the Linux allocation service (kmalloc/vmalloc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The descriptor address of the heap to get memory from.</td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the requested block. Sizes lower or equal to the page size are rounded either to the minimum allocation size if lower than this value, or to the minimum alignment size if greater or equal to this value. In the current implementation, with MINALLOC = 16 and MINALIGN = 16, a 15 bytes request will be rounded to 16 bytes, and a 17 bytes request will be rounded to 32.</td></tr>
    <tr><td class="paramname">flags</td><td>A set of flags affecting the operation. Unless RTHEAP_EXTEND is passed and the heap is extendable, this service will return NULL without attempting to extend the heap dynamically upon memory starvation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the allocated region upon success, or NULL if no memory is available from the specified non-extendable heap, or no memory can be obtained from Linux to extend the heap.</dd></dl>
<p>Side-effect: This routine does not call the rescheduling procedure.</p>
<p >Context: This routine can always be called on behalf of a thread context. It can also be called on behalf of an IST context if the heap storage area has been statically-defined at initialization time (see <a class="el" href="group__shm.html#ga0d4e1013dd611c50a93d52886f795411" title="Initialize a memory heap.">rtheap_init()</a>). </p>

</div>
</div>
<a id="gacbe9195c92d9718e700c4b32dad785d0" name="gacbe9195c92d9718e700c4b32dad785d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbe9195c92d9718e700c4b32dad785d0">&#9670;&#160;</a></span>rtheap_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtheap_free </td>
          <td>(</td>
          <td class="paramtype">rtheap_t *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a memory block to a memory heap. </p>
<p >Releases a memory region to the memory heap it was previously allocated from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The descriptor address of the heap to release memory to.</td></tr>
    <tr><td class="paramname">block</td><td>The address of the region to release returned by a previous call to <a class="el" href="group__shm.html#ga7c1fd23da0a751a6857f2f2ad4a33128" title="Allocate a memory block from a memory heap.">rtheap_alloc()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success, or RTHEAP_PARAM is returned whenever the block is not a valid region of the specified heap.</dd></dl>
<p>Side-effect: This routine does not call the rescheduling procedure.</p>
<p >Context: This routine can be called on behalf of a thread or IST context </p>

</div>
</div>
<a id="ga0d4e1013dd611c50a93d52886f795411" name="ga0d4e1013dd611c50a93d52886f795411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d4e1013dd611c50a93d52886f795411">&#9670;&#160;</a></span>rtheap_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtheap_init </td>
          <td>(</td>
          <td class="paramtype">rtheap_t *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>heapaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_long&#160;</td>
          <td class="paramname"><em>heapsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_long&#160;</td>
          <td class="paramname"><em>pagesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>suprt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a memory heap. </p>
<p >Initializes a memory heap suitable for dynamic memory allocation requests. The heap manager can operate in two modes, whether time-bounded if the heap storage area and size are statically defined at initialization time, or dynamically extendable at the expense of a less deterministic behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The address of a heap descriptor the memory manager will use to store the allocation data. This descriptor must always be valid while the heap is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td class="paramname">heapaddr</td><td>The address of a statically-defined heap storage area. If this parameter is non-zero, all allocations will be made from the given area in fully time-bounded mode. In such a case, the heap is non-extendable. If a null address is passed, the heap manager will attempt to extend the heap each time a memory starvation is encountered. In the latter case, the heap manager will request additional chunks of core memory to Linux when needed, voiding the real-time guarantee for the caller.</td></tr>
    <tr><td class="paramname">heapsize</td><td>If heapaddr is non-zero, heapsize gives the size in bytes of the statically-defined storage area. Otherwise, heapsize defines the standard length of each extent that will be requested to Linux when a memory starvation is encountered for the heap. heapsize must be a multiple of pagesize and lower than 16 Mbytes. Depending on the Linux allocation service used, requests for extent memory might be limited in size. For instance, heapsize must be lower than 128Kb for kmalloc()-based allocations. In the current implementation, heapsize must be large enough to contain an internal header. The following formula gives the size of this header: hdrsize = (sizeof(rtextent_t) + ((heapsize - sizeof(rtextent_t))) / (pagesize + 1) + 15) &amp; ~15;</td></tr>
    <tr><td class="paramname">pagesize</td><td>The size in bytes of the fundamental memory page which will be used to subdivide the heap internally. Choosing the right page size is important regarding performance and memory fragmentation issues, so it might be a good idea to take a look at <a href="http://docs.FreeBSD.org/44doc/papers/kernmalloc.pdf">http://docs.FreeBSD.org/44doc/papers/kernmalloc.pdf</a> to pick the best one for your needs. In the current implementation, pagesize must be a power of two in the range [ 8 .. 32768] inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success, or one of the following error codes:<ul>
<li>RTHEAP_PARAM is returned whenever a parameter is invalid.</li>
<li>RTHEAP_NOMEM is returned if no initial extent can be allocated for a dynamically extendable heap (i.e. heapaddr == NULL).</li>
</ul>
</dd></dl>
<p>Side-effect: This routine does not call the rescheduling procedure.</p>
<p >Context: This routine must be called on behalf of a thread context. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
