<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Message handling functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Message handling functions</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="msg_8c.html">msg.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Message handling functions. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga0">rt_send</a> (RT_TASK *task, unsigned int msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message.  <a href="#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga1">rt_send_if</a> (RT_TASK *task, unsigned int msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message, only if the calling task will not be blocked.  <a href="#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga2">rt_send_until</a> (RT_TASK *task, unsigned int msg, RTIME time)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga3">rt_send_timed</a> (RT_TASK *task, unsigned int msg, RTIME delay)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga4">rt_evdrp</a> (RT_TASK *task, unsigned int *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Eavedrop (spy) the content of a message.  <a href="#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga5">rt_receive</a> (RT_TASK *task, unsigned int *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message.  <a href="#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga6">rt_receive_if</a> (RT_TASK *task, unsigned int *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message, only if the calling task is not blocked.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga7">rt_receive_until</a> (RT_TASK *task, unsigned int *msg, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message with an absolute timeout.  <a href="#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga8">rt_receive_timed</a> (RT_TASK *task, unsigned int *msg, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message with a relative timeout.  <a href="#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga9">rt_sendx</a> (RT_TASK *task, void *msg, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send an extended message.  <a href="#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga10">rt_sendx_if</a> (RT_TASK *task, void *msg, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send an extended message, only if the calling task will not be blocked.  <a href="#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga11">rt_sendx_until</a> (RT_TASK *task, void *msg, int size, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send an extended message with absolute timeout.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga12">rt_sendx_timed</a> (RT_TASK *task, void *msg, int size, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send an extended message with relative timeout.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga13">rt_evdrpx</a> (RT_TASK *task, void *msg, int size, int *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Eavedrop (spy) the content of an extended message.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga14">rt_receivex</a> (RT_TASK *task, void *msg, int size, int *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive an extended message.  <a href="#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga15">rt_receivex_if</a> (RT_TASK *task, void *msg, int size, int *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive an extended message, only if the calling task is not blocked.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga16">rt_receivex_until</a> (RT_TASK *task, void *msg, int size, int *len, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive an extended message with an absolute timeout.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga17">rt_receivex_timed</a> (RT_TASK *task, void *msg, int size, int *len, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive an extended message with a relative timeout.  <a href="#ga17"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga4" doxytag="msg.c::rt_evdrp"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_evdrp           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Eavedrop (spy) the content of a message. 
<p>
<a class="anchor" name="rt_evdrp"></a> <p>
rt_evdrp spies the content of a message from the task specified by <em>task</em> while leaving it on the queue. To actually receive the message any of the rt_receive function must be used specifically. If task is equal to 0, the caller eavdrops the first message of its receive queue, if any. rt_evdrp never blocks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to any 4 bytes word buffer provided by the caller.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the sender task is returned upon success.<br>
 0 is returned if no message is available. A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: the sender task was killed before sending the message;</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="msg.c::rt_evdrpx"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_evdrpx           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Eavedrop (spy) the content of an extended message. 
<p>
<a class="anchor" name="rt_evdrpx"></a> <p>
rt_evdrpx spies the content of a message from the task specified by <em>task</em> while leaving it on the queue. To actually receive the message any of the rt_receivex function must be used specifically. If task is equal to 0, the caller eavdrops the first message of its receive queue, if any. rt_evdrpix never blocks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to the message to be eavedropped, without receive.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the message to be eavedropped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>is a pointer to an integer to be set to the actual len of the eavedropped message.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the sender task is returned upon success.<br>
 0 is returned if no message is available. A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: the sender task was killed before sending the message;</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="msg.c::rt_receive"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_receive           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive a message. 
<p>
<a class="anchor" name="rt_receive"></a> <p>
rt_receive gets a message from the task specified by task. If task is equal to 0, the caller accepts messages from any task. If there is a pending message, rt_receive does not block but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpced messages since rpcing tasks always waits for a returned message. Moreover it inheredits the highest priority of any rpcing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_return. Otherwise the caller task is blocked waiting for any message to be sent/rpced.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to any 4 bytes word buffer provided by the caller.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the sender task is returned upon success.<br>
 0 is returned if the caller is unblocked but no message has been received (e.g. the task <em>task</em> was killed before sending the message.)<br>
 A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: the sender task was killed before sending the message;</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="msg.c::rt_receive_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_receive_if           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive a message, only if the calling task is not blocked. 
<p>
<a class="anchor" name="rt_receive_if"></a> <p>
rt_receive_if tries to get a message from the task specified by task. If task is equal to 0, the caller accepts messages from any task. The caller task is never blocked but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpced messages since rpcing tasks always waits for a returned message. Moreover it inheredits the highest priority of any rpcing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_return. Otherwise the caller task is blocked waiting for any message to be sent/rpced.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to the task structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to a buffer provided by the caller.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the sender task is returned upon success.<br>
 A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: there was no message to receive;</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.     </td>
  </tr>
</table>
<a class="anchor" name="ga8" doxytag="msg.c::rt_receive_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_receive_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive a message with a relative timeout. 
<p>
<a class="anchor" name="rt_receive_timed"></a> <p>
rt_receive_timed receives a message from the task specified by task. If task is equal to 0, the caller accepts messages from any task. If there is a pending message, rt_receive does not block but but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpced messages since rpcing tasks always waits for a returned message. Moreover it inheredits the highest priority of any rpcing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_return. Otherwise the caller task is blocked waiting for any message to be sent/rpced. In this case these functions return if: a sender sends a message and has a lower priority; any rpced message is received;<ul>
<li>timeout occurs;</li><li>an error occurs (e.g. the sender task is killed.)</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to the task structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to a buffer provided by the caller.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>is a timeout relative to the current time.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, a pointer to the sender task is returned. On other failure, a special value is returned. The errors are described below:<ul>
<li><b>0</b>: there was no message to receive.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.</dd></dl>
See also: <a class="el" href="group__msg.html#rt_receive_until">rt_receive_until</a>().     </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="msg.c::rt_receive_until"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_receive_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive a message with an absolute timeout. 
<p>
<a class="anchor" name="rt_receive_until"></a> <p>
rt_receive_until receives a message from the task specified by task. If task is equal to 0, the caller accepts messages from any task. If there is a pending message, rt_receive does not block but but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpced messages since rpcing tasks always waits for a returned message. Moreover it inheredits the highest priority of any rpcing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_return. Otherwise the caller task is blocked waiting for any message to be sent/rpced. In this case these functions return if: a sender sends a message and has a lower priority; any rpced message is received;<ul>
<li>timeout occurs;</li><li>an error occurs (e.g. the sender task is killed.)</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to the task structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to a buffer provided by the caller.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>is an absolute timout value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, a pointer to the sender task is returned. On other failure, a special value is returned. The errors are described below:<ul>
<li><b>0</b>: there was no message to receive.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe.</dd></dl>
See also: <a class="el" href="group__msg.html#rt_receive_timed">rt_receive_timed</a>().     </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="msg.c::rt_receivex"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_receivex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive an extended message. 
<p>
<a class="anchor" name="rt_receivex"></a> <p>
rt_receivex gets an extended message <em>msg</em> of size <em>size</em> from the task specified by <em>task</em> task. If task is equal to 0, the caller accepts messages from any task. If there is a pending message, rt_receivex does not block but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpcxed messages since rpcxing tasks always wait for a returned message. Moreover it inheredits the highest priority of any rpcxing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_returnx. Otherwise the caller task is blocked waiting for any message to be sentx/rpcxed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to the message to be eavedropped, without receive.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the message to be eavedropped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>is a pointer to an integer to be set to the actual len of the eavedropped message.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the sender task is returned upon success.<br>
 0 is returned if the caller is unblocked but no message has been received (e.g. the task <em>task</em> was killed before sending the message.)<br>
 A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: the sender task was killed before sending the message;</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="msg.c::rt_receivex_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_receivex_if           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive an extended message, only if the calling task is not blocked. 
<p>
<a class="anchor" name="rt_receivex_if"></a> <p>
rt_receivex gets an extended message <em>msg</em> of size <em>size</em> from the task specified by <em>task</em> task. If task is equal to 0, the caller accepts messages from any task. The caller task is never blocked but can be preempted if the task that rt_sentx the just received message has a higher priority. The task will not block if it receives rpcxed messages since rpcxing tasks always wait for a returned message. Moreover it inheredits the highest priority of any rpcxing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_returnx. Otherwise the caller task is blocked waiting for any message to be sentx/rpcxed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to the message to be eavedropped, without receive.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the message to be eavedropped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>is a pointer to an integer to be set to the actual len of the eavedropped message.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the sender task is returned upon success.<br>
 0 is returned if the caller is unblocked but no message has been received (e.g. the task <em>task</em> was killed before sending the message.)<br>
 A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: the sender task was killed before sending the message;</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga17" doxytag="msg.c::rt_receivex_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_receivex_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive an extended message with a relative timeout. 
<p>
<a class="anchor" name="rt_receivex_timed"></a> <p>
rt_receivex_until gets an extended message <em>msg</em> of size <em>size</em> from the task specified by <em>task</em> task. If task is equal to 0, the caller accepts messages from any task. If there is a pending message, rt_receivex does not block but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpcxed messages since rpcxing tasks always wait for a returned message. Moreover it inheredits the highest priority of any rpcxing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_returnx. Otherwise the caller task is blocked waiting for any message to be sentx/rpcxed.<p>
In this case these functions return if: a sender sendxs a message and has a lower priority; any rpcxed message is received;<ul>
<li>timeout occurs;</li><li>an error occurs (e.g. the sender task is killed.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to the message to be eavedropped, without receive.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the message to be eavedropped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>is a pointer to an integer to be set to the actual len of the eavedropped message.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>is a timeout relative to the current time.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the sender task is returned upon success.<br>
 0 is returned if the caller is unblocked but no message has been received (e.g. the task <em>task</em> was killed before sending the message.)<br>
 A special value is returned on other failure. The errors are described below:</dd></dl>
</li><li><b>0</b>: the sender task was killed before sending the message;</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="msg.c::rt_receivex_until"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_receivex_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive an extended message with an absolute timeout. 
<p>
<a class="anchor" name="rt_receivex_until"></a> <p>
rt_receivex_until gets an extended message <em>msg</em> of size <em>size</em> from the task specified by <em>task</em> task. If task is equal to 0, the caller accepts messages from any task. If there is a pending message, rt_receivex does not block but can be preempted if the task that rt_sent the just received message has a higher priority. The task will not block if it receives rpcxed messages since rpcxing tasks always wait for a returned message. Moreover it inheredits the highest priority of any rpcxing task waiting on the receive queue. The receiving task will then recover its priority as explained in rt_returnx. Otherwise the caller task is blocked waiting for any message to be sentx/rpcxed.<p>
In this case these functions return if: a sender sendxs a message and has a lower priority; any rpcxed message is received;<ul>
<li>timeout occurs;</li><li>an error occurs (e.g. the sender task is killed.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a <em>RT_TASK</em> structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to the message to be eavedropped, without receive.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the message to be eavedropped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>is a pointer to an integer to be set to the actual len of the eavedropped message.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>is an absolute timout value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the sender task is returned upon success.<br>
 0 is returned if the caller is unblocked but no message has been received (e.g. the task <em>task</em> was killed before sending the message.)<br>
 A special value is returned on other failure. The errors are described below:</dd></dl>
</li><li><b>0</b>: the sender task was killed before sending the message;</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga0" doxytag="msg.c::rt_send"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_send           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a message. 
<p>
<a class="anchor" name="rt_send"></a> <p>
rt_send sends the message <em>msg</em> to the task <em>task</em>. If the receiver task is ready to get the message rt_send does not block the sending task, but its execution can be preempted if the receiving task has a higher priority. Otherwise the caller task is blocked and queued up in priority order on the receive list of the sent task.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a task structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>corresponds to the message that has to be sent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, the pointer to the task that received the message is returned.<br>
 0 is returned if the caller is unblocked but the message has not been sent, e.g. the task <em>task</em> was killed before receiving the message.<br>
 A special value is returned as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="msg.c::rt_send_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_send_if           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send a message, only if the calling task will not be blocked. 
<p>
<a class="anchor" name="rt_send_if"></a> <p>
rt_send_if sends the message <em>msg</em> to the task <em>task</em> if the latter is ready to receive, so that the caller task is never blocked, but its execution can be preempted if the receiving task is ready to receive and has a higher priority.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a task structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>corresponds to the message that has to be sent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the pointer to the task <em>task</em> that received the message is returned upon success.<br>
 <em>0</em> is returned if the message has not been sent.<br>
 A special value <em>0xFFFF</em> is returned upon failure.<br>
<br>
 The errors are described below:<ul>
<li><b>0</b>: the task <em>task</em> was not ready to receive the message.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. (FIXME) </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="msg.c::rt_send_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_send_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="anchor" name="rt_send_timed"></a> brief Send a message with a relative timeout.<p>
rt_send_timed sends the message <em>msg</em> to the task <em>task</em>. If the receiver task is ready to get the message, this function does not block the sending task, but its execution can be preempted if the receiving task has a higher priority. Otherwise the caller task is blocked and queued up in priority order on the receive list of the sent task. In this case the function returns if:<ul>
<li>the caller task is in the first place of the waiting queue and the receiver gets the message and has a lower priority;</li><li>a timeout occurs;</li><li>an error occurs (e.g. the receiver task is killed).</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a task structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>corresponds to the message that has to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>is the timeout relative to the current time.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>on success, the pointer to the task that received the message i.e. the message received before timeout expiration.<br>
 0 if the message has not been sent.<br>
 A special value on other failure. The errors are described below:<ul>
<li><b>0</b>: operation timed out, message was not delivered;</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
See also: <a class="el" href="group__msg.html#rt_send_until">rt_send_until</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. (FIXME) </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="msg.c::rt_send_until"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_send_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="anchor" name="rt_send_until"></a> brief Send a message with an absolute timeout.<p>
rt_send_until sends the message <em>msg</em> to the task <em>task</em>. If the receiver task is ready to get the message, this function does not block the sending task, but its execution can be preempted if the receiving task has a higher priority. Otherwise the caller task is blocked and queued up in priority order on the receive list of the sent task. In this case the function returns if:<ul>
<li>the caller task is in the first place of the waiting queue and the receiver gets the message and has a lower priority;</li><li>a timeout occurs;</li><li>an error occurs (e.g. the receiver task is killed).</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a task structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>corresponds to the message that has to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>is the absolute timeout value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the pointer to the task that received the message is returned on success i.e. the message received before timeout expiration.<br>
 0 is returned if the message has not been sent. A special value is returned on other failure. The errors are described below:<ul>
<li><b>0</b>: operation timed out, message was not delivered;</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
See also: <a class="el" href="group__msg.html#rt_send_timed">rt_send_timed</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="msg.c::rt_sendx"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_sendx           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send an extended message. 
<p>
<a class="anchor" name="rt_sendx"></a> <p>
rt_sendx sends an arbitrary message <em>msg</em> of size <em>size</em> bytes to the task <em>task</em>. If the receiver task is ready to get the message rt_sendx does not block the sending task, but its execution can be preempted if the receiving task has a higher priority. Otherwise the caller task is blocked and queued up in priority order on the receive list of the sent task.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a task structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the message to be sent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, the pointer to the task that received the message is returned.<br>
 0 is returned if the caller is unblocked but the message has not been sent, e.g. the task <em>task</em> was killed before receiving the message.<br>
 A special value is returned as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga10" doxytag="msg.c::rt_sendx_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_sendx_if           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send an extended message, only if the calling task will not be blocked. 
<p>
<a class="anchor" name="rt_sendx_if"></a> <p>
rt_sendx_if sends an arbitrary message <em>msg</em> of size <em>size</em> bytes to the task <em>task</em> if the latter is ready to receive. So the caller task in never blocked but its execution can be preempted if the receiving task has a higher priority.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a task structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the message to be sent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, the pointer to the task that received the message is returned.<br>
 0 is returned if the caller is unblocked but the message has not been sent, e.g. the task <em>task</em> was killed before receiving the message.<br>
 A special value is returned as described below in case of a failure:<ul>
<li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="msg.c::rt_sendx_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_sendx_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>delay</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send an extended message with relative timeout. 
<p>
<a class="anchor" name="rt_sendx_timed"></a> <p>
rt_sendx_until sends an arbitrary message <em>msg</em> of size <em>size</em> bytes to the task <em>task</em>. If the receiver task is ready to get the message rt_sendx_until does not block the sending task, but its execution can be preempted if the receiving task has a higher priority. Otherwise the caller task is blocked and queued up in priority order on the receive list of the sent task. In this case the function returns if:<ul>
<li>the caller task is in the first place of the waiting queue and the receiver gets the message and has a lower priority;</li><li>a timeout occurs;</li><li>an error occurs (e.g. the receiver task is killed).</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a task structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>is r timeout elative to the current time.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, the pointer to the task that received the message is returned.<br>
 0 is returned if the caller is unblocked but the message has not been sent, e.g. the task <em>task</em> was killed before receiving the message.<br>
 A special value is returned as described below in case of a failure:<ul>
<li><b>0</b>: operation timed out, message was not delivered;</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="msg.c::rt_sendx_until"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_sendx_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send an extended message with absolute timeout. 
<p>
<a class="anchor" name="rt_sendx_until"></a> <p>
rt_sendx_until sends an arbitrary message <em>msg</em> of size <em>size</em> bytes to the task <em>task</em>. If the receiver task is ready to get the message rt_sendx_until does not block the sending task, but its execution can be preempted if the receiving task has a higher priority. Otherwise the caller task is blocked and queued up in priority order on the receive list of the sent task. In this case the function returns if:<ul>
<li>the caller task is in the first place of the waiting queue and the receiver gets the message and has a lower priority;</li><li>a timeout occurs;</li><li>an error occurs (e.g. the receiver task is killed).</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to a task structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>points to the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>is an absolute timeout value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, the pointer to the task that received the message is returned.<br>
 0 is returned if the caller is unblocked but the message has not been sent, e.g. the task <em>task</em> was killed before receiving the message.<br>
 A special value is returned as described below in case of a failure:<ul>
<li><b>0</b>: operation timed out, message was not delivered;</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on 0xFFFF is not an address that can be used by any RTAI task, so it is should be safe always. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:53 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
