<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: base/sched/api.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">base</a>&nbsp;/&nbsp;<a class="el" href="dir_000035.html">sched</a></div>
<h1>api.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Common scheduling function. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>Paolo Mantegazza</dd></dl>
This file is part of the RTAI project.<p>
<dl compact><dt><b>Note:</b></dt><dd>Copyright &copy; 1999-2003 Paolo Mantegazza &lt;<a href="mailto:mantegazza@aero.polimi.it">mantegazza@aero.polimi.it</a>&gt;</dd></dl>
This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.<p>
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.<p>
You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
<p>

<p>
Include dependency graph for api.c:<p><center><img src="api_8c__incl.png" border="0" usemap="#api.c_map" alt="Include dependency graph"></center>
<map name="api.c_map">
<area href="rtai__schedcore_8h-source.html" shape="rect" coords="58,158,178,182" alt="">
<area href="rtai__lxrt_8h.html" shape="rect" coords="56,9,133,33" alt="">
<area href="rtai__tasklets_8h.html" shape="rect" coords="132,84,236,108" alt="">
<area href="rtai__registry_8h.html" shape="rect" coords="253,158,357,182" alt="">
</map>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a9">rt_get_prio</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check a task priority.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a10">rt_get_inher_prio</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check a task priority.  <a href="#a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a11">rt_change_prio</a> (RT_TASK *task, int priority)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change a task priority.  <a href="#a11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a12">rt_whoami</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the task pointer of the current task.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a13">rt_task_yield</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Yield the current task.  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a14">rt_task_suspend</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">rt_task_suspend suspends execution of the task task.  <a href="#a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a18">rt_task_resume</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resume a task.  <a href="#a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a19">rt_get_task_state</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query task state.  <a href="#a19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a20">rt_linux_use_fpu</a> (int use_fpu_flag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set indication of FPU usage.  <a href="#a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a21">rt_task_use_fpu</a> (RT_TASK *task, int use_fpu_flag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a22">rt_task_signal_handler</a> (RT_TASK *task, void(*handler)(void))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the signal handler of a task.  <a href="#a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a24">rt_task_make_periodic_relative_ns</a> (RT_TASK *task, RTIME start_delay, RTIME period)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a task run periodically.  <a href="#a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a25">rt_task_make_periodic</a> (RT_TASK *task, RTIME start_time, RTIME period)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a task run periodically.  <a href="#a25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a26">rt_task_wait_period</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait till next period.  <a href="#a26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RTIME&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a30">next_period</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the time a periodic task will be resumed after calling rt_task_wait_period.  <a href="#a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a31">rt_busy_sleep</a> (int ns)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delay/suspend execution for a while.  <a href="#a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a32">rt_sleep</a> (RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delay/suspend execution for a while.  <a href="#a32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a33">rt_sleep_until</a> (RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delay/suspend execution for a while.  <a href="#a33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga83">rt_register</a> (unsigned long name, void *adr, int type, struct task_struct *t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga84">rt_drg_on_name</a> (unsigned long name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga85">rt_drg_on_adr</a> (void *adr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga1">rt_get_name</a> (void *adr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an object name by its address.  <a href="group__lxrt.html#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga0">rt_get_adr</a> (unsigned long name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an object address by its name.  <a href="group__lxrt.html#ga0"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a30" doxytag="api.c::next_period"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RTIME next_period           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the time a periodic task will be resumed after calling rt_task_wait_period. 
<p>
<a class="anchor" name="next_period"></a><p>
this function returns the time when the caller task will run next. Combined with the appropriate rt_get_time function() it can be used for checking the fraction of period used or any period overrun.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Next period time in internal count units. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="api.c::rt_busy_sleep"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_busy_sleep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ns</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delay/suspend execution for a while. 
<p>
<a class="anchor" name="rt_busy_sleep"></a><p>
rt_busy_sleep delays the execution of the caller task without giving back the control to the scheduler. This function burns away CPU cycles in a busy wait loop so it should be used only for very short synchronization delays. On machine not having a TSC clock it can lead to many microseconds uncertain busy sleeps because of the need of reading the 8254 timer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ns</em>&nbsp;</td><td>is the number of nanoseconds to wait.</td></tr>
  </table>
</dl>
See also: <a class="el" href="api_8c.html#rt_sleep">rt_sleep</a>(), <a class="el" href="api_8c.html#rt_sleep_until">rt_sleep_until</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>A higher priority task or interrupt handler can run before the task goes to sleep, so the actual time spent in these functions may be longer than that specified. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="api.c::rt_change_prio"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_change_prio           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change a task priority. 
<p>
<a class="anchor" name="rt_change_prio"></a><p>
rt_change_prio changes the base priority of task <em>task</em> to <em>prio</em>.<p>
Recall that a task has a base native priority, assigned at its birth or by <a class="el" href="api_8c.html#rt_change_prio">rt_change_prio</a>(), and an actual, inherited, priority. They can be different because of priority inheritance.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is the affected task.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>is the new priority, it can range within 0 &lt; prio &lt; RT_SCHED_LOWEST_PRIORITY.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>rt_change_prio returns the base priority task <em>task</em> had before the change.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx (FIXME). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="api.c::rt_get_inher_prio"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_get_inher_prio           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check a task priority. 
<p>
<a class="anchor" name="rt_get_inher_prio"></a><p>
rt_get_prio returns the base priority task <em>task</em> has inherited from other tasks, either blocked on resources owned by or waiting to pass a message to task <em>task</em>.<p>
Recall that a task has a base native priority, assigned at its birth or by <a class="el" href="api_8c.html#rt_change_prio">rt_change_prio</a>(), and an actual, inherited, priority. They can be different because of priority inheritance.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is the affected task.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>rt_get_inher_prio returns the priority of task <em>task</em>.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="api.c::rt_get_prio"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_get_prio           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check a task priority. 
<p>
<a class="anchor" name="rt_get_prio"></a><p>
rt_get_prio returns the base priority of task <em>task</em>.<p>
Recall that a task has a base native priority, assigned at its birth or by <a class="el" href="api_8c.html#rt_change_prio">rt_change_prio</a>(), and an actual, inherited, priority. They can be different because of priority inheritance.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is the affected task.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>rt_get_prio returns the priority of task <em>task</em>.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="api.c::rt_get_task_state"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_get_task_state           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Query task state. 
<p>
<a class="anchor" name="rt_get_task_state"></a> rt_get_task_state returns the state of a real time task.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to the task structure.</td></tr>
  </table>
</dl>
Task state is formed by the bitwise OR of one or more of the following flags:<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>READY</em>&nbsp;</td><td>Task <em>task</em> is ready to run (i.e. unblocked). Note that on a UniProcessor machine the currently running task is just in READY state, while on MultiProcessors can be (READY | RUNNING), see below. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SUSPENDED</em>&nbsp;</td><td>Task <em>task</em> blocked waiting for a resume. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DELAYED</em>&nbsp;</td><td>Task <em>task</em> blocked waiting for its next running period or expiration of a timeout. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SEMAPHORE</em>&nbsp;</td><td>Task <em>task</em> blocked on a semaphore, waiting for the semaphore to be signaled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SEND</em>&nbsp;</td><td>Task <em>task</em> blocked on sending a message, receiver was not in RECEIVE state. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RECEIVE</em>&nbsp;</td><td>Task <em>task</em> blocked waiting for incoming messages, sends or rpcs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RPC</em>&nbsp;</td><td>Task <em>task</em> blocked on a Remote Procedure Call, receiver was not in RECEIVE state. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RETURN</em>&nbsp;</td><td>Task <em>task</em> blocked waiting for a return from a Remote Procedure Call, receiver got the RPC but has not replied yet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RUNNING</em>&nbsp;</td><td>Task <em>task</em> is running, used only for SMP schedulers.</td></tr>
  </table>
</dl>
The returned task state is just an approximate information. Timer and other hardware interrupts may cause a change in the state of the queried task before the caller could evaluate the returned value. Caller should disable interrupts if it wants reliable info about an other task. rt_get_task_state does not perform any check on pointer task.     </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="api.c::rt_linux_use_fpu"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_linux_use_fpu           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>use_fpu_flag</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set indication of FPU usage. 
<p>
<a class="anchor" name="rt_linux_use_fpu"></a><p>
rt_linux_use_fpu informs the scheduler that floating point arithmetic operations will be used also by foreground Linux processes, i.e. the Linux kernel itself (unlikely) and any of its processes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>use_fpu_flag</em>&nbsp;</td><td>If this parameter has a nonzero value, the Floating Point Unit (FPU) context is also switched when <em>task</em> or the kernel becomes active. This makes task switching slower, negligibly, on all 32 bits CPUs but 386s and the oldest 486s. This flag can be set also by rt_task_init when the real time task is created. With UP and MUP schedulers care is taken to avoid useless saves/ restores of the FPU environment. Under SMP tasks can be moved from CPU to CPU so saves/restores for tasks using the FPU are always carried out. Note that by default Linux has this flag cleared. Beside by using rt_linux_use_fpu you can change the Linux FPU flag when you insmod any RTAI scheduler module by setting the LinuxFpu command line parameter of the rtai_sched module itself.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL:</b> task does not refer to a valid task.</li></ul>
</dd></dl>
See also: <a class="el" href="api_8c.html#rt_linux_use_fpu">rt_linux_use_fpu</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="api.c::rt_sleep"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_sleep           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>delay</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delay/suspend execution for a while. 
<p>
<a class="anchor" name="rt_sleep"></a><p>
rt_sleep suspends execution of the caller task for a time of delay internal count units. During this time the CPU is used by other tasks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>Corresponds to the time the task is going to be suspended.</td></tr>
  </table>
</dl>
See also: <a class="el" href="api_8c.html#rt_busy_sleep">rt_busy_sleep</a>(), <a class="el" href="api_8c.html#rt_sleep_until">rt_sleep_until</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>A higher priority task or interrupt handler can run before the task goes to sleep, so the actual time spent in these functions may be longer than the the one specified. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="api.c::rt_sleep_until"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_sleep_until           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RTIME&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>time</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delay/suspend execution for a while. 
<p>
<a class="anchor" name="rt_sleep_until"></a><p>
rt_sleep_until is similar to <a class="el" href="api_8c.html#rt_sleep">rt_sleep</a>() but the parameter time is the absolute time till the task have to be suspended. If the given time is already passed this call has no effect.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time</em>&nbsp;</td><td>Absolute time till the task have to be suspended</td></tr>
  </table>
</dl>
See also: <a class="el" href="api_8c.html#rt_busy_sleep">rt_busy_sleep</a>(), <a class="el" href="api_8c.html#rt_sleep_until">rt_sleep_until</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>A higher priority task or interrupt handler can run before the task goes to sleep, so the actual time spent in these functions may be longer than the the one specified. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="api.c::rt_task_make_periodic"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_task_make_periodic           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>start_time</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>period</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a task run periodically. 
<p>
<a class="anchor" name="rt_task_make_periodic"></a> rt_task_make_periodic mark the task <em>task</em>, previously created with <a class="el" href="group__lxrt.html#ga6">rt_task_init</a>(), as suitable for a periodic execution, with period <em>period</em>, when <a class="el" href="api_8c.html#rt_task_wait_period">rt_task_wait_period</a>() is called.<p>
The time of first execution is defined through <em>start_time</em> or <em>start_delay</em>. <em>start_time</em> is an absolute value measured in clock ticks. <em>start_delay</em> is relative to the current time and measured in nanoseconds.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to the task you want to make periodic.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_time</em>&nbsp;</td><td>is the absolute time to wait before the task start running, in clock ticks.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>period</em>&nbsp;</td><td>corresponds to the period of the task, in clock ticks.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. A negative value on failure as described below:<ul>
<li><b>EINVAL:</b> task does not refer to a valid task.</li></ul>
</td></tr>
  </table>
</dl>
See also: <a class="el" href="api_8c.html#rt_task_make_periodic_relative_ns">rt_task_make_periodic_relative_ns</a>(). Recall that the term clock ticks depends on the mode in which the hard timer runs. So if the hard timer was set as periodic a clock tick will last as the period set in start_rt_timer, while if oneshot mode is used a clock tick will last as the inverse of the running frequency of the hard timer in use and irrespective of any period used in the call to start_rt_timer.     </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="api.c::rt_task_make_periodic_relative_ns"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_task_make_periodic_relative_ns           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>start_delay</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>period</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make a task run periodically. 
<p>
<a class="anchor" name="rt_task_make_periodic_relative_ns"></a> rt_task_make_periodic_relative_ns mark the task <em>task</em>, previously created with <a class="el" href="group__lxrt.html#ga6">rt_task_init</a>(), as suitable for a periodic execution, with period <em>period</em>, when <a class="el" href="api_8c.html#rt_task_wait_period">rt_task_wait_period</a>() is called.<p>
The time of first execution is defined through <em>start_time</em> or <em>start_delay</em>. <em>start_time</em> is an absolute value measured in clock ticks. <em>start_delay</em> is relative to the current time and measured in nanoseconds.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to the task you want to make periodic.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start_delay</em>&nbsp;</td><td>is the time, to wait before the task start running, in nanoseconds.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>period</em>&nbsp;</td><td>corresponds to the period of the task, in nanoseconds.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. A negative value on failure as described below:<ul>
<li><b>EINVAL:</b> task does not refer to a valid task.</li></ul>
</td></tr>
  </table>
</dl>
Recall that the term clock ticks depends on the mode in which the hard timer runs. So if the hard timer was set as periodic a clock tick will last as the period set in start_rt_timer, while if oneshot mode is used a clock tick will last as the inverse of the running frequency of the hard timer in use and irrespective of any period used in the call to start_rt_timer.     </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="api.c::rt_task_resume"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_task_resume           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resume a task. 
<p>
<a class="anchor" name="rt_task_resume"></a> rt_task_resume resumes execution of the task <em>task</em> previously suspended by <a class="el" href="api_8c.html#rt_task_suspend">rt_task_suspend</a>(), or makes a newly created task ready to run, if it makes the task ready. Since no account is made for multiple suspend rt_task_resume unconditionally resumes any task it makes ready.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>pointer to a task structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL:</b> task does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>the new RTAI 24.1.xx (FIXME) development releases take into account multiple suspend and require as many rt_task_resumes as the rt_task_suspends placed on a task. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="api.c::rt_task_signal_handler"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_task_signal_handler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void(*)(void)&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the signal handler of a task. 
<p>
<a class="anchor" name="rt_task_signal_handler"></a><p>
rt_task_signal_handler installs, or changes, the signal function of a real time task.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to the real time task.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>is the entry point of the signal function.</td></tr>
  </table>
</dl>
A signal handler function can be set also when the task is newly created with <a class="el" href="group__lxrt.html#ga6">rt_task_init</a>(). The signal handler is a function called within the task environment and with interrupts disabled, when the task becomes the current running task after a context switch, except at its very first scheduling. It allows you to implement whatever signal management policy you think useful, and many other things as well (FIXME).<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success.A negative value on failure as described below:<ul>
<li><b>EINVAL:</b> task does not refer to a valid task. </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="api.c::rt_task_suspend"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_task_suspend           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
rt_task_suspend suspends execution of the task task. 
<p>
<a class="anchor" name="rt_task_suspend"></a> It will not be executed until a call to <a class="el" href="api_8c.html#rt_task_resume">rt_task_resume</a>() or <a class="el" href="api_8c.html#rt_task_make_periodic">rt_task_make_periodic</a>() is made. No account is made for multiple suspends, i.e. a multiply suspended task is made ready as soon as it is rt_task_resumed, thus immediately resuming its execution if it is the highest in priority.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>pointer to a task structure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL:</b> task does not refer to a valid task.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>the new RTAI 24.1.xx (FIXME) development releases take into account multiple suspend and require as many <a class="el" href="api_8c.html#rt_task_resume">rt_task_resume</a>() as the rt_task_suspends placed on a task. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="api.c::rt_task_use_fpu"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_task_use_fpu           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>use_fpu_flag</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="anchor" name="rt_task_use_fpu"></a><p>
rt_task_use_fpu informs the scheduler that floating point arithmetic operations will be used by the real time task <em>task</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>is a pointer to the real time task.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_fpu_flag</em>&nbsp;</td><td>If this parameter has a nonzero value, the Floating Point Unit (FPU) context is also switched when <em>task</em> or the kernel becomes active. This makes task switching slower, negligibly, on all 32 bits CPUs but 386s and the oldest 486s. This flag can be set also by <a class="el" href="group__lxrt.html#ga6">rt_task_init</a>() when the real time task is created. With UP and MUP schedulers care is taken to avoid useless saves/restores of the FPU environment. Under SMP tasks can be moved from CPU to CPU so saves/restores for tasks using the FPU are always carried out.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL:</b> task does not refer to a valid task.</li></ul>
</dd></dl>
See also: <a class="el" href="api_8c.html#rt_linux_use_fpu">rt_linux_use_fpu</a>().     </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="api.c::rt_task_wait_period"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_task_wait_period           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wait till next period. 
<p>
<a class="anchor" name="rt_task_wait_period"></a> rt_task_wait_period suspends the execution of the currently running real time task until the next period is reached. The task must have been previously marked for a periodic execution by calling <a class="el" href="api_8c.html#rt_task_make_periodic">rt_task_make_periodic</a>() or <a class="el" href="api_8c.html#rt_task_make_periodic_relative_ns">rt_task_make_periodic_relative_ns</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>The task is suspended only temporarily, i.e. it simply gives up control until the next time period. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="api.c::rt_task_yield"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_task_yield           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Yield the current task. 
<p>
<a class="anchor" name="rt_task_yield"></a> <a class="el" href="api_8c.html#rt_task_yield">rt_task_yield</a>() stops the current task and takes it at the end of the list of ready tasks having its same priority. The scheduler makes the next ready task of the same priority active.<p>
Recall that RTAI schedulers allow only higher priority tasks to preempt the execution of lower priority ones. So equal priority tasks cannot preempt each other and <a class="el" href="api_8c.html#rt_task_yield">rt_task_yield</a>() should be used if a user needs a cooperative time slicing among equal priority tasks. The implementation of the related policy is wholly in the hand of the user. It is believed that time slicing is too much an overhead for the most demanding real time applications, so it is left up to you.     </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="api.c::rt_whoami"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_whoami           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the task pointer of the current task. 
<p>
<a class="anchor" name="rt_whoami"></a><p>
Calling rt_whoami from a task can get a pointer to its own task structure.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The pointer to the current task. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:53 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
