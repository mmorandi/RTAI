<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTAI API: base/sched/api.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RTAI API<span id="projectnumber">&#160;5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('api_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">api.c File Reference<div class="ingroups"><a class="el" href="group__lxrt.html">LXRT module.</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Common scheduling function.  
<a href="#details">More...</a></p>
<div class="textblock"><div class="dynheader">
Include dependency graph for api.c:</div>
<div class="dyncontent">
<div class="center"><img src="api_8c__incl.png" border="0" usemap="#abase_2sched_2api_8c" alt=""/></div>
<map name="abase_2sched_2api_8c" id="abase_2sched_2api_8c">
<area shape="rect" title="Common scheduling function." alt="" coords="318,5,439,31"/>
<area shape="rect" title=" " alt="" coords="5,79,112,104"/>
<area shape="rect" title=" " alt="" coords="136,79,235,104"/>
<area shape="rect" title=" " alt="" coords="259,79,370,104"/>
<area shape="rect" title=" " alt="" coords="394,79,491,104"/>
<area shape="rect" href="rtai__registry_8h.html" title=" " alt="" coords="515,79,618,104"/>
<area shape="rect" href="rtai__lxrt_8h.html" title="LXRT main header." alt="" coords="831,79,910,104"/>
<area shape="rect" href="rtai__nam2num_8h.html" title="Conversion between 6 characters strings and unsigned long identifiers." alt="" coords="318,152,434,177"/>
<area shape="rect" title=" " alt="" coords="343,225,409,251"/>
<area shape="rect" title=" " alt="" coords="435,225,501,251"/>
<area shape="rect" title=" " alt="" coords="509,152,600,177"/>
<area shape="rect" title=" " alt="" coords="625,152,719,177"/>
<area shape="rect" title=" " alt="" coords="743,152,811,177"/>
<area shape="rect" title=" " alt="" coords="836,152,905,177"/>
<area shape="rect" title=" " alt="" coords="929,152,991,177"/>
<area shape="rect" title=" " alt="" coords="1015,152,1079,177"/>
<area shape="rect" title=" " alt="" coords="1103,152,1209,177"/>
<area shape="rect" title=" " alt="" coords="1233,152,1300,177"/>
<area shape="rect" title=" " alt="" coords="1325,152,1401,177"/>
<area shape="rect" title=" " alt="" coords="1425,152,1493,177"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad3b4d6a598eeaa7d7f213d5776ec3f51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#ad3b4d6a598eeaa7d7f213d5776ec3f51">rt_get_prio</a> (RT_TASK *task)</td></tr>
<tr class="memdesc:ad3b4d6a598eeaa7d7f213d5776ec3f51"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_get_prio"></a> <a href="api_8c.html#ad3b4d6a598eeaa7d7f213d5776ec3f51">More...</a><br /></td></tr>
<tr class="separator:ad3b4d6a598eeaa7d7f213d5776ec3f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329db0e016990ac277d9e44587ae0eb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a329db0e016990ac277d9e44587ae0eb1">rt_get_inher_prio</a> (RT_TASK *task)</td></tr>
<tr class="memdesc:a329db0e016990ac277d9e44587ae0eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_get_inher_prio"></a> <a href="api_8c.html#a329db0e016990ac277d9e44587ae0eb1">More...</a><br /></td></tr>
<tr class="separator:a329db0e016990ac277d9e44587ae0eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a190b1947e86e53fcf89bf4ea899917"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a2a190b1947e86e53fcf89bf4ea899917">rt_get_priorities</a> (RT_TASK *task, int *priority, int *base_priority)</td></tr>
<tr class="memdesc:a2a190b1947e86e53fcf89bf4ea899917"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_get_priorities"></a> <a href="api_8c.html#a2a190b1947e86e53fcf89bf4ea899917">More...</a><br /></td></tr>
<tr class="separator:a2a190b1947e86e53fcf89bf4ea899917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1daa0d4d0d5090bcec2a9d8af552f4"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#adc1daa0d4d0d5090bcec2a9d8af552f4">rt_task_get_info</a> (RT_TASK *task, RT_TASK_INFO *task_info)</td></tr>
<tr class="memdesc:adc1daa0d4d0d5090bcec2a9d8af552f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_task_get_info"></a> <a href="api_8c.html#adc1daa0d4d0d5090bcec2a9d8af552f4">More...</a><br /></td></tr>
<tr class="separator:adc1daa0d4d0d5090bcec2a9d8af552f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419145276401d19064b866f97dce599e"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a419145276401d19064b866f97dce599e">rt_change_prio</a> (RT_TASK *task, int priority)</td></tr>
<tr class="memdesc:a419145276401d19064b866f97dce599e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_change_prio"></a> <a href="api_8c.html#a419145276401d19064b866f97dce599e">More...</a><br /></td></tr>
<tr class="separator:a419145276401d19064b866f97dce599e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e88a0497238e60c0499ad58624a6991"><td class="memItemLeft" align="right" valign="top">RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a9e88a0497238e60c0499ad58624a6991">rt_whoami</a> (void)</td></tr>
<tr class="memdesc:a9e88a0497238e60c0499ad58624a6991"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_whoami"></a> <a href="api_8c.html#a9e88a0497238e60c0499ad58624a6991">More...</a><br /></td></tr>
<tr class="separator:a9e88a0497238e60c0499ad58624a6991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9a444bbdb32a478b1ae793ccde4614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a8a9a444bbdb32a478b1ae793ccde4614">rt_task_yield</a> (void)</td></tr>
<tr class="memdesc:a8a9a444bbdb32a478b1ae793ccde4614"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_task_yield"></a>Yield the current task.  <a href="api_8c.html#a8a9a444bbdb32a478b1ae793ccde4614">More...</a><br /></td></tr>
<tr class="separator:a8a9a444bbdb32a478b1ae793ccde4614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcabe38a44048bad12d7173a53bc0895"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#abcabe38a44048bad12d7173a53bc0895">rt_task_suspend</a> (RT_TASK *task)</td></tr>
<tr class="memdesc:abcabe38a44048bad12d7173a53bc0895"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_task_suspend"></a>rt_task_suspend suspends execution of the task task.  <a href="api_8c.html#abcabe38a44048bad12d7173a53bc0895">More...</a><br /></td></tr>
<tr class="separator:abcabe38a44048bad12d7173a53bc0895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaac1a64e91d5ef126497a87fecbec5"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#afeaac1a64e91d5ef126497a87fecbec5">rt_task_resume</a> (RT_TASK *task)</td></tr>
<tr class="memdesc:afeaac1a64e91d5ef126497a87fecbec5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_task_resume"></a>Resume a task.  <a href="api_8c.html#afeaac1a64e91d5ef126497a87fecbec5">More...</a><br /></td></tr>
<tr class="separator:afeaac1a64e91d5ef126497a87fecbec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7cdc96cca13b5bb084fcd0c323e8a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#aff7cdc96cca13b5bb084fcd0c323e8a5">rt_get_task_state</a> (RT_TASK *task)</td></tr>
<tr class="memdesc:aff7cdc96cca13b5bb084fcd0c323e8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_get_task_state"></a>Query task state  <a href="api_8c.html#aff7cdc96cca13b5bb084fcd0c323e8a5">More...</a><br /></td></tr>
<tr class="separator:aff7cdc96cca13b5bb084fcd0c323e8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9107efafa0dcb51e81dd4c515e74e512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a9107efafa0dcb51e81dd4c515e74e512">rt_linux_use_fpu</a> (int use_fpu_flag)</td></tr>
<tr class="memdesc:a9107efafa0dcb51e81dd4c515e74e512"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_linux_use_fpu"></a> <a href="api_8c.html#a9107efafa0dcb51e81dd4c515e74e512">More...</a><br /></td></tr>
<tr class="separator:a9107efafa0dcb51e81dd4c515e74e512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc70267c2a16cfe8f1de3763ae2d438f"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#abc70267c2a16cfe8f1de3763ae2d438f">rt_task_use_fpu</a> (RT_TASK *task, int use_fpu_flag)</td></tr>
<tr class="memdesc:abc70267c2a16cfe8f1de3763ae2d438f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_task_use_fpu"></a> <a href="api_8c.html#abc70267c2a16cfe8f1de3763ae2d438f">More...</a><br /></td></tr>
<tr class="separator:abc70267c2a16cfe8f1de3763ae2d438f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e38c283426df4a55f9229f01a684217"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a3e38c283426df4a55f9229f01a684217">rt_task_signal_handler</a> (RT_TASK *task, void(*handler)(void))</td></tr>
<tr class="memdesc:a3e38c283426df4a55f9229f01a684217"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_task_signal_handler"></a> <a href="api_8c.html#a3e38c283426df4a55f9229f01a684217">More...</a><br /></td></tr>
<tr class="separator:a3e38c283426df4a55f9229f01a684217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593d82ec09dc65c8c09c9ee75fe2edd0"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a593d82ec09dc65c8c09c9ee75fe2edd0">rt_task_make_periodic_relative_ns</a> (RT_TASK *task, RTIME start_delay, RTIME period)</td></tr>
<tr class="memdesc:a593d82ec09dc65c8c09c9ee75fe2edd0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_task_make_periodic_relative_ns"></a>Make a task run periodically.  <a href="api_8c.html#a593d82ec09dc65c8c09c9ee75fe2edd0">More...</a><br /></td></tr>
<tr class="separator:a593d82ec09dc65c8c09c9ee75fe2edd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9ed28242367a9fa18014b9d32ae0f2"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#ade9ed28242367a9fa18014b9d32ae0f2">rt_task_make_periodic</a> (RT_TASK *task, RTIME start_time, RTIME period)</td></tr>
<tr class="memdesc:ade9ed28242367a9fa18014b9d32ae0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_task_make_periodic"></a>Make a task run periodically  <a href="api_8c.html#ade9ed28242367a9fa18014b9d32ae0f2">More...</a><br /></td></tr>
<tr class="separator:ade9ed28242367a9fa18014b9d32ae0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4176714390da3fc9e23f9091dc353f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#aed4176714390da3fc9e23f9091dc353f">rt_task_wait_period</a> (void)</td></tr>
<tr class="memdesc:aed4176714390da3fc9e23f9091dc353f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_task_wait_period"></a>Wait till next period.  <a href="api_8c.html#aed4176714390da3fc9e23f9091dc353f">More...</a><br /></td></tr>
<tr class="separator:aed4176714390da3fc9e23f9091dc353f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd5d660c3dc8da9ecb0a234ffe9d5f5"><td class="memItemLeft" align="right" valign="top">RTIME&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#abdd5d660c3dc8da9ecb0a234ffe9d5f5">next_period</a> (void)</td></tr>
<tr class="memdesc:abdd5d660c3dc8da9ecb0a234ffe9d5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="next_period"></a> <a href="api_8c.html#abdd5d660c3dc8da9ecb0a234ffe9d5f5">More...</a><br /></td></tr>
<tr class="separator:abdd5d660c3dc8da9ecb0a234ffe9d5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64eeb9acf2f8358cadc796d19f3bd18d"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a64eeb9acf2f8358cadc796d19f3bd18d">rt_busy_sleep</a> (int ns)</td></tr>
<tr class="memdesc:a64eeb9acf2f8358cadc796d19f3bd18d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_busy_sleep"></a> <a href="api_8c.html#a64eeb9acf2f8358cadc796d19f3bd18d">More...</a><br /></td></tr>
<tr class="separator:a64eeb9acf2f8358cadc796d19f3bd18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9398ea1bc326c783b1b83d3bc0a2011e"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a9398ea1bc326c783b1b83d3bc0a2011e">rt_sleep</a> (RTIME delay)</td></tr>
<tr class="memdesc:a9398ea1bc326c783b1b83d3bc0a2011e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_sleep"></a> <a href="api_8c.html#a9398ea1bc326c783b1b83d3bc0a2011e">More...</a><br /></td></tr>
<tr class="separator:a9398ea1bc326c783b1b83d3bc0a2011e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2217e92524304d5eccc037cda6a37a74"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html#a2217e92524304d5eccc037cda6a37a74">rt_sleep_until</a> (RTIME time)</td></tr>
<tr class="memdesc:a2217e92524304d5eccc037cda6a37a74"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="rt_sleep_until"></a> <a href="api_8c.html#a2217e92524304d5eccc037cda6a37a74">More...</a><br /></td></tr>
<tr class="separator:a2217e92524304d5eccc037cda6a37a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b09f30503a969be7ea781f306015944"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga2b09f30503a969be7ea781f306015944">rt_register</a> (unsigned long name, void *adr, int type, struct task_struct *t)</td></tr>
<tr class="memdesc:ga2b09f30503a969be7ea781f306015944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an object.  <a href="group__lxrt.html#ga2b09f30503a969be7ea781f306015944">More...</a><br /></td></tr>
<tr class="separator:ga2b09f30503a969be7ea781f306015944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b58c40321e007796b5429ef984417c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga5b58c40321e007796b5429ef984417c0">rt_drg_on_name</a> (unsigned long name)</td></tr>
<tr class="memdesc:ga5b58c40321e007796b5429ef984417c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an object by its name.  <a href="group__lxrt.html#ga5b58c40321e007796b5429ef984417c0">More...</a><br /></td></tr>
<tr class="separator:ga5b58c40321e007796b5429ef984417c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d0691b3f239aee2942ca1cc348217e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#gab5d0691b3f239aee2942ca1cc348217e">rt_drg_on_adr</a> (void *adr)</td></tr>
<tr class="memdesc:gab5d0691b3f239aee2942ca1cc348217e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an object by its address.  <a href="group__lxrt.html#gab5d0691b3f239aee2942ca1cc348217e">More...</a><br /></td></tr>
<tr class="separator:gab5d0691b3f239aee2942ca1cc348217e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Common scheduling function. </p>
<dl class="section author"><dt>Author</dt><dd>Paolo Mantegazza</dd></dl>
<p>This file is part of the RTAI project.</p>
<dl class="section note"><dt>Note</dt><dd>Copyright &copy; 1999-2017 Paolo Mantegazza <a href="#" onclick="location.href='mai'+'lto:'+'man'+'te'+'gaz'+'za'+'@ae'+'ro'+'.po'+'li'+'mi.'+'it'; return false;">mante<span class="obfuscator">.nosp@m.</span>gazz<span class="obfuscator">.nosp@m.</span>a@aer<span class="obfuscator">.nosp@m.</span>o.po<span class="obfuscator">.nosp@m.</span>limi.<span class="obfuscator">.nosp@m.</span>it</a></dd></dl>
<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p>
<p >This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p >You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="abdd5d660c3dc8da9ecb0a234ffe9d5f5" name="abdd5d660c3dc8da9ecb0a234ffe9d5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd5d660c3dc8da9ecb0a234ffe9d5f5">&#9670;&#160;</a></span>next_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTIME next_period </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="next_period"></a></p>
<p >Get the time a periodic task will be resumed after calling rt_task_wait_period.</p>
<p >this function returns the time when the caller task will run next. Combined with the appropriate rt_get_time function() it can be used for checking the fraction of period used or any period overrun.</p>
<dl class="section return"><dt>Returns</dt><dd>Next period time in internal count units. </dd></dl>

</div>
</div>
<a id="a64eeb9acf2f8358cadc796d19f3bd18d" name="a64eeb9acf2f8358cadc796d19f3bd18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64eeb9acf2f8358cadc796d19f3bd18d">&#9670;&#160;</a></span>rt_busy_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE void rt_busy_sleep </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_busy_sleep"></a></p>
<p >Delay/suspend execution for a while.</p>
<p >rt_busy_sleep delays the execution of the caller task without giving back the control to the scheduler. This function burns away CPU cycles in a busy wait loop so it should be used only for very short synchronization delays. On machine not having a TSC clock it can lead to many microseconds uncertain busy sleeps because of the need of reading the 8254 timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>is the number of nanoseconds to wait.</td></tr>
  </table>
  </dd>
</dl>
<p>See also: rt_sleep(), rt_sleep_until().</p>
<dl class="section note"><dt>Note</dt><dd>A higher priority task or interrupt handler can run before the task goes to sleep, so the actual time spent in these functions may be longer than that specified. </dd></dl>

</div>
</div>
<a id="a419145276401d19064b866f97dce599e" name="a419145276401d19064b866f97dce599e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419145276401d19064b866f97dce599e">&#9670;&#160;</a></span>rt_change_prio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_change_prio </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_change_prio"></a></p>
<p >Change a task priority.</p>
<p >rt_change_prio changes the base priority of task <em>task</em> to <em>prio</em>.</p>
<p >Recall that a task has a base native priority, assigned at its birth or by rt_change_prio(), and an actual, inherited, priority. They can be different because of priority inheritance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is the affected task.</td></tr>
    <tr><td class="paramname">priority</td><td>is the new priority, it can range within 0 &lt; prio &lt; RT_SCHED_LOWEST_PRIORITY.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rt_change_prio returns the base priority task <em>task</em> had before the change. </dd></dl>

</div>
</div>
<a id="a329db0e016990ac277d9e44587ae0eb1" name="a329db0e016990ac277d9e44587ae0eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329db0e016990ac277d9e44587ae0eb1">&#9670;&#160;</a></span>rt_get_inher_prio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_get_inher_prio </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_get_inher_prio"></a></p>
<p >Check a task priority.</p>
<p >rt_get_prio returns the base priority task <em>task</em> has inherited from other tasks, either blocked on resources owned by or waiting to pass a message to task <em>task</em>.</p>
<p >Recall that a task has a base native priority, assigned at its birth or by rt_change_prio(), and an actual, inherited, priority. They can be different because of priority inheritance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is the affected task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rt_get_inher_prio returns the priority of task <em>task</em>. </dd></dl>

</div>
</div>
<a id="ad3b4d6a598eeaa7d7f213d5776ec3f51" name="ad3b4d6a598eeaa7d7f213d5776ec3f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b4d6a598eeaa7d7f213d5776ec3f51">&#9670;&#160;</a></span>rt_get_prio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_get_prio </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_get_prio"></a></p>
<p >Check a task priority.</p>
<p >rt_get_prio returns the base priority of task <em>task</em>.</p>
<p >Recall that a task has a base native priority, assigned at its birth or by rt_change_prio(), and an actual, inherited, priority. They can be different because of priority inheritance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is the affected task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rt_get_prio returns the priority of task <em>task</em>. </dd></dl>

</div>
</div>
<a id="a2a190b1947e86e53fcf89bf4ea899917" name="a2a190b1947e86e53fcf89bf4ea899917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a190b1947e86e53fcf89bf4ea899917">&#9670;&#160;</a></span>rt_get_priorities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_get_priorities </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>base_priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_get_priorities"></a></p>
<p >Check inheredited and base priority.</p>
<p >rt_get_priorities returns the base and inherited priorities of a task.</p>
<p >Recall that a task has a base native priority, assigned at its birth or by rt_change_prio(), and an actual, inherited, priority. They can be different because of priority inheritance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is the affected task.</td></tr>
    <tr><td class="paramname">priority</td><td>the actual, e.e. inherited priority.</td></tr>
    <tr><td class="paramname">base_priority</td><td>the base priority.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rt_get_priority returns 0 if non NULL priority addresses are given, EINVAL if addresses are NULL or task is not a valid object. </dd></dl>

</div>
</div>
<a id="aff7cdc96cca13b5bb084fcd0c323e8a5" name="aff7cdc96cca13b5bb084fcd0c323e8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7cdc96cca13b5bb084fcd0c323e8a5">&#9670;&#160;</a></span>rt_get_task_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_get_task_state </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_get_task_state"></a>Query task state </p>
<p >rt_get_task_state returns the state of a real time task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to the task structure.</td></tr>
  </table>
  </dd>
</dl>
<p>Task state is formed by the bitwise OR of one or more of the following flags:</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">READY</td><td>Task <em>task</em> is ready to run (i.e. unblocked). Note that on a UniProcessor machine the currently running task is just in READY state, while on MultiProcessors can be (READY | RUNNING), see below. </td></tr>
    <tr><td class="paramname">SUSPENDED</td><td>Task <em>task</em> blocked waiting for a resume. </td></tr>
    <tr><td class="paramname">DELAYED</td><td>Task <em>task</em> blocked waiting for its next running period or expiration of a timeout. </td></tr>
    <tr><td class="paramname">SEMAPHORE</td><td>Task <em>task</em> blocked on a semaphore, waiting for the semaphore to be signaled. </td></tr>
    <tr><td class="paramname">SEND</td><td>Task <em>task</em> blocked on sending a message, receiver was not in RECEIVE state. </td></tr>
    <tr><td class="paramname">RECEIVE</td><td>Task <em>task</em> blocked waiting for incoming messages, sends or rpcs. </td></tr>
    <tr><td class="paramname">RPC</td><td>Task <em>task</em> blocked on a Remote Procedure Call, receiver was not in RECEIVE state. </td></tr>
    <tr><td class="paramname">RETURN</td><td>Task <em>task</em> blocked waiting for a return from a Remote Procedure Call, receiver got the RPC but has not replied yet. </td></tr>
    <tr><td class="paramname">RUNNING</td><td>Task <em>task</em> is running, used only for SMP schedulers.</td></tr>
  </table>
  </dd>
</dl>
<p>The returned task state is just an approximate information. Timer and other hardware interrupts may cause a change in the state of the queried task before the caller could evaluate the returned value. Caller should disable interrupts if it wants reliable info about an other task. rt_get_task_state does not perform any check on pointer task. </p>

</div>
</div>
<a id="a9107efafa0dcb51e81dd4c515e74e512" name="a9107efafa0dcb51e81dd4c515e74e512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9107efafa0dcb51e81dd4c515e74e512">&#9670;&#160;</a></span>rt_linux_use_fpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_linux_use_fpu </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_fpu_flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_linux_use_fpu"></a></p>
<p >Set indication of FPU usage.</p>
<p >rt_linux_use_fpu informs the scheduler that floating point arithmetic operations will be used also by foreground Linux processes, i.e. the Linux kernel itself (unlikely) and any of its processes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">use_fpu_flag</td><td>If this parameter has a nonzero value, the Floating Point Unit (FPU) context is also switched when <em>task</em> or the kernel becomes active. This makes task switching slower, negligibly, on all 32 bits CPUs but 386s and the oldest 486s. This flag can be set also by rt_task_init when the real time task is created. With UP and MUP schedulers care is taken to avoid useless saves/ restores of the FPU environment. Under SMP tasks can be moved from CPU to CPU so saves/restores for tasks using the FPU are always carried out. Note that by default Linux has this flag cleared. Beside by using rt_linux_use_fpu you can change the Linux FPU flag when you insmod any RTAI scheduler module by setting the LinuxFpu command line parameter of the rtai_sched module itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL:</b> task does not refer to a valid task.</li>
</ul>
</dd></dl>
<p>See also: <a class="el" href="api_8c.html#a9107efafa0dcb51e81dd4c515e74e512">rt_linux_use_fpu()</a>. </p>

</div>
</div>
<a id="a9398ea1bc326c783b1b83d3bc0a2011e" name="a9398ea1bc326c783b1b83d3bc0a2011e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9398ea1bc326c783b1b83d3bc0a2011e">&#9670;&#160;</a></span>rt_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_sleep </td>
          <td>(</td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_sleep"></a></p>
<p >Delay/suspend execution for a while.</p>
<p >rt_sleep suspends execution of the caller task for a time of delay internal count units. During this time the CPU is used by other tasks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>Corresponds to the time the task is going to be suspended.</td></tr>
  </table>
  </dd>
</dl>
<p>See also: rt_busy_sleep(), rt_sleep_until().</p>
<dl class="section return"><dt>Returns</dt><dd>0 if the delay expires as expected. An abnormal termination returns as described below:<ul>
<li><b>RTE_UNBLKD:</b> the task was unblocked while sleeping;</li>
<li><b>RTE_TMROVRN:</b> an immediate return was taken because the delay is too short to be honoured.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A higher priority task or interrupt handler can run before the task goes to sleep, so the actual time spent in these functions may be longer than the the one specified. </dd></dl>

</div>
</div>
<a id="a2217e92524304d5eccc037cda6a37a74" name="a2217e92524304d5eccc037cda6a37a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2217e92524304d5eccc037cda6a37a74">&#9670;&#160;</a></span>rt_sleep_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_sleep_until </td>
          <td>(</td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_sleep_until"></a></p>
<p >Delay/suspend execution for a while.</p>
<p >rt_sleep_until is similar to rt_sleep() but the parameter time is the absolute time till the task have to be suspended. If the given time is already passed this call has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Absolute time till the task have to be suspended</td></tr>
  </table>
  </dd>
</dl>
<p>See also: rt_busy_sleep(), rt_sleep_until().</p>
<dl class="section return"><dt>Returns</dt><dd>0 if the sleeping expires as expected. An abnormal termination returns as described below:<ul>
<li><b>RTE_UNBLKD:</b> the task was unblocked while sleeping;</li>
<li><b>RTE_TMROVRN:</b> an immediate return was taken because the time deadline has already expired.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A higher priority task or interrupt handler can run before the task goes to sleep, so the actual time spent in these functions may be longer than the the one specified. </dd></dl>

</div>
</div>
<a id="adc1daa0d4d0d5090bcec2a9d8af552f4" name="adc1daa0d4d0d5090bcec2a9d8af552f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1daa0d4d0d5090bcec2a9d8af552f4">&#9670;&#160;</a></span>rt_task_get_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_task_get_info </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_TASK_INFO *&#160;</td>
          <td class="paramname"><em>task_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_task_get_info"></a></p>
<p >Get task task data listed in RT_TASK_INFO type.</p>
<p >rt_task_get_info returns task data listed in RT_TASK_INFO type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is the task of interest, NULL can be used for the current task. </td></tr>
    <tr><td class="paramname">task_info</td><td>a pointer to RT_TASK_INFO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if task is not valid or task_info is NULL, 0 if OK. </dd></dl>

</div>
</div>
<a id="ade9ed28242367a9fa18014b9d32ae0f2" name="ade9ed28242367a9fa18014b9d32ae0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9ed28242367a9fa18014b9d32ae0f2">&#9670;&#160;</a></span>rt_task_make_periodic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_task_make_periodic </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>start_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_task_make_periodic"></a>Make a task run periodically </p>
<p >rt_task_make_periodic mark the task <em>task</em>, previously created with <a class="el" href="group__lxrt.html#gaf619b54951a4af8984f616771edd53db">rt_task_init()</a>, as suitable for a periodic execution, with period <em>period</em>, when rt_task_wait_period() is called.</p>
<p >The time of first execution is defined through <em>start_time</em> or <em>start_delay</em>. <em>start_time</em> is an absolute value measured in clock ticks. <em>start_delay</em> is relative to the current time and measured in nanoseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to the task you want to make periodic.</td></tr>
    <tr><td class="paramname">start_time</td><td>is the absolute time to wait before the task start running, in clock ticks.</td></tr>
    <tr><td class="paramname">period</td><td>corresponds to the period of the task, in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success. A negative value on failure as described below:<ul>
<li><b>EINVAL:</b> task does not refer to a valid task.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>See also: rt_task_make_periodic_relative_ns(). Recall that the term clock ticks depends on the mode in which the hard timer runs. So, since only oneshot is used, a clock tick will last as the inverse of the running frequency of the hard timer in use, irrespective of any period used in the call to start_rt_timer. </p>

</div>
</div>
<a id="a593d82ec09dc65c8c09c9ee75fe2edd0" name="a593d82ec09dc65c8c09c9ee75fe2edd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593d82ec09dc65c8c09c9ee75fe2edd0">&#9670;&#160;</a></span>rt_task_make_periodic_relative_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_task_make_periodic_relative_ns </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>start_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_task_make_periodic_relative_ns"></a>Make a task run periodically. </p>
<p >rt_task_make_periodic_relative_ns mark the task <em>task</em>, previously created with <a class="el" href="group__lxrt.html#gaf619b54951a4af8984f616771edd53db">rt_task_init()</a>, as suitable for a periodic execution, with period <em>period</em>, when rt_task_wait_period() is called.</p>
<p >The time of first execution is defined through <em>start_time</em> or <em>start_delay</em>. <em>start_time</em> is an absolute value measured in clock ticks. <em>start_delay</em> is relative to the current time and measured in nanoseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to the task you want to make periodic.</td></tr>
    <tr><td class="paramname">start_delay</td><td>is the time, to wait before the task start running, in nanoseconds.</td></tr>
    <tr><td class="paramname">period</td><td>corresponds to the period of the task, in nanoseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success. A negative value on failure as described below:<ul>
<li><b>EINVAL:</b> task does not refer to a valid task.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Recall that the term clock ticks depends on the mode in which the hard timer runs. So, since only oneshot is used, a clock tick will last as the inverse of the running frequency of the hard timer in use, irrespective of any period used in the call to start_rt_timer. </p>

</div>
</div>
<a id="afeaac1a64e91d5ef126497a87fecbec5" name="afeaac1a64e91d5ef126497a87fecbec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeaac1a64e91d5ef126497a87fecbec5">&#9670;&#160;</a></span>rt_task_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_task_resume </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_task_resume"></a>Resume a task. </p>
<p >rt_task_resume resumes execution of the task <em>task</em> previously suspended by rt_task_suspend(), or makes a newly created task ready to run, if it makes the task ready. Since no account is made for multiple suspend rt_task_resume unconditionally resumes any task it makes ready.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to a task structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL:</b> task does not refer to a valid task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3e38c283426df4a55f9229f01a684217" name="a3e38c283426df4a55f9229f01a684217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e38c283426df4a55f9229f01a684217">&#9670;&#160;</a></span>rt_task_signal_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_task_signal_handler </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_task_signal_handler"></a></p>
<p >Set the signal handler of a task.</p>
<p >rt_task_signal_handler installs, or changes, the signal function of a real time task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to the real time task.</td></tr>
    <tr><td class="paramname">handler</td><td>is the entry point of the signal function.</td></tr>
  </table>
  </dd>
</dl>
<p>A signal handler function can be set also when the task is newly created with <a class="el" href="group__lxrt.html#gaf619b54951a4af8984f616771edd53db">rt_task_init()</a>. The signal handler is a function called within the task environment and with interrupts disabled, when the task becomes the current running task after a context switch, except at its very first scheduling. It allows you to implement whatever signal management policy you think useful, and many other things as well (FIXME).</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success.A negative value on failure as described below:<ul>
<li><b>EINVAL:</b> task does not refer to a valid task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abcabe38a44048bad12d7173a53bc0895" name="abcabe38a44048bad12d7173a53bc0895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcabe38a44048bad12d7173a53bc0895">&#9670;&#160;</a></span>rt_task_suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_task_suspend </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_task_suspend"></a>rt_task_suspend suspends execution of the task task. </p>
<p >It will not be executed until a call to rt_task_resume() or rt_task_make_periodic() is made. Multiple suspends and require as many rt_task_resume() as the rt_task_suspends placed on a task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to a task structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the task suspend depth. An abnormal termination returns as described below:<ul>
<li><b>-EINVAL:</b> task does not refer to a valid task.</li>
<li><b>RTE_UNBLKD:</b> the task was unblocked while suspended; </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abc70267c2a16cfe8f1de3763ae2d438f" name="abc70267c2a16cfe8f1de3763ae2d438f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc70267c2a16cfe8f1de3763ae2d438f">&#9670;&#160;</a></span>rt_task_use_fpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rt_task_use_fpu </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_fpu_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_task_use_fpu"></a></p>
<p >rt_task_use_fpu informs the scheduler that floating point arithmetic operations will be used by the real time task <em>task</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>is a pointer to the real time task.</td></tr>
    <tr><td class="paramname">use_fpu_flag</td><td>If this parameter has a nonzero value, the Floating Point Unit (FPU) context is also switched when <em>task</em> or the kernel becomes active. This makes task switching slower, negligibly, on all 32 bits CPUs but 386s and the oldest 486s. This flag can be set also by <a class="el" href="group__lxrt.html#gaf619b54951a4af8984f616771edd53db">rt_task_init()</a> when the real time task is created. With UP and MUP schedulers care is taken to avoid useless saves/restores of the FPU environment. Under SMP tasks can be moved from CPU to CPU so saves/restores for tasks using the FPU are always carried out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. A negative value on failure as described below:<ul>
<li><b>EINVAL:</b> task does not refer to a valid task.</li>
</ul>
</dd></dl>
<p>See also: <a class="el" href="api_8c.html#a9107efafa0dcb51e81dd4c515e74e512">rt_linux_use_fpu()</a>. </p>

</div>
</div>
<a id="aed4176714390da3fc9e23f9091dc353f" name="aed4176714390da3fc9e23f9091dc353f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4176714390da3fc9e23f9091dc353f">&#9670;&#160;</a></span>rt_task_wait_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_wait_period </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_task_wait_period"></a>Wait till next period. </p>
<p >rt_task_wait_period suspends the execution of the currently running real time task until the next period is reached. The task must have been previously marked for a periodic execution by calling rt_task_make_periodic() or rt_task_make_periodic_relative_ns().</p>
<dl class="section return"><dt>Returns</dt><dd>0 if the period expires as expected. An abnormal termination returns as described below:<ul>
<li><b>RTE_UNBLKD:</b> the task was unblocked while sleeping;</li>
<li><b>RTE_TMROVRN:</b> an immediate return was taken because the next period has already expired.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The task is suspended only temporarily, i.e. it simply gives up control until the next time period. </dd></dl>

</div>
</div>
<a id="a8a9a444bbdb32a478b1ae793ccde4614" name="a8a9a444bbdb32a478b1ae793ccde4614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9a444bbdb32a478b1ae793ccde4614">&#9670;&#160;</a></span>rt_task_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_task_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_task_yield"></a>Yield the current task. </p>
<p >rt_task_yield() stops the current task and takes it at the end of the list of ready tasks having its same priority. The scheduler makes the next ready task of the same priority active. If the current task has the highest priority no more then it results in an immediate rescheduling.</p>
<p >Recall that RTAI schedulers allow only higher priority tasks to preempt the execution of lower priority ones. So equal priority tasks cannot preempt each other and rt_task_yield() should be used if a user needs a cooperative time slicing among equal priority tasks. The implementation of the related policy is wholly in the hand of the user. It is believed that time slicing is too much an overhead for the most demanding real time applications, so it is left up to you. </p>

</div>
</div>
<a id="a9e88a0497238e60c0499ad58624a6991" name="a9e88a0497238e60c0499ad58624a6991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e88a0497238e60c0499ad58624a6991">&#9670;&#160;</a></span>rt_whoami()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RT_TASK * rt_whoami </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="rt_whoami"></a></p>
<p >Get the task pointer of the current task.</p>
<p >Calling rt_whoami from a task can get a pointer to its own task structure.</p>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the current task. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_e914ee4d4a44400f1fdb170cb4ead18a.html">base</a></li><li class="navelem"><a class="el" href="dir_c9c0adc6f2f0cafb89aff20282f582cc.html">sched</a></li><li class="navelem"><a class="el" href="api_8c.html">api.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
