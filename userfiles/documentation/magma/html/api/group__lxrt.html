<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: LXRT module.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>LXRT module.</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
LXRT services (soft-hard real time in user space). 
<p>
LXRT is a module that allows you to use all the services made available by RTAI and its schedulers in user space, both for soft and hard real time. At the moment it is a feature youll find nowhere but with RTAI. For an explanation of how it works see <a class="el" href="lxrt_faq.html">Pierre Cloutiers LXRT-INFORMED FAQs</a>, and the explanation of <a class="el" href="whatis_lxrt.html">the implementation of hard real time in user space</a> (contributed by: Pierre Cloutier, Paolo Mantegazza, Steve Papacharalambous).<p>
LXRT-INFORMED should be the production version of LXRT, the latter being the development version. So it can happen that LXRT-INFORMED could be lagging slightly behind LXRT. If you need to hurry to the services not yet ported to LXRT-INFORMED do it without pain. Even if you are likely to miss some useful services found only in LXRT-INFORMED, we release only when a feature is relatively stable.<p>
From what said above there should be no need for anything specific as all the functions you can use in user space have been already documented in this manual. There are however a few exceptions that need to be explained.<p>
Note also that, as already done for the shared memory services in user space, the function calls for Linux processes are inlined in the file rtai_lxrt.h. This approach has been preferred to a library since it is simpler, more effective, the calls are short and simple so that, even if it is likely that there can be more than just a few per process, they could never be charged of making codes too bigger. Also common to shared memory is the use of unsigned int to identify LXRT objects. If you want to use string identifiers the same support functions, i.e. <a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>, can be used. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__lxrt_8h.html">rtai_lxrt.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LXRT main header. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__mbx_8h.html">rtai_mbx.h</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__nam2num_8h.html">rtai_nam2num.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion between characters strings and unsigned long identifiers. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__registry_8h.html">rtai_registry.h</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__sem_8h.html">rtai_sem.h</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html">api.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Common scheduling function. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga381">rt_mbx_init</a>(name, size)&nbsp;&nbsp;&nbsp;rt_typed_mbx_init(name, size, FIFO_Q)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga382">rt_sem_init</a>(name, value)&nbsp;&nbsp;&nbsp;rt_typed_sem_init(name, value, CNT_SEM)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga383">rt_cond_init</a>(name)&nbsp;&nbsp;&nbsp;rt_typed_sem_init(name, 0, BIN_SEM)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga0">rt_get_adr</a> (unsigned long name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an object address by its name.  <a href="#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga1">rt_get_name</a> (void *adr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an object name by its address.  <a href="#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga6">rt_task_init</a> (int name, int priority, int stack_size, int max_msg_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new real time task in user space.  <a href="#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga9">rt_make_soft_real_time</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a hard real time Linux process, or pthread to the standard Linux behavior.  <a href="#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga73">rt_make_hard_real_time</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give a Linux process, or pthread, hard real time execution capabilities allowing full kernel preemption.  <a href="#ga73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga74">rt_allow_nonroot_hrt</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows a non root user to use the Linux POSIX soft real time process management and memory lock functions, and allows it to do any input-output operation from user space.  <a href="#ga74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga83">rt_register</a> (unsigned long name, void *adr, int type, struct task_struct *t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga84">rt_drg_on_name</a> (unsigned long name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga85">rt_drg_on_adr</a> (void *adr)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="ga383" doxytag="rtai_sem.h::rt_cond_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rt_cond_init          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_typed_sem_init(name, 0, BIN_SEM)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a condition variable.<p>
Allocates and initializes a condition variable to be referred by <em>name</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of the condition variable.</td></tr>
  </table>
</dl>
It is important to remark that the returned pointer cannot be used directly, it is for kernel space data, but just passed as arguments when needed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the condition variable to be used in related calls or 0 if an error has occured. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga381" doxytag="rtai_mbx.h::rt_mbx_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rt_mbx_init          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_typed_mbx_init(name, size, FIFO_Q)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize mailbox.<p>
Initializes a mailbox referred to by <em>name</em> of size <em>size</em>.<p>
It is important to remark that the returned task pointer cannot be used directly, they are for kernel space data, but just passed as arguments when needed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>On success a pointer to the mail box to be used in related calls. <p>
A 0 value is returned if it was not possible to setup the semaphore or something using the same name was found. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga382" doxytag="rtai_sem.h::rt_sem_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define rt_sem_init          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">name,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>value&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;rt_typed_sem_init(name, value, CNT_SEM)</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a counting semaphore.<p>
Allocates and initializes a semaphore to be referred by <em>name</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of the semaphore.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>is the initial value of the semaphore</td></tr>
  </table>
</dl>
It is important to remark that the returned task pointer cannot be used directly, they are for kernel space data, but just passed as arguments when needed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the semaphore to be used in related calls or 0 if an error has occured. </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga74" doxytag="rtai_lxrt.h::rt_allow_nonroot_hrt"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_allow_nonroot_hrt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allows a non root user to use the Linux POSIX soft real time process management and memory lock functions, and allows it to do any input-output operation from user space. 
<p>
Only the process itself can use this functions, it is not possible to impose the related transition from another process.     </td>
  </tr>
</table>
<a class="anchor" name="ga85" doxytag="api.c::rt_drg_on_adr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_drg_on_adr           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>adr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deregister an object by its address.<p>
rt_drg_on_adr deregisters the object identified by its <em>adr</em>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a positive number on success, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga84" doxytag="api.c::rt_drg_on_name"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_drg_on_name           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deregister an object by its name.<p>
rt_drg_on_name deregisters the object identified by its <em>name</em>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a positive number on success, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga0" doxytag="rtai_lxrt.h::rt_get_adr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* rt_get_adr           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get an object address by its name. 
<p>
rt_get_adr returns the address associated to <em>name</em>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the address associated to <em>name</em> on success, 0 on failure </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="rtai_lxrt.h::rt_get_name"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned long rt_get_name           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>adr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get an object name by its address. 
<p>
rt_get_name returns the name pointed by the address <em>adr</em>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the identifier pointed by the address <em>adr</em> on success, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga73" doxytag="rtai_lxrt.h::rt_make_hard_real_time"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_make_hard_real_time           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Give a Linux process, or pthread, hard real time execution capabilities allowing full kernel preemption. 
<p>
rt_make_hard_real_time makes the soft Linux POSIX real time process, from which it is called, a hard real time LXRT process. It is important to remark that this function must be used only with soft Linux POSIX processes having their memory locked in memory. See Linux man pages.<p>
Only the process itself can use this functions, it is not possible to impose the related transition from another process.<p>
Note that processes made hard real time should avoid making any Linux System call that can lead to a task switch as Linux cannot run anymore processes that are made hard real time. To interact with Linux you should couple the process that was made hard real time with a Linux buddy server, either standard or POSIX soft real time. To communicate and synchronize with the buddy you can use the wealth of available RTAI, and its schedulers, services.<p>
After all it is pure nonsense to use a non hard real time Operating System, i.e. Linux, from within hard real time processes.     </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="rtai_lxrt.h::rt_make_soft_real_time"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_make_soft_real_time           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return a hard real time Linux process, or pthread to the standard Linux behavior. 
<p>
rt_make_soft_real_time returns to soft Linux POSIX real time a process, from which it is called, that was made hard real time by a call to rt_make_hard_real_time.<p>
Only the process itself can use this functions, it is not possible to impose the related transition from another process.     </td>
  </tr>
</table>
<a class="anchor" name="ga83" doxytag="api.c::rt_register"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_register           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>adr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct task_struct *&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register an object.<p>
rt_register registers the object to be identified with <em>name</em>, which is pointed by <em>adr</em>.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a positive number on success, 0 on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="rtai_lxrt.h::rt_task_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_task_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>max_msg_size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new real time task in user space. 
<p>
rt_task_init provides a real time buddy, also called proxy, task to the Linux process that wants to access RTAI scheduler services. It needs no task function as none is used, but it does need to setup a task structure and initialize it appropriately as the provided services are carried out as if the Linux process has become an RTAI task. Because of that it requires less arguments and returns the pointer to the task that is to be used in related calls.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is a unique identifier that is possibly used by easing referencing the buddy RTAItask, and thus its peer Linux process.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>is the priority of the buddys priority.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stack_size</em>&nbsp;</td><td>is just what is implied by such a name and refers to the stack size used by the buddy.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_msg_size</em>&nbsp;</td><td>is a hint for the size of the most lengthy message than is likely to be exchanged.</td></tr>
  </table>
</dl>
<em>stack_size</em> and <em>max_msg_size</em> can be zero, in which case the default internal values are used. The assignment of a different value should be required only if you want to use task signal functions. In such a case note that these signal functions are intended to catch asyncrounous events in kernel space and, as such, must be programmed into a companion module and interfaced to their parent Linux process through the available services.<p>
Keep an eye on the default stack (512) and message (256) sizes as they seem to be acceptable, but this API has not been used extensively with complex interrupt service routines. Since the latter are served on the stack of any task being interrupted, and more than one can pile up on the same stack, it can be possible that a larger stack is required. In such a case either recompile lxrt.c with macros STACK_SIZE and MSG_SIZE set appropriately, or explicitly assign larger values at your buddy tasks inits. Note that while the stack size can be critical the message size will not. In fact the module reassigns it, appropriately sized, whenever it is needed. The cost is a kmalloc with GFP_KERNEL that can block, but within the Linux environment. Note also that <em>max_msg_size</em> is for a buffer to be used to copy whatever message, either mailbox or inter task, from user to kernel space, as messages are not necessarily copied immediately, and has nothing to do directly with what you are doing.<p>
It is important to remark that the returned task pointers cannot be used directly, they are for kernel space data, but just passed as arguments when needed.<p>
<dl compact><dt><b>Returns:</b></dt><dd>On success a pointer to the task structure initialized in kernel space. <p>
On failure a 0 value is returned if it was not possible to setup the buddy task or something using the same name was found. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:53 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
