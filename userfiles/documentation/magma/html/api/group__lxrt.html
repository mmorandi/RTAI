<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTAI API: LXRT module.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RTAI API<span id="projectnumber">&#160;5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__lxrt.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">LXRT module.</div></div>
</div><!--header-->
<div class="contents">

<p>LXRT services (soft-hard real time in user space)  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for LXRT module.:</div>
<div class="dyncontent">
<div class="center"><img src="group__lxrt.png" border="0" usemap="#agroup____lxrt" alt=""/></div>
<map name="agroup____lxrt" id="agroup____lxrt">
<area shape="rect" title="LXRT services (soft&#45;hard real time in user space)" alt="" coords="5,42,111,67"/>
<area shape="rect" href="group__shm.html" title=" " alt="" coords="253,5,411,45"/>
<area shape="rect" href="group__tasklets.html" title="The tasklets module adds an interesting feature along the line, pioneered by RTAI,..." alt="" coords="300,70,364,95"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:rtai__lxrt_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__lxrt_8h.html">rtai_lxrt.h</a></td></tr>
<tr class="memdesc:rtai__lxrt_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">LXRT main header. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rtai__mbx_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__mbx_8h.html">rtai_mbx.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rtai__nam2num_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__nam2num_8h.html">rtai_nam2num.h</a></td></tr>
<tr class="memdesc:rtai__nam2num_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion between 6 characters strings and unsigned long identifiers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rtai__registry_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__registry_8h.html">rtai_registry.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:rtai__sem_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__sem_8h.html">rtai_sem.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:api_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="api_8c.html">api.c</a></td></tr>
<tr class="memdesc:api_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common scheduling function. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf586178e26327a8f15c1f88c13fba1c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#gaf586178e26327a8f15c1f88c13fba1c4">rt_mbx_init</a>(name,  size)&#160;&#160;&#160;rt_typed_mbx_init(name, size, FIFO_Q)</td></tr>
<tr class="memdesc:gaf586178e26327a8f15c1f88c13fba1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize mailbox.  <a href="group__lxrt.html#gaf586178e26327a8f15c1f88c13fba1c4">More...</a><br /></td></tr>
<tr class="separator:gaf586178e26327a8f15c1f88c13fba1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23569ca638cdac31d41a3c7bff820598"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga23569ca638cdac31d41a3c7bff820598">rt_sem_init</a>(name,  value)&#160;&#160;&#160;rt_typed_sem_init(name, value, CNT_SEM)</td></tr>
<tr class="memdesc:ga23569ca638cdac31d41a3c7bff820598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a counting semaphore.  <a href="group__lxrt.html#ga23569ca638cdac31d41a3c7bff820598">More...</a><br /></td></tr>
<tr class="separator:ga23569ca638cdac31d41a3c7bff820598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dbaa1fbd576aaca0cbf8ca3fb5b2e99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga3dbaa1fbd576aaca0cbf8ca3fb5b2e99">rt_cond_init</a>(name)&#160;&#160;&#160;rt_typed_sem_init(name, 0, BIN_SEM)</td></tr>
<tr class="memdesc:ga3dbaa1fbd576aaca0cbf8ca3fb5b2e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a condition variable.  <a href="group__lxrt.html#ga3dbaa1fbd576aaca0cbf8ca3fb5b2e99">More...</a><br /></td></tr>
<tr class="separator:ga3dbaa1fbd576aaca0cbf8ca3fb5b2e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac977b736fee9b77b8d7b537bf0867fe3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#gac977b736fee9b77b8d7b537bf0867fe3">rt_get_adr</a> (unsigned long name)</td></tr>
<tr class="memdesc:gac977b736fee9b77b8d7b537bf0867fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an object address by its name.  <a href="group__lxrt.html#gac977b736fee9b77b8d7b537bf0867fe3">More...</a><br /></td></tr>
<tr class="separator:gac977b736fee9b77b8d7b537bf0867fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac02018f755719d63c5f6351e63c23ff9"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#gac02018f755719d63c5f6351e63c23ff9">rt_get_name</a> (void *adr)</td></tr>
<tr class="memdesc:gac02018f755719d63c5f6351e63c23ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an object name by its address.  <a href="group__lxrt.html#gac02018f755719d63c5f6351e63c23ff9">More...</a><br /></td></tr>
<tr class="separator:gac02018f755719d63c5f6351e63c23ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf619b54951a4af8984f616771edd53db"><td class="memItemLeft" align="right" valign="top">RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#gaf619b54951a4af8984f616771edd53db">rt_task_init</a> (unsigned long name, int priority, int stack_size, int max_msg_size)</td></tr>
<tr class="memdesc:gaf619b54951a4af8984f616771edd53db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an RTAI task extension for a Linux process/task in user space.  <a href="group__lxrt.html#gaf619b54951a4af8984f616771edd53db">More...</a><br /></td></tr>
<tr class="separator:gaf619b54951a4af8984f616771edd53db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3a670e6b3a1d29456d2c8279eb57a51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#gae3a670e6b3a1d29456d2c8279eb57a51">rt_make_soft_real_time</a> (void)</td></tr>
<tr class="memdesc:gae3a670e6b3a1d29456d2c8279eb57a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a hard real time Linux process, or pthread to the standard Linux behavior.  <a href="group__lxrt.html#gae3a670e6b3a1d29456d2c8279eb57a51">More...</a><br /></td></tr>
<tr class="separator:gae3a670e6b3a1d29456d2c8279eb57a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2267dda226028d36838c3bdc151d51db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga2267dda226028d36838c3bdc151d51db">rt_make_hard_real_time</a> (void)</td></tr>
<tr class="memdesc:ga2267dda226028d36838c3bdc151d51db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a Linux process, or pthread, hard real time execution capabilities allowing full kernel preemption.  <a href="group__lxrt.html#ga2267dda226028d36838c3bdc151d51db">More...</a><br /></td></tr>
<tr class="separator:ga2267dda226028d36838c3bdc151d51db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09dcd8bf352258ef618e11716ae899fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga09dcd8bf352258ef618e11716ae899fc">rt_allow_nonroot_hrt</a> (void)</td></tr>
<tr class="memdesc:ga09dcd8bf352258ef618e11716ae899fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows a non root user to use the Linux POSIX soft real time process management and memory lock functions, and allows it to do any input-output operation from user space.  <a href="group__lxrt.html#ga09dcd8bf352258ef618e11716ae899fc">More...</a><br /></td></tr>
<tr class="separator:ga09dcd8bf352258ef618e11716ae899fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b09f30503a969be7ea781f306015944"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga2b09f30503a969be7ea781f306015944">rt_register</a> (unsigned long name, void *adr, int type, struct task_struct *t)</td></tr>
<tr class="memdesc:ga2b09f30503a969be7ea781f306015944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an object.  <a href="group__lxrt.html#ga2b09f30503a969be7ea781f306015944">More...</a><br /></td></tr>
<tr class="separator:ga2b09f30503a969be7ea781f306015944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b58c40321e007796b5429ef984417c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#ga5b58c40321e007796b5429ef984417c0">rt_drg_on_name</a> (unsigned long name)</td></tr>
<tr class="memdesc:ga5b58c40321e007796b5429ef984417c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an object by its name.  <a href="group__lxrt.html#ga5b58c40321e007796b5429ef984417c0">More...</a><br /></td></tr>
<tr class="separator:ga5b58c40321e007796b5429ef984417c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d0691b3f239aee2942ca1cc348217e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lxrt.html#gab5d0691b3f239aee2942ca1cc348217e">rt_drg_on_adr</a> (void *adr)</td></tr>
<tr class="memdesc:gab5d0691b3f239aee2942ca1cc348217e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deregister an object by its address.  <a href="group__lxrt.html#gab5d0691b3f239aee2942ca1cc348217e">More...</a><br /></td></tr>
<tr class="separator:gab5d0691b3f239aee2942ca1cc348217e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >LXRT services (soft-hard real time in user space) </p>
<p >LXRT is a module that allows you to use all the services made available by RTAI and its schedulers in user space, both for soft and hard real time. At the moment it is a feature youll find nowhere but with RTAI. For an explanation of how it works see <a class="el" href="lxrt_faq.html">Pierre Cloutiers LXRT-INFORMED FAQs</a>, and the explanation of <a class="el" href="whatis_lxrt.html">the implementation of hard real time in user space</a> (contributed by: Pierre Cloutier, Paolo Mantegazza, Steve Papacharalambous).</p>
<p >LXRT-INFORMED should be the production version of LXRT, the latter being the development version. So it can happen that LXRT-INFORMED could be lagging slightly behind LXRT. If you need to hurry to the services not yet ported to LXRT-INFORMED do it without pain. Even if you are likely to miss some useful services found only in LXRT-INFORMED, we release only when a feature is relatively stable.</p>
<p >From what said above there should be no need for anything specific as all the functions you can use in user space have been already documented in this manual. There are however a few exceptions that need to be explained.</p>
<p >Note also that, as already done for the shared memory services in user space, the function calls for Linux processes are inlined in the file rtai_lxrt.h. This approach has been preferred to a library since it is simpler, more effective, the calls are short and simple so that, even if it is likely that there can be more than just a few per process, they could never be charged of making codes too bigger. Also common to shared memory is the use of unsigned int to identify LXRT objects. If you want to use string identifiers the same support functions, i.e. nam2num() and num2nam(), can be used. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga3dbaa1fbd576aaca0cbf8ca3fb5b2e99" name="ga3dbaa1fbd576aaca0cbf8ca3fb5b2e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dbaa1fbd576aaca0cbf8ca3fb5b2e99">&#9670;&#160;</a></span>rt_cond_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rt_cond_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;rt_typed_sem_init(name, 0, BIN_SEM)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a condition variable. </p>
<p >Allocates and initializes a condition variable to be referred by <em>name</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the condition variable.</td></tr>
  </table>
  </dd>
</dl>
<p>It is important to remark that the returned pointer cannot be used directly, it is for kernel space data, but just passed as arguments when needed.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the condition variable to be used in related calls or 0 if an error has occured. </dd></dl>

</div>
</div>
<a id="gaf586178e26327a8f15c1f88c13fba1c4" name="gaf586178e26327a8f15c1f88c13fba1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf586178e26327a8f15c1f88c13fba1c4">&#9670;&#160;</a></span>rt_mbx_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rt_mbx_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;rt_typed_mbx_init(name, size, FIFO_Q)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize mailbox. </p>
<p >Initializes a mailbox referred to by <em>name</em> of size <em>size</em>.</p>
<p >It is important to remark that the returned task pointer cannot be used directly, they are for kernel space data, but just passed as arguments when needed.</p>
<dl class="section return"><dt>Returns</dt><dd>On success a pointer to the mail box to be used in related calls. </dd>
<dd>
A 0 value is returned if it was not possible to setup the semaphore or something using the same name was found. </dd></dl>

</div>
</div>
<a id="ga23569ca638cdac31d41a3c7bff820598" name="ga23569ca638cdac31d41a3c7bff820598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23569ca638cdac31d41a3c7bff820598">&#9670;&#160;</a></span>rt_sem_init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rt_sem_init</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;rt_typed_sem_init(name, value, CNT_SEM)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a counting semaphore. </p>
<p >Allocates and initializes a semaphore to be referred by <em>name</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the semaphore.</td></tr>
    <tr><td class="paramname">value</td><td>is the initial value of the semaphore</td></tr>
  </table>
  </dd>
</dl>
<p>It is important to remark that the returned task pointer cannot be used directly, they are for kernel space data, but just passed as arguments when needed.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the semaphore to be used in related calls or 0 if an error has occured. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga09dcd8bf352258ef618e11716ae899fc" name="ga09dcd8bf352258ef618e11716ae899fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09dcd8bf352258ef618e11716ae899fc">&#9670;&#160;</a></span>rt_allow_nonroot_hrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_allow_nonroot_hrt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows a non root user to use the Linux POSIX soft real time process management and memory lock functions, and allows it to do any input-output operation from user space. </p>
<p >Only the process itself can use this functions, it is not possible to impose the related transition from another process. </p>

</div>
</div>
<a id="gab5d0691b3f239aee2942ca1cc348217e" name="gab5d0691b3f239aee2942ca1cc348217e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5d0691b3f239aee2942ca1cc348217e">&#9670;&#160;</a></span>rt_drg_on_adr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_drg_on_adr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>adr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deregister an object by its address. </p>
<p >rt_drg_on_adr deregisters the object identified by its <em>adr</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>a positive number on success, 0 on failure. </dd></dl>

</div>
</div>
<a id="ga5b58c40321e007796b5429ef984417c0" name="ga5b58c40321e007796b5429ef984417c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b58c40321e007796b5429ef984417c0">&#9670;&#160;</a></span>rt_drg_on_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_drg_on_name </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deregister an object by its name. </p>
<p >rt_drg_on_name deregisters the object identified by its <em>name</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>a positive number on success, 0 on failure. </dd></dl>

</div>
</div>
<a id="gac977b736fee9b77b8d7b537bf0867fe3" name="gac977b736fee9b77b8d7b537bf0867fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac977b736fee9b77b8d7b537bf0867fe3">&#9670;&#160;</a></span>rt_get_adr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * rt_get_adr </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an object address by its name. </p>
<p >rt_get_adr returns the address associated to <em>name</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>the address associated to <em>name</em> on success, 0 on failure </dd></dl>

</div>
</div>
<a id="gac02018f755719d63c5f6351e63c23ff9" name="gac02018f755719d63c5f6351e63c23ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac02018f755719d63c5f6351e63c23ff9">&#9670;&#160;</a></span>rt_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long rt_get_name </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>adr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an object name by its address. </p>
<p >rt_get_name returns the name pointed by the address <em>adr</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>the identifier pointed by the address <em>adr</em> on success, 0 on failure. </dd></dl>

</div>
</div>
<a id="ga2267dda226028d36838c3bdc151d51db" name="ga2267dda226028d36838c3bdc151d51db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2267dda226028d36838c3bdc151d51db">&#9670;&#160;</a></span>rt_make_hard_real_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_make_hard_real_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give a Linux process, or pthread, hard real time execution capabilities allowing full kernel preemption. </p>
<p >rt_make_hard_real_time makes the soft Linux POSIX real time process, from which it is called, a hard real time LXRT process. It is important to remark that this function must be used only with soft Linux POSIX processes having their memory locked in memory. See Linux man pages.</p>
<p >Only the process itself can use this functions, it is not possible to impose the related transition from another process.</p>
<p >Note that processes made hard real time should avoid making any Linux System call that can lead to a task switch as Linux cannot run anymore processes that are made hard real time. To interact with Linux you should couple the process that was made hard real time with a Linux buddy server, either standard or POSIX soft real time. To communicate and synchronize with the buddy you can use the wealth of available RTAI, and its schedulers, services.</p>
<p >After all it is pure nonsense to use a non hard real time Operating System, i.e. Linux, from within hard real time processes. </p>

<p class="reference">Referenced by <a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet()</a>.</p>

</div>
</div>
<a id="gae3a670e6b3a1d29456d2c8279eb57a51" name="gae3a670e6b3a1d29456d2c8279eb57a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3a670e6b3a1d29456d2c8279eb57a51">&#9670;&#160;</a></span>rt_make_soft_real_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_make_soft_real_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a hard real time Linux process, or pthread to the standard Linux behavior. </p>
<p >rt_make_soft_real_time returns to soft Linux POSIX real time a process, from which it is called, that was made hard real time by a call to rt_make_hard_real_time.</p>
<p >Only the process itself can use this functions, it is not possible to impose the related transition from another process. </p>

<p class="reference">Referenced by <a class="el" href="group__tasklets.html#ga67b50b50295add10457e86b00b855367">rt_init_tasklet()</a>.</p>

</div>
</div>
<a id="ga2b09f30503a969be7ea781f306015944" name="ga2b09f30503a969be7ea781f306015944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b09f30503a969be7ea781f306015944">&#9670;&#160;</a></span>rt_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_register </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>adr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct task_struct *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an object. </p>
<p >rt_register registers the object to be identified with <em>name</em>, which is pointed by <em>adr</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>a positive number on success, 0 on failure. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__sem.html#gab7abcca83168a9d28b26e216eb02962b">_rt_named_rwl_init()</a>, <a class="el" href="group__sem.html#ga64749a909f8974c977c0fbb2cbef31bb">_rt_named_spl_init()</a>, <a class="el" href="group__mbx.html#ga3ca8b3216f1687590fe6c024639ad61a">_rt_typed_named_mbx_init()</a>, and <a class="el" href="group__sem.html#ga630f67adb4cf3169dbbd20098f50933a">_rt_typed_named_sem_init()</a>.</p>

</div>
</div>
<a id="gaf619b54951a4af8984f616771edd53db" name="gaf619b54951a4af8984f616771edd53db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf619b54951a4af8984f616771edd53db">&#9670;&#160;</a></span>rt_task_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RT_TASK * rt_task_init </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_msg_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an RTAI task extension for a Linux process/task in user space. </p>
<p >rt_task_init extends the Linux task structure, making it possible to use RTAI APIs that wants to access RTAI scheduler services. It needs no task function as none is used, but it does need to setup an RTAI task structure and initialize it appropriately as the provided services are carried out as if the Linux process has become an RTAI task also. Because of that it requires less arguments and returns the pointer to the RTAI task extension that is to be used in related calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is a unique identifier that is possibly used to ease referencing the RTAI task extension of a peer Linux process.</td></tr>
    <tr><td class="paramname">priority</td><td>is the priority of the RTAI task extension.</td></tr>
    <tr><td class="paramname">stack_size,a</td><td>legacy parameter used nomore; kept for portability reasons only. (It was just what is implied by such a name and referred to the stack size used by the buddy in the very first implementation of LXRT).</td></tr>
    <tr><td class="paramname">max_msg_size</td><td>is a hint for the size of the most lengthy intertask message that is likely to be exchanged.</td></tr>
  </table>
  </dd>
</dl>
<p><em>max_msg_size</em> can be zero, in which case a default internal value is used. Keep an eye on such a default message (256) size. It could be possible that a larger size is required to suite your needs best. In such a case either recompile sys.c with the macro MSG_SIZE set appropriately, or assign a larger size here esplicitly. Note that the message size is not critical though. In fact the module reassigns it, dynamically and appropriately sized, whenever it is needed. The cost is a real time allocation of the new buffer. Note also that <em>max_msg_size</em> is for a buffer to be used to copy whatever intertask message from user to kernel space, as intertask messages are not necessarily used immediately.</p>
<p >It is important to remark that the returned task pointers cannot be used directly, they are for kernel space data, but just passed as arguments when needed.</p>
<dl class="section return"><dt>Returns</dt><dd>On success a pointer to the task structure initialized in kernel space. </dd>
<dd>
On failure a NULL value is returned if it was not possible to setup the RTAI task extension or something using the same name was found. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
