<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: base/ipc/msg/msg.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">base</a>&nbsp;/&nbsp;<a class="el" href="dir_000022.html">ipc</a>&nbsp;/&nbsp;<a class="el" href="dir_000027.html">msg</a></div>
<h1>msg.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Message handling functions. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>Paolo Mantegazza</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Copyright (C) 1999-2003 Paolo Mantegazza &lt;<a href="mailto:mantegazza@aero.polimi.it">mantegazza@aero.polimi.it</a>&gt; [ Specific COPYRIGHTS follow along the code ]</dd></dl>
This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.<p>
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.<p>
You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
<p>

<p>
Include dependency graph for msg.c:<p><center><img src="msg_8c__incl.png" border="0" usemap="#msg.c_map" alt="Include dependency graph"></center>
<map name="msg.c_map">
<area href="rtai__schedcore_8h-source.html" shape="rect" coords="58,84,178,108" alt="">
<area href="rtai__msg_8h-source.html" shape="rect" coords="26,9,112,33" alt="">
<area href="rtai__registry_8h.html" shape="rect" coords="338,84,442,108" alt="">
</map>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga0">rt_send</a> (RT_TASK *task, unsigned int msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message.  <a href="group__msg.html#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga1">rt_send_if</a> (RT_TASK *task, unsigned int msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message, only if the calling task will not be blocked.  <a href="group__msg.html#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga2">rt_send_until</a> (RT_TASK *task, unsigned int msg, RTIME time)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga3">rt_send_timed</a> (RT_TASK *task, unsigned int msg, RTIME delay)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga0">rt_rpc</a> (RT_TASK *task, unsigned int to_do, unsigned int *result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a remote procedure call.  <a href="group__rpc.html#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga1">rt_rpc_if</a> (RT_TASK *task, unsigned int to_do, unsigned int *result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a remote procedure call, only if the calling task will not be blocked.  <a href="group__rpc.html#ga1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga2">rt_rpc_until</a> (RT_TASK *task, unsigned int to_do, unsigned int *result, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a remote procedure call with an absolute timeout.  <a href="group__rpc.html#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga3">rt_rpc_timed</a> (RT_TASK *task, unsigned int to_do, unsigned int *result, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a remote procedure call with a relative timeout.  <a href="group__rpc.html#ga3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga4">rt_isrpc</a> (RT_TASK *task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if sender waits for reply or not.  <a href="group__rpc.html#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga5">rt_return</a> (RT_TASK *task, unsigned int result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return (sends) the result back to the task that made the related remote procedure call.  <a href="group__rpc.html#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga4">rt_evdrp</a> (RT_TASK *task, unsigned int *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Eavedrop (spy) the content of a message.  <a href="group__msg.html#ga4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga5">rt_receive</a> (RT_TASK *task, unsigned int *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message.  <a href="group__msg.html#ga5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga6">rt_receive_if</a> (RT_TASK *task, unsigned int *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message, only if the calling task is not blocked.  <a href="group__msg.html#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga7">rt_receive_until</a> (RT_TASK *task, unsigned int *msg, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message with an absolute timeout.  <a href="group__msg.html#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga8">rt_receive_timed</a> (RT_TASK *task, unsigned int *msg, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message with a relative timeout.  <a href="group__msg.html#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="msg_8c.html#a21">rt_rpcx</a> (RT_TASK *task, void *smsg, void *rmsg, int ssize, int rsize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an extended remote procedure call.  <a href="#a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="msg_8c.html#a22">rt_rpcx_if</a> (RT_TASK *task, void *smsg, void *rmsg, int ssize, int rsize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an extended remote procedure call, only if the calling task will not be blocked.  <a href="#a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga6">rt_rpcx_until</a> (RT_TASK *task, void *smsg, void *rmsg, int ssize, int rsize, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an extended remote procedure call with absolute timeout.  <a href="group__rpc.html#ga6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga7">rt_rpcx_timed</a> (RT_TASK *task, void *smsg, void *rmsg, int ssize, int rsize, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an extended remote procedure call with a relative timeout.  <a href="group__rpc.html#ga7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga9">rt_sendx</a> (RT_TASK *task, void *msg, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send an extended message.  <a href="group__msg.html#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga10">rt_sendx_if</a> (RT_TASK *task, void *msg, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send an extended message, only if the calling task will not be blocked.  <a href="group__msg.html#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga11">rt_sendx_until</a> (RT_TASK *task, void *msg, int size, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send an extended message with absolute timeout.  <a href="group__msg.html#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga12">rt_sendx_timed</a> (RT_TASK *task, void *msg, int size, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send an extended message with relative timeout.  <a href="group__msg.html#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rpc.html#ga8">rt_returnx</a> (RT_TASK *task, void *msg, int size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return (sends) an extended result back to the task that made the related extended remote procedure call.  <a href="group__rpc.html#ga8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga13">rt_evdrpx</a> (RT_TASK *task, void *msg, int size, int *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Eavedrop (spy) the content of an extended message.  <a href="group__msg.html#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga14">rt_receivex</a> (RT_TASK *task, void *msg, int size, int *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive an extended message.  <a href="group__msg.html#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga15">rt_receivex_if</a> (RT_TASK *task, void *msg, int size, int *len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive an extended message, only if the calling task is not blocked.  <a href="group__msg.html#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga16">rt_receivex_until</a> (RT_TASK *task, void *msg, int size, int *len, RTIME time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive an extended message with an absolute timeout.  <a href="group__msg.html#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RT_TASK *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__msg.html#ga17">rt_receivex_timed</a> (RT_TASK *task, void *msg, int size, int *len, RTIME delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive an extended message with a relative timeout.  <a href="group__msg.html#ga17"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a21" doxytag="msg.c::rt_rpcx"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_rpcx           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>smsg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>rmsg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ssize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>rsize</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make an extended remote procedure call. 
<p>
<a class="anchor" name="rt_rpcx"></a> <p>
rt_rpcx makes an extended Remote Procedure Call (RPC). rt_rpcx is used for synchronous inter task messaging. It sends an arbitrary <em>smsg</em> of size <em>ssize</em> bytes to the task <em>task</em> then it always blocks waiting until a message, of size <em>rsize</em> bytes at most, is returned in <em>rmsg</em> from the called task. If the returned message is greater tha rsize it will be truncated. So the caller task is always blocked on the receiver priority queue while the receiver inheredits the blocked sender priority if it is higher (lower in value) than its. The receiver task may get the message with any rt_receivex function. It can send an answer with <a class="el" href="group__rpc.html#rt_returnx">rt_returnx</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>pointer to the RT_TASK structure of the receiver.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smsg</em>&nbsp;</td><td>points to the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rmsg</em>&nbsp;</td><td>points to the message to be returned by the receiver.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssize</em>&nbsp;</td><td>size of the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rsize</em>&nbsp;</td><td>maximum allowed size for the message to be received.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that received the message) is returned. If the message has not been sent (e.g. the task <em>task</em> was killed before receiving the message) 0 is returned.</dd></dl>
See also: rt_receivex_*, <a class="el" href="group__rpc.html#rt_returnx">rt_returnx</a>(), <a class="el" href="group__rpc.html#rt_isrpc">rt_isrpc</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>The trio <a class="el" href="msg_8c.html#rt_rpcx">rt_rpcx</a>(), <a class="el" href="group__msg.html#rt_receivex">rt_receivex</a>(), <a class="el" href="group__rpc.html#rt_returnx">rt_returnx</a>() implements functions similar to its peers send-receive-reply found in QNX. For a even greater compatibility see rt_Send-rt_Receive-rt_Reply. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="msg.c::rt_rpcx_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">RT_TASK* rt_rpcx_if           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">RT_TASK *&nbsp;</td>
          <td class="mdname" nowrap> <em>task</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>smsg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>rmsg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ssize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>rsize</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Make an extended remote procedure call, only if the calling task will not be blocked. 
<p>
<a class="anchor" name="rt_rpcx_if"></a> <p>
rt_rpcx_if tries to make an extended Remote Procedure Call (RPC). If the receiver task is ready to accept a message rt_rpcx_if sends the message as it will be done by rt_rpcx. If the receiver is not ready rt_rpcx_if returns immediately. The receiver task may get the message with any rt_receivex function. It can send the answer with * <a class="el" href="group__rpc.html#rt_returnx">rt_returnx</a>().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>task</em>&nbsp;</td><td>pointer to the RT_TASK structure of the receiver.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smsg</em>&nbsp;</td><td>points to the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rmsg</em>&nbsp;</td><td>points to the message to be returned by the receiver.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssize</em>&nbsp;</td><td>size of the message to be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rsize</em>&nbsp;</td><td>maximum allowed size for the message to be received.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, task (the pointer to the task that received the message) is returned. If message has not been sent, 0 is returned. On other failure, a special value is returned as described below:<ul>
<li><b>0</b>: The task <em>task</em> was not ready to receive the message or it was killed before sending the reply.</li><li><b>0xFFFF</b>: <em>task</em> does not refer to a valid task.</li></ul>
</dd></dl>
See also: notes under <a class="el" href="group__rpc.html#rt_rpc">rt_rpc</a>().<p>
<dl compact><dt><b>Note:</b></dt><dd>Since all the messaging functions return a task address, 0xFFFF could seem an inappropriate return value. However on all the CPUs RTAI runs on, 0xFFFF is not an address that can be used by any RTAI task, so it is should be always safe. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:53 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
