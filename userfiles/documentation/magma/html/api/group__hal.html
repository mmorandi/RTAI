<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: RTAI services functions.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>RTAI services functions.</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This module defines some functions that can be used by RTAI tasks, for managing interrupts and communication services with Linux processes. 
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="i386_2hal_2hal_8c.html">hal.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ARTI -- RTAI-compatible Adeos-based Real-Time Interface. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ppc_2hal_2hal_8c.html">hal.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ARTI -- RTAI-compatible Adeos-based Real-Time Interface. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="asm-i386_2rtai__hal_8h.html">rtai_hal.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ARTI -- RTAI-compatible Adeos-based Real-Time Interface. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="asm-ppc_2rtai__hal_8h.html">rtai_hal.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ARTI -- RTAI-compatible Adeos-based Real-Time Interface. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga74">rt_startup_irq</a> (unsigned irq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">start and initialize the PIC to accept interrupt request irq.  <a href="#ga74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga75">rt_shutdown_irq</a> (unsigned irq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shut down an IRQ source.  <a href="#ga75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga76">rt_enable_irq</a> (unsigned irq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable an IRQ source.  <a href="#ga76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga77">rt_disable_irq</a> (unsigned irq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable an IRQ source.  <a href="#ga77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga78">rt_mask_and_ack_irq</a> (unsigned irq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask and acknowledge and IRQ source.  <a href="#ga78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga79">rt_unmask_irq</a> (unsigned irq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmask and IRQ source.  <a href="#ga79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga80">rt_ack_irq</a> (unsigned irq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acknowledge an IRQ source.  <a href="#ga80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga82">rt_request_linux_irq</a> (unsigned irq, irqreturn_t(*handler)(int irq, void *dev_id, struct pt_regs *regs), char *name, void *dev_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install shared Linux interrupt handler.  <a href="#ga82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga83">rt_free_linux_irq</a> (unsigned irq, void *dev_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uninstall shared Linux interrupt handler.  <a href="#ga83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga84">rt_pend_linux_irq</a> (unsigned irq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pend an IRQ to Linux.  <a href="#ga84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga85">rt_request_srq</a> (unsigned label, void(*k_handler)(void), long long(*u_handler)(unsigned))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install a system request handler.  <a href="#ga85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga86">rt_free_srq</a> (unsigned srq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uninstall a system request handler.  <a href="#ga86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga87">rt_pend_linux_srq</a> (unsigned srq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a Linux IRQ.  <a href="#ga87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga93">rt_request_timer</a> (void(*handler)(void), unsigned tick, int use_apic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install a timer interrupt handler.  <a href="#ga93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga94">rt_free_timer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uninstall a timer interrupt handler.  <a href="#ga94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga172">rt_request_linux_irq</a> (unsigned irq, void(*handler)(int irq, void *dev_id, struct pt_regs *regs), char *name, void *dev_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install shared Linux interrupt handler.  <a href="#ga172"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal.html#ga32">used_apic</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install a timer interrupt handler.  <a href="#ga32"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga80" doxytag="hal.c::rt_ack_irq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_ack_irq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>irq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acknowledge an IRQ source. 
<p>
The related request can then interrupt the CPU again, provided it has not been masked.<p>
The above function allow you to manipulate the PIC at hand, but you must know what you are doing. Such a duty does not pertain to this manual and you should refer to your PIC datasheet.<p>
Note that Linux has the same functions, but they must be used only for its interrupts. Only the above ones can be safely used in real time handlers.<p>
It must also be remarked that when you install a real time interrupt handler, RTAI already calls either rt_mask_and_ack_irq(), for level triggered interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing control to you interrupt handler. hus generally you should just call rt_unmask_irq() at due time, for level triggered interrupts, while nothing should be done for edge triggered ones. Recall that in the latter case you allow also any new interrupts on the same request as soon as you enable interrupts at the CPU level.<p>
Often some of the above functions do equivalent things. Once more there is no way of doing it right except by knowing the hardware you are manipulating. Furthermore you must also remember that when you install a hard real time handler the related interrupt is usually disabled, unless you are overtaking one already owned by Linux which has been enabled by it. Recall that if have done it right, and interrupts do not show up, it is likely you have just to rt_enable_irq() your irq.     </td>
  </tr>
</table>
<a class="anchor" name="ga77" doxytag="hal.c::rt_disable_irq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_disable_irq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>irq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disable an IRQ source. 
<p>
The above function allow you to manipulate the PIC at hand, but you must know what you are doing. Such a duty does not pertain to this manual and you should refer to your PIC datasheet.<p>
Note that Linux has the same functions, but they must be used only for its interrupts. Only the above ones can be safely used in real time handlers.<p>
It must also be remarked that when you install a real time interrupt handler, RTAI already calls either rt_mask_and_ack_irq(), for level triggered interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing control to you interrupt handler. hus generally you should just call rt_unmask_irq() at due time, for level triggered interrupts, while nothing should be done for edge triggered ones. Recall that in the latter case you allow also any new interrupts on the same request as soon as you enable interrupts at the CPU level.<p>
Often some of the above functions do equivalent things. Once more there is no way of doing it right except by knowing the hardware you are manipulating. Furthermore you must also remember that when you install a hard real time handler the related interrupt is usually disabled, unless you are overtaking one already owned by Linux which has been enabled by it. Recall that if have done it right, and interrupts do not show up, it is likely you have just to rt_enable_irq() your irq.     </td>
  </tr>
</table>
<a class="anchor" name="ga76" doxytag="hal.c::rt_enable_irq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_enable_irq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>irq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable an IRQ source. 
<p>
The above function allow you to manipulate the PIC at hand, but you must know what you are doing. Such a duty does not pertain to this manual and you should refer to your PIC datasheet.<p>
Note that Linux has the same functions, but they must be used only for its interrupts. Only the above ones can be safely used in real time handlers.<p>
It must also be remarked that when you install a real time interrupt handler, RTAI already calls either rt_mask_and_ack_irq(), for level triggered interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing control to you interrupt handler. hus generally you should just call rt_unmask_irq() at due time, for level triggered interrupts, while nothing should be done for edge triggered ones. Recall that in the latter case you allow also any new interrupts on the same request as soon as you enable interrupts at the CPU level.<p>
Often some of the above functions do equivalent things. Once more there is no way of doing it right except by knowing the hardware you are manipulating. Furthermore you must also remember that when you install a hard real time handler the related interrupt is usually disabled, unless you are overtaking one already owned by Linux which has been enabled by it. Recall that if have done it right, and interrupts do not show up, it is likely you have just to rt_enable_irq() your irq.     </td>
  </tr>
</table>
<a class="anchor" name="ga83" doxytag="hal.c::rt_free_linux_irq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_free_linux_irq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev_id</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Uninstall shared Linux interrupt handler. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev_id</em>&nbsp;</td><td>is to pass to the interrupt handler, in the same way as the standard Linux irq request call.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>is the IRQ level of the interrupt handler to be freed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EINVAL</em>&nbsp;</td><td>if <em>irq</em> is not a valid IRQ number. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga86" doxytag="hal.c::rt_free_srq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_free_srq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>srq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Uninstall a system request handler. 
<p>
rt_free_srq uninstalls the specified system call <em>srq</em>, returned by installing the related handler with a previous call to rt_request_srq().<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EINVAL</em>&nbsp;</td><td>if <em>srq</em> is invalid. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga94" doxytag="hal.c::rt_free_timer"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_free_timer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Uninstall a timer interrupt handler. 
<p>
rt_free_timer uninstalls a timer previously set by rt_request_timer().     </td>
  </tr>
</table>
<a class="anchor" name="ga78" doxytag="hal.c::rt_mask_and_ack_irq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_mask_and_ack_irq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>irq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Mask and acknowledge and IRQ source. 
<p>
No * other interrupts can be accepted, once also the CPU will enable interrupts, which ones depends on the PIC at hand and on how it is programmed.<p>
The above function allow you to manipulate the PIC at hand, but you must know what you are doing. Such a duty does not pertain to this manual and you should refer to your PIC datasheet.<p>
Note that Linux has the same functions, but they must be used only for its interrupts. Only the above ones can be safely used in real time handlers.<p>
It must also be remarked that when you install a real time interrupt handler, RTAI already calls either rt_mask_and_ack_irq(), for level triggered interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing control to you interrupt handler. hus generally you should just call rt_unmask_irq() at due time, for level triggered interrupts, while nothing should be done for edge triggered ones. Recall that in the latter case you allow also any new interrupts on the same request as soon as you enable interrupts at the CPU level.<p>
Often some of the above functions do equivalent things. Once more there is no way of doing it right except by knowing the hardware you are manipulating. Furthermore you must also remember that when you install a hard real time handler the related interrupt is usually disabled, unless you are overtaking one already owned by Linux which has been enabled by it. Recall that if have done it right, and interrupts do not show up, it is likely you have just to rt_enable_irq() your irq.     </td>
  </tr>
</table>
<a class="anchor" name="ga84" doxytag="hal.c::rt_pend_linux_irq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_pend_linux_irq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>irq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pend an IRQ to Linux. 
<p>
rt_pend_linux_irq appends a Linux interrupt irq for processing in Linux IRQ mode, i.e. with hardware interrupts fully enabled.<p>
<dl compact><dt><b>Note:</b></dt><dd>rt_pend_linux_irq does not perform any check on <em>irq</em>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga87" doxytag="hal.c::rt_pend_linux_srq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_pend_linux_srq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>srq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Append a Linux IRQ. 
<p>
rt_pend_linux_srq appends a system call request srq to be used as a service request to the Linux kernel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>srq</em>&nbsp;</td><td>is the value returned by rt_request_srq.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>rt_pend_linux_srq does not perform any check on irq. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga172" doxytag="hal.c::rt_request_linux_irq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_request_linux_irq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void(*)(int irq, void *dev_id, struct pt_regs *regs)&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev_id</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Install shared Linux interrupt handler. 
<p>
rt_request_linux_irq installs function <em>handler</em> as a standard Linux interrupt service routine for IRQ level <em>irq</em> forcing Linux to share the IRQ with other interrupt handlers, even if it does not want. The handler is appended to any already existing Linux handler for the same irq and is run by Linux irq as any of its handler. In this way a real time application can monitor Linux interrupts handling at its will. The handler appears in /proc/interrupts.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>pointer on the interrupt service routine to be installed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is a name for /proc/interrupts.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dev_id</em>&nbsp;</td><td>is to pass to the interrupt handler, in the same way as the standard Linux irq request call.</td></tr>
  </table>
</dl>
The interrupt service routine can be uninstalled with rt_free_linux_irq().<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EINVAL</em>&nbsp;</td><td>if <em>irq</em> is not a valid IRQ number or handler is <code>NULL</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EBUSY</em>&nbsp;</td><td>if there is already a handler of interrupt <em>irq</em>. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga82" doxytag="hal.c::rt_request_linux_irq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_request_linux_irq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>irq</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>irqreturn_t(*)(int irq, void *dev_id, struct pt_regs *regs)&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev_id</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Install shared Linux interrupt handler. 
<p>
rt_request_linux_irq installs function <em>handler</em> as a standard Linux interrupt service routine for IRQ level <em>irq</em> forcing Linux to share the IRQ with other interrupt handlers, even if it does not want. The handler is appended to any already existing Linux handler for the same irq and is run by Linux irq as any of its handler. In this way a real time application can monitor Linux interrupts handling at its will. The handler appears in /proc/interrupts.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>pointer on the interrupt service routine to be installed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is a name for /proc/interrupts.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dev_id</em>&nbsp;</td><td>is to pass to the interrupt handler, in the same way as the standard Linux irq request call.</td></tr>
  </table>
</dl>
The interrupt service routine can be uninstalled with rt_free_linux_irq().<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EINVAL</em>&nbsp;</td><td>if <em>irq</em> is not a valid IRQ number or handler is <code>NULL</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EBUSY</em>&nbsp;</td><td>if there is already a handler of interrupt <em>irq</em>. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga85" doxytag="hal.c::rt_request_srq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_request_srq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>label</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void(*)(void)&nbsp;</td>
          <td class="mdname" nowrap> <em>k_handler</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>long long(*)(unsigned)&nbsp;</td>
          <td class="mdname" nowrap> <em>u_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Install a system request handler. 
<p>
rt_request_srq installs a two way RTAI system request (srq) by assigning <em>u_handler</em>, a function to be used when a user calls srq from user space, and <em>k_handler</em>, the function to be called in kernel space following its activation by a call to rt_pend_linux_srq(). <em>k_handler</em> is in practice used to request a service from the kernel. In fact Linux system requests cannot be used safely from RTAI so you can setup a handler that receives real time requests and safely executes them when Linux is running.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u_handler</em>&nbsp;</td><td>can be used to effectively enter kernel space without the overhead and clumsiness of standard Unix/Linux protocols. This is very flexible service that allows you to personalize your use of RTAI.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of the assigned system request on success. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>EINVAL</em>&nbsp;</td><td>if <em>k_handler</em> is <code>NULL</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EBUSY</em>&nbsp;</td><td>if no free srq slot is available. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga93" doxytag="hal.c::rt_request_timer"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_request_timer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void(*)(void)&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>tick</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>use_apic</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Install a timer interrupt handler. 
<p>
rt_request_timer requests a timer of period tick ticks, and installs the routine <em>handler</em> as a real time interrupt service routine for the timer.<p>
Set <em>tick</em> to 0 for oneshot mode (in oneshot mode it is not used). If <em>apic</em> has a nonzero value the local APIC timer is used. Otherwise timing is based on the 8254.     </td>
  </tr>
</table>
<a class="anchor" name="ga75" doxytag="hal.c::rt_shutdown_irq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_shutdown_irq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>irq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Shut down an IRQ source. 
<p>
No further interrupt request irq can be accepted.<p>
The above function allow you to manipulate the PIC at hand, but you must know what you are doing. Such a duty does not pertain to this manual and you should refer to your PIC datasheet.<p>
Note that Linux has the same functions, but they must be used only for its interrupts. Only the above ones can be safely used in real time handlers.<p>
It must also be remarked that when you install a real time interrupt handler, RTAI already calls either rt_mask_and_ack_irq(), for level triggered interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing control to you interrupt handler. hus generally you should just call rt_unmask_irq() at due time, for level triggered interrupts, while nothing should be done for edge triggered ones. Recall that in the latter case you allow also any new interrupts on the same request as soon as you enable interrupts at the CPU level.<p>
Often some of the above functions do equivalent things. Once more there is no way of doing it right except by knowing the hardware you are manipulating. Furthermore you must also remember that when you install a hard real time handler the related interrupt is usually disabled, unless you are overtaking one already owned by Linux which has been enabled by it. Recall that if have done it right, and interrupts do not show up, it is likely you have just to rt_enable_irq() your irq.     </td>
  </tr>
</table>
<a class="anchor" name="ga74" doxytag="hal.c::rt_startup_irq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned rt_startup_irq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>irq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
start and initialize the PIC to accept interrupt request irq. 
<p>
The above function allow you to manipulate the PIC at hand, but you must know what you are doing. Such a duty does not pertain to this manual and you should refer to your PIC datasheet.<p>
Note that Linux has the same functions, but they must be used only for its interrupts. Only the above ones can be safely used in real time handlers.<p>
It must also be remarked that when you install a real time interrupt handler, RTAI already calls either rt_mask_and_ack_irq(), for level triggered interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing control to you interrupt handler. hus generally you should just call rt_unmask_irq() at due time, for level triggered interrupts, while nothing should be done for edge triggered ones. Recall that in the latter case you allow also any new interrupts on the same request as soon as you enable interrupts at the CPU level.<p>
Often some of the above functions do equivalent things. Once more there is no way of doing it right except by knowing the hardware you are manipulating. Furthermore you must also remember that when you install a hard real time handler the related interrupt is usually disabled, unless you are overtaking one already owned by Linux which has been enabled by it. Recall that if have done it right, and interrupts do not show up, it is likely you have just to rt_enable_irq() your irq.     </td>
  </tr>
</table>
<a class="anchor" name="ga79" doxytag="hal.c::rt_unmask_irq"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_unmask_irq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>irq</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unmask and IRQ source. 
<p>
The related request can then interrupt the CPU again, provided it has also been acknowledged.<p>
The above function allow you to manipulate the PIC at hand, but you must know what you are doing. Such a duty does not pertain to this manual and you should refer to your PIC datasheet.<p>
Note that Linux has the same functions, but they must be used only for its interrupts. Only the above ones can be safely used in real time handlers.<p>
It must also be remarked that when you install a real time interrupt handler, RTAI already calls either rt_mask_and_ack_irq(), for level triggered interrupts, or rt_ack_irq(), for edge triggered interrupts, before passing control to you interrupt handler. hus generally you should just call rt_unmask_irq() at due time, for level triggered interrupts, while nothing should be done for edge triggered ones. Recall that in the latter case you allow also any new interrupts on the same request as soon as you enable interrupts at the CPU level.<p>
Often some of the above functions do equivalent things. Once more there is no way of doing it right except by knowing the hardware you are manipulating. Furthermore you must also remember that when you install a hard real time handler the related interrupt is usually disabled, unless you are overtaking one already owned by Linux which has been enabled by it. Recall that if have done it right, and interrupts do not show up, it is likely you have just to rt_enable_irq() your irq.     </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="ga32" doxytag="hal.c::used_apic"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int unsigned long <a class="el" href="group__hal.html#ga32">used_apic</a><code> [static]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Install a timer interrupt handler. 
<p>
rt_request_timer requests a timer of period tick ticks, and installs the routine <em>handler</em> as a real time interrupt service routine for the timer.<p>
Set <em>tick</em> to 0 for oneshot mode (in oneshot mode it is not used). If <em>apic</em> has a nonzero value the local APIC timer is used. Otherwise timing is based on the 8254.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:53 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
