<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTAI API: A general overview of RTAI fifos.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RTAI API<span id="projectnumber">&#160;5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('fifos_overview.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">A general overview of RTAI fifos. </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >The new fifo implementation for RTAI maintains full compatibility with the basic services provided by its original NMT-RTL counterpart while adding many more.</p>
<p >It is important to remark that even if RTAI fifo APIs appears as before the implementation behind them is based on the mailbox concepts, already available in RTAI and symmetrically usable from kernel modules and Linux processes. The only notable difference, apart from the file style API functions to be used in Linux processes, is that on the module side you always have only non blocking put/get, so that any different policy should be enforced by using appropriate user handler functions.</p>
<p >With regard to fifo handlers it is now possible to install also one with a read/write argument (read <code>'r'</code> , write <code>'w'</code> ). In this way you have a handler that can know what it has been called for. It is useful when you open read-write fifos or to check against miscalls.</p>
<p >For that you can have a handler prototyped as: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> x_handler(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fifo, <span class="keywordtype">int</span> rw);</div>
</div><!-- fragment --><p >that can be installed by using: </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__fifos__ipc.html#ga23f3d01684830922905ee388e44b05c2">rtf_create_handler</a>(fifo_numver, X_FIFO_HANDLER(x_handler));</div>
<div class="ttc" id="agroup__fifos__ipc_html_ga23f3d01684830922905ee388e44b05c2"><div class="ttname"><a href="group__fifos__ipc.html#ga23f3d01684830922905ee388e44b05c2">rtf_create_handler</a></div><div class="ttdeci">int rtf_create_handler(unsigned int minor, void *handler)</div><div class="ttdoc">Install a FIFO handler function.</div><div class="ttdef"><b>Definition:</b> fifos.c:1086</div></div>
</div><!-- fragment --><p >see <a class="el" href="rtai__fifos_8h.html" title="Interface of the RTAI FIFO module.">rtai_fifos.h</a> for the #X_FIFO_HANDLER macro definition. The handler code is likely to be a kind of: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> x_handler(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fifo, <span class="keywordtype">int</span> rw);</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (rw == <span class="charliteral">&#39;r&#39;</span>) {</div>
<div class="line">        <span class="comment">// do stuff for a call from read and return appropriate value.</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// do stuff for a call from write and return appropriate value.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >Even if fifos are strictly no more required in RTAI, because of the symmetric inter/intra kernel/user space support, they are kept both for compatibility reasons and because they are very useful tools to be used to communicate with interrupt handlers, since they do not require any scheduler to be installed. Notice that for such applications RTAI has now shared memory circular buffers (SCB) that might be even more effective to exchange data to/from interrupt handlers. In this sense you can see this new implementation of fifos as a kind of universal form of device drivers, since once you have your interrupt handler installed you can use fifo services to do all the rest.</p>
<p >However the new implementation made it easy to add some new services. One of these is the possibility of using asyncronous signals to notify data availability by catching a user set signal. It is implemented in a standard way, see the function: </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__fifos__ipc.html#gafa9c209b9864c9db9d3bdf2b6b5d1432">rtf_set_async_sig</a>(<span class="keywordtype">int</span> fd, <span class="keywordtype">int</span> signum) (<span class="keywordflow">default</span> signum is SIGIO);</div>
<div class="ttc" id="agroup__fifos__ipc_html_gafa9c209b9864c9db9d3bdf2b6b5d1432"><div class="ttname"><a href="group__fifos__ipc.html#gafa9c209b9864c9db9d3bdf2b6b5d1432">rtf_set_async_sig</a></div><div class="ttdeci">int rtf_set_async_sig(int fd, int signum)</div><div class="ttdoc">Activate asynchronous notification of data availability.</div><div class="ttdef"><b>Definition:</b> rtai_fifos.h:723</div></div>
</div><!-- fragment --><p >and standard Linux man for fcntl and signal/sigaction, while the others are specific to this implementation.</p>
<p >A complete picture of what is available can be obtained from a look at <a class="el" href="rtai__fifos_8h.html" title="Interface of the RTAI FIFO module.">rtai_fifos.h</a> prototypes.</p>
<p >It is important to remark that now fifos allows multiple readers/writers so the select/poll mechanism to synchronize with in/out data can lead to unexpected blocks for such cases. For example: you poll and get that there are data available, then read/write them sure not to be blocked, meanwhile another user gets into and stoles all of your data, when you ask for them you get blocked.</p>
<p >To avoid such problems you have available the functions:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__fifos__ipc.html#gab06376e644144962402ece7f9af0568e">rtf_read_all_at_once</a>(fd, buf, count);</div>
<div class="ttc" id="agroup__fifos__ipc_html_gab06376e644144962402ece7f9af0568e"><div class="ttname"><a href="group__fifos__ipc.html#gab06376e644144962402ece7f9af0568e">rtf_read_all_at_once</a></div><div class="ttdeci">int rtf_read_all_at_once(int fd, void *buf, int count)</div><div class="ttdoc">Read data from FIFO in user space, waiting for all of them.</div><div class="ttdef"><b>Definition:</b> rtai_fifos.h:544</div></div>
</div><!-- fragment --><p >that blocks till all count bytes are available;</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__fifos__ipc.html#gab37b66f1046fbb1abe75ac9356d8c159">rtf_read_timed</a>(fd, buf, count, ms_delay);</div>
<div class="line">        </div>
<div class="line"><a class="code hl_function" href="group__fifos__ipc.html#ga9b659378d41e0eb36d9ffcd394b6b567">rtf_write_timed</a>(fd, buf, count, ms_delay);</div>
<div class="ttc" id="agroup__fifos__ipc_html_ga9b659378d41e0eb36d9ffcd394b6b567"><div class="ttname"><a href="group__fifos__ipc.html#ga9b659378d41e0eb36d9ffcd394b6b567">rtf_write_timed</a></div><div class="ttdeci">int rtf_write_timed(int fd, void *buf, int count, int ms_delay)</div><div class="ttdoc">Write data to FIFO in user space, with timeout.</div><div class="ttdef"><b>Definition:</b> rtai_fifos.h:607</div></div>
<div class="ttc" id="agroup__fifos__ipc_html_gab37b66f1046fbb1abe75ac9356d8c159"><div class="ttname"><a href="group__fifos__ipc.html#gab37b66f1046fbb1abe75ac9356d8c159">rtf_read_timed</a></div><div class="ttdeci">int rtf_read_timed(int fd, void *buf, int count, int ms_delay)</div><div class="ttdoc">Read data from FIFO in user space, with timeout.</div><div class="ttdef"><b>Definition:</b> rtai_fifos.h:572</div></div>
</div><!-- fragment --><p >that block just for the specified delay in milliseconds but are queued in real time Linux process priority order. If <em>ms_delay</em> is zero they return immediately with all the data they could get, even if you did not set <code>O_NONBLOCK</code> at fifo opening.</p>
<p >So by mixing normal read/writes with their friends above you can easily implement blocking, non blocking and timed IOs. They are not standard and so not portable, but far easy to use then the select/poll mechanism. The standard llseek is also available but it is equivalent to calling rtf_reset, whatever fifo place you point at in the call.</p>
<p >For an easier timing you have available also: </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__fifos__ipc.html#ga685141f8373367d50f691439a650b79b">rtf_suspend_timed</a>(fd, ms_delay).</div>
<div class="ttc" id="agroup__fifos__ipc_html_ga685141f8373367d50f691439a650b79b"><div class="ttname"><a href="group__fifos__ipc.html#ga685141f8373367d50f691439a650b79b">rtf_suspend_timed</a></div><div class="ttdeci">int rtf_suspend_timed(int fd, int ms_delay)</div><div class="ttdoc">Suspend a process for some time.</div><div class="ttdef"><b>Definition:</b> rtai_fifos.h:467</div></div>
</div><!-- fragment --><p >To make them easier to use, fifos can now be created by the user at open time. If a fifo that does not exist already is opened, it is created with a 1K buffer. Any following creation on modules side resizes it without any loss of data. Again if you want to create a fifo from the user side with a desired buffer size you can use: </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__fifos__ipc.html#gacd65539dc2663b89e9b3e9094c83a390">rtf_open_sized</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *dev, perm, size).</div>
<div class="ttc" id="agroup__fifos__ipc_html_gacd65539dc2663b89e9b3e9094c83a390"><div class="ttname"><a href="group__fifos__ipc.html#gacd65539dc2663b89e9b3e9094c83a390">rtf_open_sized</a></div><div class="ttdeci">int rtf_open_sized(const char *dev, int perm, int size)</div><div class="ttdoc">Create a real-time FIFO.</div><div class="ttdef"><b>Definition:</b> rtai_fifos.h:507</div></div>
</div><!-- fragment --><p >Since they had to be there already to implement our mailboxes we have made available also binary semaphores. They can be used for many things, e.g. to synchronize shared memory access without any scheduler installed and in place of using blocking fifos read/writes with dummy data, just to synchronize. The semaphore services available are: </p><div class="fragment"><div class="line">rtf_sem_init(fd, init_val);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__fifos__sem.html#gab1d77341ac9b787584ac9af25dbe58fd">rtf_sem_wait</a>(fd);</div>
<div class="line"> </div>
<div class="line">rtf_sem_trywait(fd);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__fifos__sem.html#ga59942c0cade5055a42986d5d442ebde9">rtf_sem_timed_wait</a>(fd, ms_delay);</div>
<div class="line"> </div>
<div class="line">rtf_sem_post(fd);</div>
<div class="line"> </div>
<div class="line">rtf_sem_destroy(fd);</div>
<div class="ttc" id="agroup__fifos__sem_html_ga59942c0cade5055a42986d5d442ebde9"><div class="ttname"><a href="group__fifos__sem.html#ga59942c0cade5055a42986d5d442ebde9">rtf_sem_timed_wait</a></div><div class="ttdeci">int rtf_sem_timed_wait(int fd, int ms_delay)</div><div class="ttdoc">Wait a semaphore with timeout.</div><div class="ttdef"><b>Definition:</b> rtai_fifos.h:694</div></div>
<div class="ttc" id="agroup__fifos__sem_html_gab1d77341ac9b787584ac9af25dbe58fd"><div class="ttname"><a href="group__fifos__sem.html#gab1d77341ac9b787584ac9af25dbe58fd">rtf_sem_wait</a></div><div class="ttdeci">int rtf_sem_wait(int fd)</div><div class="ttdoc">Take a semaphore.</div><div class="ttdef"><b>Definition:</b> rtai_fifos.h:656</div></div>
</div><!-- fragment --><p >Note that <em>fd</em> is the file descriptor, a semaphore is always associated to a fifo and you must get a file descriptor by opening the corresponding fifo.</p>
<p >Naturally the above functions are symmetrically available in kernel space but, except for init and create, only for the nonblocking services, i.e: trywait and post. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
