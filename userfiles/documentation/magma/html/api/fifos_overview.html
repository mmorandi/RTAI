<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: A general overview of RTAI fifos.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1><a class="anchor" name="fifos_overview">A general overview of RTAI fifos.</a></h1>The new fifo implementation for RTAI maintains full compatibility with the basic services provided by its original NMT-RTL counterpart while adding many more.<p>
It is important to remark that even if RTAI fifo APIs appears as before the implementation behind them is based on the mailbox concepts, already available in RTAI and symmetrically usable from kernel modules and Linux processes. The only notable difference, apart from the file style API functions to be used in Linux processes, is that on the module side you always have only non blocking put/get, so that any different policy should be enforced by using appropriate user handler functions.<p>
With regard to fifo handlers it is now possible to install also one with a read/write argument (read <code>'r'</code> , write <code>'w'</code> ). In this way you have a handler that can know what it has been called for. It is useful when you open read-write fifos or to check against miscalls.<p>
For that you can have a handler prototyped as: <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> x_handler(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fifo, <span class="keywordtype">int</span> rw);
</pre></div><p>
that can be installed by using: <div class="fragment"><pre class="fragment"><a class="code" href="group__fifos__ipc.html#ga10">rtf_create_handler</a>(fifo_numver, X_FIFO_HANDLER(x_handler));
</pre></div><p>
see <a class="el" href="rtai__fifos_8h.html">rtai_fifos.h</a> for the #X_FIFO_HANDLER macro definition. The handler code is likely to be a kind of: <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> x_handler(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fifo, <span class="keywordtype">int</span> rw);
{
    <span class="keywordflow">if</span> (rw == <span class="charliteral">'r'</span>) {
        <span class="comment">// do stuff for a call from read and return appropriate value.</span>
    } <span class="keywordflow">else</span> {
        <span class="comment">// do stuff for a call from write and return appropriate value.</span>
    }
}
</pre></div><p>
Even if fifos are strictly no more required in RTAI, because of the availability of LXRT and LXRT-INFORMED, they are kept both for compatibility reasons and because they are very useful tools to be used to communicate with interrupt handlers, since they do not require any scheduler to be installed. In this sense you can see this new implementation of fifos as a kind of universal form of device drivers, since once you have your interrupt handler installed you can use fifo services to do all the rest.<p>
However the new implementation made it easy to add some new services. One of these is the possibility of using asyncronous signals to notify data availability by catching a user set signal. It is implemented in a standard way, see the function: <div class="fragment"><pre class="fragment"><a class="code" href="group__fifos__ipc.html#ga5">rtf_set_async_sig</a>(<span class="keywordtype">int</span> fd, <span class="keywordtype">int</span> signum) (<span class="keywordflow">default</span> signum is SIGIO);
</pre></div><p>
and standard Linux man for fcntl and signal/sigaction, while the others are specific to this implementation.<p>
A complete picture of what is available can be obtained from a look at <a class="el" href="rtai__fifos_8h.html">rtai_fifos.h</a> prototypes.<p>
It is important to remark that now fifos allows multiple readers/writers so the select/poll mechanism to synchronize with in/out data can lead to unexpected blocks for such cases. For example: you poll and get that there are data available, then read/write them sure not to be blocked, meanwhile another user gets into and stoles all of your data, when you ask for them you get blocked.<p>
To avoid such problems you have available the functions:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__fifos__ipc.html#ga2">rtf_read_all_at_once</a>(fd, buf, count);
</pre></div><p>
that blocks till all count bytes are available;<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__fifos__ipc.html#ga3">rtf_read_timed</a>(fd, buf, count, ms_delay);
        
<a class="code" href="group__fifos__ipc.html#ga4">rtf_write_timed</a>(fd, buf, count, ms_delay);
</pre></div><p>
that block just for the specified delay in milliseconds but are queued in real time Linux process priority order. If <em>ms_delay</em> is zero they return immediately with all the data they could get, even if you did not set <code>O_NONBLOCK</code> at fifo opening.<p>
So by mixing normal read/writes with their friends above you can easily implement blocking, non blocking and timed IOs. They are not standard and so not portable, but far easy to use then the select/poll mechanism. The standard llseek is also available but it is equivalent to calling rtf_reset, whatever fifo place you point at in the call.<p>
For an easier timing you have available also: <div class="fragment"><pre class="fragment"><a class="code" href="group__fifos__ipc.html#ga0">rtf_suspend_timed</a>(fd, ms_delay).
</pre></div><p>
To make them easier to use, fifos can now be created by the user at open time. If a fifo that does not exist already is opened, it is created with a 1K buffer. Any following creation on modules side resizes it without any loss of data. Again if you want to create a fifo from the user side with a desired buffer size you can use: <div class="fragment"><pre class="fragment"><a class="code" href="group__fifos__ipc.html#ga1">rtf_open_sized</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *dev, perm, size).
</pre></div><p>
Since they had to be there already to implement our mailboxes we have made available also binary semaphores. They can be used for many things, e.g. to synchronize shared memory access without any scheduler installed and in place of using blocking fifos read/writes with dummy data, just to synchronize. The semaphore services available are: <div class="fragment"><pre class="fragment"><a class="code" href="group__fifos__sem.html#ga2">rtf_sem_init</a>(fd, init_val);

<a class="code" href="group__fifos__sem.html#ga0">rtf_sem_wait</a>(fd);

<a class="code" href="group__fifos__sem.html#ga4">rtf_sem_trywait</a>(fd);

<a class="code" href="group__fifos__sem.html#ga1">rtf_sem_timed_wait</a>(fd, ms_delay);

<a class="code" href="group__fifos__sem.html#ga3">rtf_sem_post</a>(fd);

<a class="code" href="group__fifos__sem.html#ga5">rtf_sem_destroy</a>(fd);
</pre></div><p>
Note that <em>fd</em> is the file descriptor, a semaphore is always associated to a fifo and you must get a file descriptor by opening the corresponding fifo.<p>
Naturally the above functions are symmetrically available in kernel space but, except for init and create, only for the nonblocking services, i.e: trywait and post. <hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:53 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
