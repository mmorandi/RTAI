<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: mini RTAI LXRT tasklets module</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>mini RTAI LXRT tasklets module</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
The MINI_RTAI_LXRT tasklets module adds an interesting new feature along the line, pioneered by RTAI, of a symmetric usage of all its services inter-intra kernel and user space, both for soft and hard real time applications. 
<p>
In such a way you have opened a whole spectrum of development and implementation lanes, allowing maximum flexibility with uncompromized performances.<p>
The new services provided can be useful when you have many tasks, both in kernel and user space, that must execute in soft/hard real time but do not need any RTAI scheduler service that could lead to a task block. Such tasks are here called tasklets and can be of two kinds: normal tasklets and timed tasklets (timers).<p>
It must be noted that only timers should need to be made available both in user and kernel space. In fact normal tasklets in kernel space are nothing but standard functions that can be directly executed by calling them, so there would be no need for any special treatment. However to maintain full usage symmetry, and to ease any possible porting from one address space to the other, also normal tasklet functions can be used in whatever address space.<p>
Note that if, at this point, you are reminded to similar Linux kernel services you are not totally wrong. They are not exactly the same, because of their symmetric availability in kernel and user space, but the basic idea behind them is clearly fairly similar.<p>
Tasklets should be used whenever the standard hard real time tasks available with RTAI and LXRT schedulers can be a waist of resources and the execution of simple, possibly timed, functions could often be more than enough. Instances of such applications are timed polling and simple Programmable Logic Controllers (PLC) like sequences of services. Obviously there are many others instances that can make it sufficient the use of tasklets, either normal or timers. In general such an approach can be a very useful complement to fully featured tasks in controlling complex machines and systems, both for basic and support services.<p>
It is remarked that the implementation found here for timed tasklets rely on a server support task that executes the related timer functions, either in oneshot or periodic mode, on the base of their time deadline and according to their, user assigned, priority. Instead, as told above, plain tasklets are just functions executed from kernel space; their execution needs no server and is simply triggered by calling a given service function at due time, either from a kernel task or interrupt handler requiring, or in charge of, their execution when they are needed. Once more it is important to recall that all non blocking RTAI scheduler services can be used in any tasklet function. Blocking services must absolutely be avoided. They will deadlock the timers server task, executing task or interrupt handler, whichever applies, so that no more tasklet functions will be executed.<p>
User and kernel space MINI_RTAI_LXRT applications can cooperate and synchronize by using shared memory. It has been called MINI_RTAI_LXRT because it is a kind of light soft/hard real time server that can partially substitute RTAI and LXRT in simple applications, i.e. if the constraints hinted above are wholly satisfied. So MINI_RTAI_LXRT can be used in kernel and user space, with any RTAI scheduler. Its implementations has been very easy, as it is nothing but what its name implies. LXRT made all the needed tools already available. In fact it duplicates a lot of LXRT so that its final production version will be fully integrated with it, ASAP. However, at the moment, it cannot work with LXRT yet.<p>
Note that in user space you run within the memory of the process owning the tasklet function so you MUST lock all of your processes memory in core, by using mlockall, to prevent it being swapped out. Also abundantly pre grow your stack to the largest size needed during the execution of your application, see mlockall usage in Linux manuals.<p>
The RTAI distribution contains many useful examples that demonstrate the use of most services, both in kernel and user space. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__nam2num_8h.html">rtai_nam2num.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion between characters strings and unsigned long identifiers. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__tasklets_8h.html">rtai_tasklets.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface of the <a class="el" href="group__tasklets.html">mini LXRT RTAI tasklets module</a>. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tasklets_8c.html">tasklets.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the <a class="el" href="group__tasklets.html">mini LXRT RTAI tasklets module</a>. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">rt_tasklet_struct *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga9">rt_init_tasklet</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Init, in kernel space, a tasklet structure to be used in user space.  <a href="#ga9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga10">rt_delete_tasklet</a> (struct rt_tasklet_struct *tasklet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete, in kernel space, a tasklet structure to be used in user space.  <a href="#ga10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga11">rt_insert_timer</a> (struct rt_tasklet_struct *timer, int priority, RTIME firing_time, RTIME period, void(*handler)(unsigned long), unsigned long data, int pid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a timer in the list of timers to be processed.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga12">rt_remove_timer</a> (struct rt_tasklet_struct *timer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a timer in the list of timers to be processed.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga13">rt_set_timer_priority</a> (struct rt_tasklet_struct *timer, int priority)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the priority of an existing timer.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga14">rt_set_timer_firing_time</a> (struct rt_tasklet_struct *timer, RTIME firing_time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the firing time of a timer.  <a href="#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga15">rt_set_timer_period</a> (struct rt_tasklet_struct *timer, RTIME period)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the period of a timer.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga19">rt_insert_tasklet</a> (struct rt_tasklet_struct *tasklet, int priority, void(*handler)(unsigned long), unsigned long data, unsigned long id, int pid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a tasklet in the list of tasklets to be processed.  <a href="#ga19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga21">rt_remove_tasklet</a> (struct rt_tasklet_struct *tasklet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a tasklet in the list of tasklets to be processed.  <a href="#ga21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga22">rt_exec_tasklet</a> (struct rt_tasklet_struct *tasklet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exec a tasklet.  <a href="#ga22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">rt_tasklet_struct *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tasklets.html#ga25">rt_find_tasklet_by_id</a> (unsigned long id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find a tasklet identified by its id.  <a href="#ga25"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga10" doxytag="rtai_tasklets.h::rt_delete_tasklet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_delete_tasklet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct rt_tasklet_struct *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tasklet</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete, in kernel space, a tasklet structure to be used in user space. 
<p>
rt_tasklet_delete free a tasklet structure (struct rt_tasklet_struct) in kernel space that was allocated by rt_tasklet_init.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tasklet</em>&nbsp;</td><td>is the pointer to the tasklet structure (struct rt_tasklet_struct) returned by rt_tasklet_init.</td></tr>
  </table>
</dl>
This function is to be used only for user space tasklets. In kernel space it is just an empty macro, as the user can, and must allocate the related structure directly, either statically or dynamically.<p>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga22" doxytag="rtai_tasklets.h::rt_exec_tasklet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_exec_tasklet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct rt_tasklet_struct *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tasklet</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Exec a tasklet. 
<p>
rt_exec_tasklet execute a tasklet from the list of tasklets to be processed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tasklet</em>&nbsp;</td><td>is the pointer to the tasklet structure to be used to manage the tasklet <em>tasklet</em>.</td></tr>
  </table>
</dl>
Kernel space tasklets addresses are usually available directly and can be easily be used in calling rt_tasklet_exec. In fact one can call the related handler directly without using such a support function, which is mainly supplied for symmetry and to ease the porting of applications from one space to the other.<p>
User space tasklets instead must be first found within the tasklet list by calling <a class="el" href="group__tasklets.html#ga25">rt_find_tasklet_by_id()</a> to get the tasklet address to be used in rt_tasklet_exec().<p>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga25" doxytag="tasklets.c::rt_find_tasklet_by_id"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">struct rt_tasklet_struct* rt_find_tasklet_by_id           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find a tasklet identified by its id. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>is the unique unsigned long to be used to identify the tasklet.</td></tr>
  </table>
</dl>
The support functions <a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a> can be used for setting up id from a six character string.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the pointer to a tasklet handler on success </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>to indicate that <em>id</em> is not a valid identifier so that the related tasklet was not found.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="rtai_tasklets.h::rt_init_tasklet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">struct rt_tasklet_struct * rt_init_tasklet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Init, in kernel space, a tasklet structure to be used in user space. 
<p>
rt_tasklet_init allocate a tasklet structure (struct rt_tasklet_struct) in kernel space to be used for the management of a user space tasklet.<p>
This function is to be used only for user space tasklets. In kernel space it is just an empty macro, as the user can, and must allocate the related structure directly, either statically or dynamically.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the pointer to the tasklet structure the user space application must use to access all its related services. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga19" doxytag="rtai_tasklets.h::rt_insert_tasklet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_insert_tasklet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct rt_tasklet_struct *&nbsp;</td>
          <td class="mdname" nowrap> <em>tasklet</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void(*)(unsigned long)&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>pid</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a tasklet in the list of tasklets to be processed. 
<p>
rt_insert_tasklet insert a tasklet in the list of tasklets to be processed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tasklet</em>&nbsp;</td><td>is the pointer to the tasklet structure to be used to manage the tasklet at hand.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>is the tasklet function to be executed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>is an unsigned long to be passed to the handler. Clearly by an appropriate type casting one can pass a pointer to whatever data structure and type is needed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>is a unique unsigned number to be used to identify the tasklet tasklet. It is typically required by the kernel space service, interrupt handler ot task, in charge of executing a user space tasklet. The support functions <a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a> can be used for setting up id from a six character string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>is an integer that marks a tasklet either as being a kernel or user space one. Despite its name you need not to know the pid of the tasklet parent process in user space. Simple use 0 for kernel space and 1 for user space.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a negative number to indicate that an invalid handler address has been passed.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="rtai_tasklets.h::rt_insert_timer"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_insert_timer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct rt_tasklet_struct *&nbsp;</td>
          <td class="mdname" nowrap> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>firing_time</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>period</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void(*)(unsigned long)&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>pid</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a timer in the list of timers to be processed. 
<p>
rt_insert_timer insert a timer in the list of timers to be processed. Timers can be either periodic or oneshot. A periodic timer is reloaded at each expiration so that it executes with the assigned periodicity. A oneshot timer is fired just once and then removed from the timers list. Timers can be reinserted or modified within their handlers functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>is the pointer to the timer structure to be used to manage the timer at hand.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>is the priority to be used to execute timers handlers when more than one timer has to be fired at the same time.It can be assigned any value such that: 0 &lt; priority &lt; RT_LOWEST_PRIORITY.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>firing_time</em>&nbsp;</td><td>is the time of the first timer expiration.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>period</em>&nbsp;</td><td>is the period of a periodic timer. A periodic timer keeps calling its handler at firing_time + k*period k = 0, 1. To define a oneshot timer simply use a null period.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>is the timer function to be executed at each timer expiration.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>is an unsigned long to be passed to the handler. Clearly by a appropriate type casting one can pass a pointer to whatever data structure and type is needed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>is an integer that marks a timer either as being a kernel or user space one. Despite its name you need not to know the pid of the timer parent process in user space. Simple use 0 for kernel space and 1 for user space.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EINVAL</em>&nbsp;</td><td>if <em>handler</em> is an invalid handler address</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga21" doxytag="rtai_tasklets.h::rt_remove_tasklet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_remove_tasklet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct rt_tasklet_struct *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tasklet</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a tasklet in the list of tasklets to be processed. 
<p>
rt_remove_tasklet remove a tasklet from the list of tasklets to be processed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tasklet</em>&nbsp;</td><td>is the pointer to the tasklet structure to be used to manage the tasklet at hand.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="rtai_tasklets.h::rt_remove_timer"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_remove_timer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct rt_tasklet_struct *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>timer</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove a timer in the list of timers to be processed. 
<p>
rt_remove_timer remove a timer from the list of the timers to be processed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>is the pointer to the timer structure to be used to manage the timer at hand.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="rtai_tasklets.h::rt_set_timer_firing_time"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_set_timer_firing_time           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct rt_tasklet_struct *&nbsp;</td>
          <td class="mdname" nowrap> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>firing_time</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the firing time of a timer. 
<p>
rt_set_timer_firing_time changes the firing time of a periodic timer overloading any existing value, so that the timer next shoot will take place at the new firing time. Note that if a oneshot timer has its firing time changed after it has already expired this function has no effect. You should reinsert it in the timer list with the new firing time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>is the pointer to the timer structure to be used to manage the timer at hand.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>firing_time</em>&nbsp;</td><td>is the new time of the first timer expiration.</td></tr>
  </table>
</dl>
This function can be used within the timer handler.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="rtai_tasklets.h::rt_set_timer_period"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_set_timer_period           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct rt_tasklet_struct *&nbsp;</td>
          <td class="mdname" nowrap> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>RTIME&nbsp;</td>
          <td class="mdname" nowrap> <em>period</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the period of a timer. 
<p>
rt_set_timer_period changes the period of a periodic timer. Note that the new period will be used to pace the timer only after the expiration of the firing time already in place. Using this function with a period different from zero for a oneshot timer, that has not expired yet, will transform it into a periodic timer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>is the pointer to the timer structure to be used to manage the timer at hand.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>period</em>&nbsp;</td><td>is the new period of a periodic timer.</td></tr>
  </table>
</dl>
The macro #rt_fast_set_timer_period can substitute the corresponding function in kernel space if both the existing timer period and the new one fit into an 32 bits integer.<p>
This function an be used within the timer handler.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="rtai_tasklets.h::rt_set_timer_priority"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void rt_set_timer_priority           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct rt_tasklet_struct *&nbsp;</td>
          <td class="mdname" nowrap> <em>timer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>priority</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the priority of an existing timer. 
<p>
rt_set_timer_priority change the priority of an existing timer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timer</em>&nbsp;</td><td>is the pointer to the timer structure to be used to manage the timer at hand.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>is the priority to be used to execute timers handlers when more than one timer has to be fired at the same time. It can be assigned any value such that: 0 &lt; priority &lt; RT_LOWEST_PRIORITY.</td></tr>
  </table>
</dl>
This function can be used within the timer handler.<p>
<dl compact><dt><b>Note:</b></dt><dd>To be used only with RTAI24.x.xx. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:53 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
