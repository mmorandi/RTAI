<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTAI API: base/include/rtai_scb.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RTAI API<span id="projectnumber">&#160;5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('rtai__scb_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">rtai_scb.h File Reference<div class="ingroups"><a class="el" href="group__shm.html">Unified RTAI real-time memory management.</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>SCB stand for Shared (memory) Circular Buffer.  
<a href="#details">More...</a></p>
<div class="textblock"><div class="dynheader">
Include dependency graph for rtai_scb.h:</div>
<div class="dyncontent">
<div class="center"><img src="rtai__scb_8h__incl.png" border="0" usemap="#abase_2include_2rtai__scb_8h" alt=""/></div>
<map name="abase_2include_2rtai__scb_8h" id="abase_2include_2rtai__scb_8h">
<area shape="rect" title="SCB stand for Shared (memory) Circular Buffer." alt="" coords="253,5,410,31"/>
<area shape="rect" href="rtai__shm_8h.html" title="Interface of the RTAI SHM module." alt="" coords="225,79,309,104"/>
<area shape="rect" title=" " alt="" coords="333,79,460,104"/>
<area shape="rect" title=" " alt="" coords="121,152,179,177"/>
<area shape="rect" title=" " alt="" coords="5,225,73,251"/>
<area shape="rect" title=" " alt="" coords="97,225,192,251"/>
<area shape="rect" title=" " alt="" coords="581,152,663,177"/>
<area shape="rect" href="rtai__lxrt_8h.html" title="LXRT main header." alt="" coords="477,152,556,177"/>
<area shape="rect" href="rtai__nam2num_8h.html" title="Conversion between 6 characters strings and unsigned long identifiers." alt="" coords="627,225,743,251"/>
<area shape="rect" title=" " alt="" coords="744,299,809,324"/>
<area shape="rect" title=" " alt="" coords="818,225,909,251"/>
<area shape="rect" title=" " alt="" coords="933,225,1001,251"/>
<area shape="rect" title=" " alt="" coords="1026,225,1095,251"/>
<area shape="rect" title=" " alt="" coords="1119,225,1181,251"/>
<area shape="rect" title=" " alt="" coords="217,225,281,251"/>
<area shape="rect" title=" " alt="" coords="305,225,411,251"/>
<area shape="rect" title=" " alt="" coords="435,225,502,251"/>
<area shape="rect" title=" " alt="" coords="527,225,603,251"/>
<area shape="rect" title=" " alt="" coords="652,299,717,324"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab49bfc44efad21372be0a271672a0f1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__scb_8h.html#ab49bfc44efad21372be0a271672a0f1f">if</a> (suprt &gt; 1000)</td></tr>
<tr class="memdesc:ab49bfc44efad21372be0a271672a0f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a shared memory circular buffer.  <a href="rtai__scb_8h.html#ab49bfc44efad21372be0a271672a0f1f">More...</a><br /></td></tr>
<tr class="separator:ab49bfc44efad21372be0a271672a0f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cf807f82b8604aeda4e3f8fe24b1ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__scb_8h.html#ab6cf807f82b8604aeda4e3f8fe24b1ad">return</a> (lbyte &gt;=fbyte ? lbyte - fbyte :size+lbyte - fbyte)</td></tr>
<tr class="memdesc:ab6cf807f82b8604aeda4e3f8fe24b1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a shared memory circular buffer.  <a href="rtai__scb_8h.html#ab6cf807f82b8604aeda4e3f8fe24b1ad">More...</a><br /></td></tr>
<tr class="separator:ab6cf807f82b8604aeda4e3f8fe24b1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41e5b5a7fd65c642303a294c139fa34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__scb_8h.html#ab41e5b5a7fd65c642303a294c139fa34">return</a> (fbyte&lt;=lbyte ? size+fbyte - lbyte :size - lbyte)</td></tr>
<tr class="memdesc:ab41e5b5a7fd65c642303a294c139fa34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes avaiable in a shared memory circular buffer.  <a href="rtai__scb_8h.html#ab41e5b5a7fd65c642303a294c139fa34">More...</a><br /></td></tr>
<tr class="separator:ab41e5b5a7fd65c642303a294c139fa34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a865a47e708850318590ef3bd48922"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__scb_8h.html#a27a865a47e708850318590ef3bd48922">if</a> (msg_size &gt; 0 &amp;&amp;((lbyte -=fbyte) &gt;=0 ? lbyte :size+lbyte) &gt;=msg_size)</td></tr>
<tr class="memdesc:a27a865a47e708850318590ef3bd48922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets (receives) a message, only if the whole message can be passed all at once.  <a href="rtai__scb_8h.html#a27a865a47e708850318590ef3bd48922">More...</a><br /></td></tr>
<tr class="separator:a27a865a47e708850318590ef3bd48922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cdd1078c19370d550c467dd1edc2e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__scb_8h.html#a40cdd1078c19370d550c467dd1edc2e4">if</a> (msg_size &gt; 0 &amp;&amp;((fbyte -=lbyte)&lt;=0 ? size+fbyte :fbyte) &gt; msg_size)</td></tr>
<tr class="memdesc:a40cdd1078c19370d550c467dd1edc2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts (sends) a message, only if the whole message can be passed all at once.  <a href="rtai__scb_8h.html#a40cdd1078c19370d550c467dd1edc2e4">More...</a><br /></td></tr>
<tr class="separator:a40cdd1078c19370d550c467dd1edc2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >SCB stand for Shared (memory) Circular Buffer. </p>
<p >It is a non blocking implementation for just a single writer (producer) and reader (consumer) and, under such a constraint, it can be a specific substitute for RTAI mailboxes. There are other constraints that must be satisfied, so it cannot be a general substitute for the more flexible RTAI mailboxes. In fact it provides just functions corresponding to RTAI mailboxes non blocking atomic send/receive of messages, i.e. the equivalents of rt_mbx_send_if and rt_mbx_receive_if. Moreover the circular buffer size must be &gt;= to the largest message to be sent/received. At least the double of the largest message to be sent/received is strongly recommended. Thus sending/receiving a message either succeeds of fails. However thanks to the use of shared memory it should be more efficient than mailboxes in atomic exchanges of messages from kernel to user space. So it is a good candidate for supporting drivers development.</p>
<dl class="section author"><dt>Author</dt><dd>Paolo Mantegazza</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Copyright &copy; 2004-2008 Paolo Mantegazza <a href="#" onclick="location.href='mai'+'lto:'+'man'+'te'+'gaz'+'za'+'@ae'+'ro'+'.po'+'li'+'mi.'+'it'; return false;">mante<span class="obfuscator">.nosp@m.</span>gazz<span class="obfuscator">.nosp@m.</span>a@aer<span class="obfuscator">.nosp@m.</span>o.po<span class="obfuscator">.nosp@m.</span>limi.<span class="obfuscator">.nosp@m.</span>it</a></dd></dl>
<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p>
<p >This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p >You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a40cdd1078c19370d550c467dd1edc2e4" name="a40cdd1078c19370d550c467dd1edc2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cdd1078c19370d550c467dd1edc2e4">&#9670;&#160;</a></span>if() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">if </td>
          <td>(</td>
          <td class="paramtype">msg_size&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0 &amp;&amp;&#160;</td>
          <td class="paramname">(fbyte -=lbyte)&lt;=0 ? size+fbyte :fbyte, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">msg_size&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts (sends) a message, only if the whole message can be passed all at once. </p>
<p >rt_scb_put tries to atomically send the message <em>msg</em> of <em>msg_size</em> bytes to the shared memory circular buffer <em>scb</em>. It returns immediately and the caller is never blocked.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, i.e. message put, it returns 0, msg_size on failure. </dd></dl>

</div>
</div>
<a id="a27a865a47e708850318590ef3bd48922" name="a27a865a47e708850318590ef3bd48922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a865a47e708850318590ef3bd48922">&#9670;&#160;</a></span>if() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">if </td>
          <td>(</td>
          <td class="paramtype">msg_size&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0 &amp;&amp;((lbyte -=fbyte) &gt;=0 ? lbyte :size+lbyte) &gt;=&#160;</td>
          <td class="paramname"><em>msg_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{ </div>
<div class="line">        <span class="keywordtype">int</span> size = SIZE, fbyte = FBYTE, lbyte = LBYTE</div>
</div><!-- fragment -->
<p>Gets (receives) a message, only if the whole message can be passed all at once. </p>
<p >eavedrops a message.</p>
<p >rt_scb_get tries to atomically receive the message <em>msg</em> of <em>msg_size</em> bytes from the shared memory circular buffer <em>scb</em>. It returns immediately and the caller is never blocked.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, i.e. message got, it returns 0, msg_size on failure.</dd></dl>
<p>rt_scb_evdrp atomically spies the message <em>msg</em> of <em>msg_size</em> bytes from the shared memory circular buffer <em>scb</em>. It returns immediately and the caller is never blocked. It is like rt_scb_get but leaves the message in the shared memory circular buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, i.e. message got, it returns 0, msg_size on failure. </dd></dl>

</div>
</div>
<a id="ab49bfc44efad21372be0a271672a0f1f" name="ab49bfc44efad21372be0a271672a0f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49bfc44efad21372be0a271672a0f1f">&#9670;&#160;</a></span>if() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">if </td>
          <td>(</td>
          <td class="paramtype">suprt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1000&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a shared memory circular buffer. </p>
<p >rt_scb_init is used to allocate and/or initialize a shared memory circular buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is an unsigned long identifier;</td></tr>
    <tr><td class="paramname">size</td><td>is the size of the circular buffer.</td></tr>
    <tr><td class="paramname">suprt</td><td>is the kernel allocation method to be used, it can be:<ul>
<li>USE_VMALLOC, use vmalloc;</li>
<li>USE_GFP_KERNEL, use kmalloc with GFP_KERNEL;</li>
<li>USE_GFP_ATOMIC, use kmalloc with GFP_ATOMIC;</li>
<li>USE_GFP_DMA, use kmalloc with GFP_DMA.</li>
<li>for use in kernel/(multi-threaded)user space only applications the user can use "suprt" to pass the address of any memory area (s)he has allocated on her/his own. In such a case the actual buffer should be greater than the requested size by the amount HDRSIZ at least.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Since <em>an</em> unsigned long can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.</p>
<dl class="section see"><dt>See also</dt><dd>nam2num() and num2nam().</dd></dl>
<p>It must be remarked that only the very first call does a real allocation, any following call to allocate with the same name, from anywhere, will just increase the usage count and map the circular buffer to the user space, or return the related pointer to the already allocated buffer in kernel/user space. In any case the functions return a pointer to the circular buffer, appropriately mapped to the memory space in use. So if one is really sure that the named circular buffer has been initted already parameters "size" and "suprt" are not used and can be assigned any value.</p>
<dl class="section return"><dt>Returns</dt><dd>a valid address on succes, you must use it, 0 on failure. </dd></dl>

</div>
</div>
<a id="ab41e5b5a7fd65c642303a294c139fa34" name="ab41e5b5a7fd65c642303a294c139fa34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41e5b5a7fd65c642303a294c139fa34">&#9670;&#160;</a></span>return() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">fbyte&lt;=lbyte ? size+fbyte - lbyte :size -&#160;</td>
          <td class="paramname"><em>lbyte</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bytes avaiable in a shared memory circular buffer. </p>
<p >rt_scb_bytes is used to get the number of bytes avaiable in a shared memory circular buffer; legacy alias for rt_scb_avbs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb</td><td>is the pointer handle returned when the buffer was initted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the available number of bytes. Get the number of free bytes pace in a shared memory circular buffer.</dd></dl>
<p >rt_scb_frbs is used to get the number of free bytes space avaiable in a shared memory circular buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb</td><td>is the pointer handle returned when the buffer was initted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of free bytes. </dd></dl>

</div>
</div>
<a id="ab6cf807f82b8604aeda4e3f8fe24b1ad" name="ab6cf807f82b8604aeda4e3f8fe24b1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cf807f82b8604aeda4e3f8fe24b1ad">&#9670;&#160;</a></span>return() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return </td>
          <td>(</td>
          <td class="paramtype">lbyte &gt;=fbyte ? lbyte - fbyte :size+lbyte -&#160;</td>
          <td class="paramname"><em>fbyte</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a shared memory circular buffer. </p>
<p >rt_scb_reset reinitializes a shared memory circular buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb</td><td>is the pointer returned when the buffer was initted. Free a shared memory circular buffer.</td></tr>
  </table>
  </dd>
</dl>
<p >rt_scb_delete is used to release a previously allocated shared memory circular buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the unsigned long identifier used when the buffer was allocated;</td></tr>
  </table>
  </dd>
</dl>
<p>Analogously to what done by all the named allocation functions the freeing calls have just the effect of decrementing a usage count, unmapping any user space shared memory being freed, till the last is done, as that is the one the really frees any allocated memory.</p>
<dl class="section return"><dt>Returns</dt><dd>the size of the succesfully freed buffer, 0 on failure.</dd></dl>
<p>No need to call this function if you provided your own memory for the circular buffer. Get the number of bytes avaiable in a shared memory circular buffer.</p>
<p >rt_scb_avbs is used to get the number of bytes avaiable in a shared memory circular buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scb</td><td>is the pointer handle returned when the buffer was initted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the available number of bytes. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_e914ee4d4a44400f1fdb170cb4ead18a.html">base</a></li><li class="navelem"><a class="el" href="dir_86751c6d8ae9997ab6788777e7f7ee73.html">include</a></li><li class="navelem"><a class="el" href="rtai__scb_8h.html">rtai_scb.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
