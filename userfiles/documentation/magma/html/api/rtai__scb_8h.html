<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: base/include/rtai_scb.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">base</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">include</a></div>
<h1>rtai_scb.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
SCB stand for Shared (memory) Circular Buffer. 
<p>
It is a non blocking implementation for just a single writer (producer) and reader (consumer) and, under such a constraint, it can be a specific substitute for RTAI mailboxes. There are other constraints that must be satisfied so it cannot be a general substitute for the more flexible RTAI mailboxes. In fact it provides just functions corresponding to RTAI mailboxes non blocking atomic send/receive of messages, i.e. the equivalents of rt_mbx_send_if and rt_mbx_receive_if. Moreover the circular buffer size must be &gt;= to the largest message to be sent/received. Thus sending/receiving a message either succeeds of fails. However thanks to the use of shared memory it should be more efficient than mailboxes in atomic exchanges of messages from kernel to user space. So it is a good candidate for supporting drivers development.<p>
<dl compact><dt><b>Author:</b></dt><dd>Paolo Mantegazza</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Copyright &copy; 2004 Paolo Mantegazza &lt;<a href="mailto:mantegazza@aero.polimi.it">mantegazza@aero.polimi.it</a>&gt;</dd></dl>
This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.<p>
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.<p>
You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
<p>

<p>
Include dependency graph for rtai_scb.h:<p><center><img src="rtai__scb_8h__incl.png" border="0" usemap="#rtai_scb.h_map" alt="Include dependency graph"></center>
<map name="rtai_scb.h_map">
<area href="rtai__shm_8h.html" shape="rect" coords="250,158,335,182" alt="">
<area href="rtai__lxrt_8h.html" shape="rect" coords="467,84,545,108" alt="">
<area href="rtai__sched_8h-source.html" shape="rect" coords="7,9,101,33" alt="">
<area href="rtai__nam2num_8h.html" shape="rect" coords="125,9,242,33" alt="">
</map>

<p>
This graph shows which files directly or indirectly include this file:<p><center><img src="rtai__scb_8h__dep__incl.png" border="0" usemap="#rtai_scb.hdep_map" alt="Included by dependency graph"></center>
<map name="rtai_scb.hdep_map">
<area href="rtai__schedcore_8h-source.html" shape="rect" coords="184,84,304,108" alt="">
<area href="mbx_8c.html" shape="rect" coords="8,9,66,33" alt="">
<area href="msg_8c.html" shape="rect" coords="90,9,149,33" alt="">
<area href="sem_8c.html" shape="rect" coords="173,9,232,33" alt="">
<area href="shm_8c.html" shape="rect" coords="256,9,314,33" alt="">
<area href="api_8c.html" shape="rect" coords="338,9,389,33" alt="">
<area href="tasklets_8c.html" shape="rect" coords="413,9,490,33" alt="">
</map>

<p>
<a href="rtai__scb_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__scb_8h.html#a5">rt_scb_init</a> (unsigned long name, int size, unsigned long suprt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate and initialize a shared memory circular buffer.  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__scb_8h.html#a6">rt_scb_delete</a> (unsigned long name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a shared memory circular buffer.  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__scb_8h.html#a7">rt_scb_bytes</a> (void *scb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of bytes avaiable in a shared memory circular buffer.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__scb_8h.html#a8">rt_scb_get</a> (void *scb, void *msg, int msg_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets (receives) a message, only if the whole message can be passed all at once.  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__scb_8h.html#a9">rt_scb_evdrp</a> (void *scb, void *msg, int msg_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">eavedrops a message.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__scb_8h.html#a10">rt_scb_put</a> (void *scb, void *msg, int msg_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Puts (sends) a message, only if the whole message can be passed all at once.  <a href="#a10"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a7" doxytag="rtai_scb.h::rt_scb_bytes"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_scb_bytes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>scb</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the number of bytes avaiable in a shared memory circular buffer. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_scb_bytes is used to get the number of bytes avaiable in a shared memory circular buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scb</em>&nbsp;</td><td>is the pointer handle returned when the buffer was initted.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the available number of bytes. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="rtai_scb.h::rt_scb_delete"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_scb_delete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free a shared memory circular buffer. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_scb_delete is used to release a previously allocated shared memory circular buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is the unsigned long identifier used when the buffer was allocated;</td></tr>
  </table>
</dl>
Analogously to what done by all the named allocation functions the freeing calls have just the effect of decrementing a usage count, unmapping any user space shared memory being freed, till the last is done, as that is the one the really frees any allocated memory.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the size of the succesfully freed buffer, 0 on failure.</dd></dl>
Do not call this function if you provided your own memory to the circular buffer. </p>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="rtai_scb.h::rt_scb_evdrp"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_scb_evdrp           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>scb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>msg_size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
eavedrops a message. 
<p>
rt_scb_evdrp atomically spies the message <em>msg</em> of <em>msg_size</em> bytes from the shared memory circular buffer <em>scb</em>. It returns immediately and the caller is never blocked. It is like rt_scb_get but leaves the message in the shared memory circular buffer.<p>
<dl compact><dt><b>Returns:</b></dt><dd>On success, i.e. message got, it returns 0, msg_size on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="rtai_scb.h::rt_scb_get"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_scb_get           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>scb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>msg_size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets (receives) a message, only if the whole message can be passed all at once. 
<p>
rt_scb_get tries to atomically receive the message <em>msg</em> of <em>msg_size</em> bytes from the shared memory circular buffer <em>scb</em>. It returns immediately and the caller is never blocked.<p>
<dl compact><dt><b>Returns:</b></dt><dd>On success, i.e. message got, it returns 0, msg_size on failure. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="rtai_scb.h::rt_scb_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* rt_scb_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>suprt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate and initialize a shared memory circular buffer. 
<p>
<p><b>For internal use only.</b></p>
<p>
rt_scb_init is used to allocate and initialize a shared memory circular buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>is an unsigned long identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the size of the circular buffer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>suprt</em>&nbsp;</td><td>is the kernel allocation method to be used, it can be:<ul>
<li>USE_VMALLOC, use vmalloc;</li><li>USE_GFP_KERNEL, use kmalloc with GFP_KERNEL;</li><li>USE_GFP_ATOMIC, use kmalloc with GFP_ATOMIC;</li><li>USE_GFP_DMA, use kmalloc with GFP_DMA.</li><li>for use in kernel only applications the user can use "suprt" to pass the address of any memory area (s)he has allocated on her/his own.</li></ul>
</td></tr>
  </table>
</dl>
Since <em>name</em> can be a clumsy identifier, services are provided to convert 6 characters identifiers to unsigned long, and vice versa.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="rtai__nam2num_8h.html#a0">nam2num()</a> and <a class="el" href="rtai__nam2num_8h.html#a1">num2nam()</a>.</dd></dl>
It must be remarked that only the very first call does a real allocation, any following call to allocate with the same name from anywhere will just increase the usage count and maps the circular buffer to the user space, or return the related pointer to the already allocated buffer in kernel space. In any case the functions return a pointer to the circular buffer, appropriately mapped to the memory space in use. So if one is really sure that the named circular buffer has been initted already parameters size and suprt are not used and can be assigned any value.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a valid address on succes, 0 on failure. </dd></dl>
</p>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="rtai_scb.h::rt_scb_put"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rt_scb_put           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>scb</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>msg_size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Puts (sends) a message, only if the whole message can be passed all at once. 
<p>
rt_scb_put tries to atomically send the message <em>msg</em> of <em>msg_size</em> bytes to the shared memory circular buffer <em>scb</em>. It returns immediately and the caller is never blocked.<p>
<dl compact><dt><b>Returns:</b></dt><dd>On success, i.e. message put, it returns 0, msg_size on failure. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:53 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
