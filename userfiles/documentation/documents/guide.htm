<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>DIAPM RTAI - Beginner's Guide</title>
<style type="text/css">
<!--
A.noline {text-decoration:none}
//-->
</style>
</head>
<body bgcolor="#FFFFFF"
topmargin="0"
bottommargin="0"
leftmargin="10"
rightmargin="0"
marginheight="0"
marginwidth="0"
>

<br>
<table align="center" width="98%" border="0" cellspacing="0" cellpadding="0" summary="">
<tr>
<td colspan="5" background="../../images/trave.gif">
<table border="0" width="100%" height="80" summary="">
<tr>
<td><p align="left">
      <img SRC="../../images/logo.gif" BORDER="0" height="75" width="74" alt="">
    </td>
    <td><p align="left"><big><font color="#0000FF">
      <b>DIAPM&nbsp; RTAI</b></font> <br>
      <font color="#0000FF"><b>Dipartimento di Ingegneria Aerospaziale -
      Politecnico di Milano&nbsp;</b></font> <br>
      <font color="#0000FF"><b>Real Time Application Interface</b></font></big>
    </td>
<td><p align="right">
      <img SRC="../../images/epatents.png" BORDER="0" height="75" width="74" alt="">
    </td>
  </tr>
  </table>
</td>
</tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="0" summary="">
<tr>
<td>
  <img src="../../images/M_empty.gif" width="10" height="1" alt="">
</td>
<td valign="top" width="100">
  <table width="150" border="0" cellspacing="0" cellpadding="0" summary="">
  <tr><td><br><br></td></tr>
  <tr>
    <td>
      <table border="0"
	     cellpadding="1"
	     cellspacing="0"
	     bgcolor="#000066"
	     width="150" summary="">
      <tr>
        <td>
	  <table width="100%" border="0" cellspacing="1" cellpadding="1" summary="">
	  <tr>
	    <td bgcolor="#F0FFFF">
	    <table border="0" width="100%" summary="">
<tr><td bgcolor="#00005b" colspan="2"><div align="center"><b><font color="#F8E8B8">Home</font></div></b></td></tr>
<tr><td colspan="2"><img src="../../images/M_empty.gif" height="8" alt="" width="8"></td></tr><tr><td width="20" align="center"><IMG SRC="../../images/M_bluedark.gif" ALIGN="TOP" alt="" width="10" height="10"></td><td width="80"><A HREF="../../index.html">RTAI Home</A></td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td bgcolor="#00005b" colspan="2"><div align="center"><b><font color="#F8E8B8">Info</font></div></b></td></tr>
<tr><td colspan="2"><img src="../../images/M_empty.gif" height="8" alt="" width="8"></td></tr><tr><td width="20" align="center"><IMG SRC="../../images/M_bluedark.gif" ALIGN="TOP" alt="" width="10" height="10"></td><td width="80"><A HREF="../../about/index.html">About RTAI</A></td></tr>
<tr><td colspan="2"><img src="../../images/M_empty.gif" height="8" alt="" width="8"></td></tr><tr><td width="20" align="center"><IMG SRC="../../images/M_bluedark.gif" ALIGN="TOP" alt="" width="10" height="10"></td><td width="80"><A HREF="../../news/index.html">News Archive</A></td></tr>
<tr><td colspan="2"><img src="../../images/M_empty.gif" height="8" alt="" width="8"></td></tr><tr><td width="20" align="center"><IMG SRC="../../images/M_bluedark.gif" ALIGN="TOP" alt="" width="10" height="10"></td><td width="80"><A HREF="../../documentation/index.html">Documentation</A></td></tr>
<tr><td colspan="2"><img src="../../images/M_empty.gif" height="8" alt="" width="8"></td></tr><tr><td width="20" align="center"><IMG SRC="../../images/M_bluedark.gif" ALIGN="TOP" alt="" width="10" height="10"></td><td width="80"><A HREF="../../applications/index.html">Applications</A></td></tr><tr><td width="20" align="center"><IMG SRC="../../images/M_empty.gif" ALIGN="TOP" alt="" width="10" height="10"></td><td width="80"><A HREF="../../applications/index.html">and Links</A><BR></td></tr>
<tr><td colspan="2"><img src="../../images/M_empty.gif" height="8" alt="" width="8"></td></tr><tr><td width="20" align="center"><IMG SRC="../../images/M_bluedark.gif" ALIGN="TOP" alt="" width="10" height="10"></td><td width="80"><A HREF="../../team/index.html">The RTAI Team</A></td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td bgcolor="#00005b" colspan="2"><div align="center"><b><font color="#F8E8B8">Download</font></div></b></td></tr>
<tr><td colspan="2"><img src="../../images/M_empty.gif" height="8" alt="" width="8"></td></tr><tr><td width="20" align="center"><IMG SRC="../../images/M_bluedark.gif" ALIGN="TOP" alt="" width="10" height="10"></td><td width="80"><A HREF="../../download/index.html">Download RTAI</A></td></tr>
<tr><td>&nbsp;</td></tr>
<tr><td bgcolor="#00005b" colspan="2"><div align="center"><b><font color="#F8E8B8">Contact</font></div></b></td></tr>
<tr><td colspan="2"><img src="../../images/M_empty.gif" height="8" alt="" width="8"></td></tr><tr><td width="20" align="center"><IMG SRC="../../images/M_bluedark.gif" ALIGN="TOP" alt="" width="10" height="10"></td><td width="80"><A HREF="../../contact/index.html">Mailing List</A></td></tr>
<tr><td colspan="2"><img src="../../images/M_empty.gif" height="8" alt="" width="8"></td></tr><tr><td width="20" align="center"><IMG SRC="../../images/M_bluedark.gif" ALIGN="TOP" alt="" width="10" height="10"></td><td width="80"><A HREF="https://cvs.comedi.org/cgi-bin/bugzilla/enter_bug.cgi?product=RTAI">Report Bug</A></td></tr>
<tr><td>&nbsp;</td></tr>
            <MENUEHEAD de-name = "Sprache wählen"
                        en-name = "Select languate"
>
            </table>
            </td>
	  </tr>
	  </table>
	</td>
      </tr>
      </table
    </td>
  </tr>
  </table>
</td>
<td>
  <img src="../../images/M_empty.gif" width="30" height="1" alt="">
</td>
<td valign="top" width="100%">
<br><br>
<p><font size="+2"><b>DIAPM RTAI - Beginner's Guide</b></font></p>
<p><font size="+1"><b> What is a &quot;real time system&quot;?</b></font></p>
<p align="justify"> A real time system can be defined as a <i>&quot;system capable of
guaranteeing timing requirements of the processes under its control&quot;</i>.
</p>
<p align="justify"> It must be <i>fast <u>and</u> predictable</i>. <i>Fast</i> means that it has
a low latency, i.e. it responds to external, asynchronous events in a short
time. The lower the latency, the better the system will respond to events which
require immediate attention. <i>Predictable </i>means that it is able to
determine task's completion time with certainty. </p>
<p align="justify"> Typically a real time system represents the <i>computer controlling system
</i>that manages and coordinates the activities of a controlled system, that
can be viewed as the environment with which the computer interacts. The
interaction is bidirectional, say through various sensors (environment -&gt;
computer) and actuators (computer -&gt; environment), and is characterized by
<i>timing correctness constraints</i>. </p>
<p align="justify"> It is desirable that <i>time-critical </i>and <i>non time-critical
activities</i> coexist in a real time system. Both are called tasks and a task
with a timeliness requirement is called a <i>real time task.</i> </p>
<p align="justify"> Typically real time tasks have the following types of requirements and/or
constraints. <br> - <i>Timing constraints</i>. The most common are either
<i>periodic</i> or <i>aperiodic</i>. An aperiodic task has a deadline by which
it must finish or start, or it may have a constraint on both start and finish
times. A periodic task has to be repeated once per period. Most sensory
processing is periodic, while aperiodic requirements can arise from dynamic
events. </p>
<table border="0" summary="">
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> <i>Resource requirements</i>. A real time task may require access to
     certain resources such as I/O devices, data structures, files and
     databases.
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> <i>Communication requirements</i>. Tasks should be allowed to
     communicate with messages.
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> <i>Concurrency constraints</i>. Tasks should be allowed concurrent
     access to common resources providing the consistency of the resource
     is not violated. <br>
</td>
</tr>
</td>
</tr>
</td>
</tr>
</table>
<p><font size="+1"><b>What is RTAI?</b></font></p>
<p align="justify"> RTAI means <i>Real Time Application Interface.</i> Strictly speaking, it is
not a real time operating system, such as VXworks or QNX. It is based on the
Linux kernel, providing the ability to make it fully pre-emptable. </p>
<p align="justify"> Linux is a standard time-sharing operating system which provides good
average performance and highly sophisticated services. Like other OS, it offers
to the applications at least the following services:</p>
<table border="0" summary="">
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> hardware management layer dealing with event polling or
     processor/peripheral interrupts
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> scheduler classes dealing with process activation, priorities, time
     slice
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> communications means among applications.
</td>
</tr>
</td>
</tr>
</td>
</tr>
</table>
<p align="justify">  Linux suffers from a lack of real time support. To obtain a timing
correctness behaviour, it is necessary to make some changes in the kernel
sources, i.e. in the interrupt handling and scheduling policies. In this way,
you can have a real time platform, with low latency and high predicatbility
requirements, within full non real time Linux environment (access to TCP/IP,
graphical display and windowing systems, file and data base systems, etc.).
</p>
<p align="justify">  RTAI offers the same services of the Linux kernel core, adding the
features of an industrial real time operating system. It consists basically of
an <i>interrupt dispatcher:</i> RTAI mainly traps the peripherals interrupts
and if necessary re-routes them to Linux. It is not an intrusive modification
of the kernel; it uses the concept of HAL (<i>hardware abstraction</i>
<i>layer</i>) to get information from Linux and to trap some fundamental
functions. This HAL provides few dependencies to Linux Kernel. This leads to a
simple adaptation in the Linux kernel, an easy RTAI port from version to
version of Linux and an easier use of other operating systems instead of RTAI.
RTAI considers Linux as a background task running when no real time activity
occurs. </p>
<p><font size="+1"><b>Installing RTAI</b></font></p>
<p align="justify">  Please have a look at the README.INSTALL file in the RTAI distribution for
detailed instructions how to install RTAI. </p>
<p><font size="+1"><b> Kernel Modules </b></font></p>
<p align="justify">  RTAI is very much module oriented. So to understand and be able to use
RTAI is necessary to know the dynamically loadable modules for Linux. </p>
<p align="justify">  The Linux kernel design is similar to that of classic Unix systems: it
uses a monolithic architecture with file systems, device drivers, and other
pieces statically linked into the kernel image to be used at boot time. The
use of dynamic kernel modules allows you to write portions of the kernel as
separate objects that can be loaded and unloaded on a running system. </p>
<p align="justify">  A kernel module is simply an object file containing routines and/or data
to load into a running kernel. When loaded, the module code resides in the
kernel's address space and executes entirely within the context of the kernel.
Technically, a module can be any set of routines, with the one restriction
that two functions, init_module() and cleanup_module(), must be provided. The
first is executed once the module is loaded, and the second, before the module
is unloaded from the kernel. </p>
<p align="justify">  The main functions to use to load /unload and inspect kernel modules are
contained in the modutils package. They are: </p>
<table border="0" summary="">
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> /sbin/insmod (insert a module into the running kernel)
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> /sbin/rmmod (remove a module from the running kernel)
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> /sbin/lsmod (inspect modules in the running codes)
</td>
</tr>
</td>
</tr>
</td>
</tr>
</table>
<p align="justify">  Note that to manage with kernel modules you have to be root. </p>
<p align="justify">  Once a module is loaded, it passes to form part of the operating system,
hence it can use all the functions and access all variables and structures of
the kernel. Similarly the global symbols created are made available or
exported to other modules. If you don't want to share some symbol (variable or
function), you have to declare it as static. </p>
<p align="justify">  A module is built from a "C" source. Here is the simplest example of a
kernel module (simple1.c). </p>
<pre>
---------  simple1.c ------------

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/version.h>

int var = 20;

int init_module(void)
{
    printk("\nVariable value: %d \n\n", var);
    return 0;
}
void cleanup_module(void)
{
    printk("\n Bye \n\n");
}

--------------------------------
</pre>
<p align="justify">  This can be compiled with: </p>
<blockquote>
<pre>
gcc -c -D__KERNEL__ -DMODULE -o simple1 simple1.c
</pre>
</blockquote>
<p align="justify">  Note that the kernel offers a different version of printf() called
printk(); this works almost identically to the first except that it sends the
output to a kernel ring buffer. At any istant you can examine the contents of
the buffer using the command dmesg. </p>
<p align="justify">  If you want to set the value of the variable var at installation, include
the following macro: MODULE_PARM(var,"i"); after its declaration.</p>
<p align="justify">  To avoid the gcc command line for all sources, let's use the Makefile
facility. Here is an example for two sources, i.e. simple1.c and simple2.c.
</p>
<pre>
---------  Makefile -----------

CFLAGS = -D__KERNEL__ -DMODULE -c

OBJS = simple1 simple2
CC = gcc

all:

clean:
        rm

------------------------------
</pre>
<p align="justify">  If you want to add a math function, say sin(), to our simple module you
have to use the linker to get the sin() function into the kernel space. The
Makefile becomes: </p>
<pre>
---------  Makefile -----------

CFLAGS = -D__KERNEL__ -DMODULE -c

OBJS = simple1 simple_with_sin
CC = gcc

all:

simple_with_sin.o: simple_with_sin.c
        -o $@ $<

simple_with_sin: simple_with_sin.o
        ld -r -static -o $@ $< -lm

clean:
        rm simple_with_sin.o

------------------------------
</pre>
<p align="justify">  If you want to do some real work, you have to learn how to read/write to
hardware registers. It's very simple. </p>
<table border="0" summary="">
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> Include the header file containing the definition of the macros
     #include <asm/io.h>
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> Use inb() to read a byte from a 8-bits port and outb() to write a byte to a 8-bits port.
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> Use inw() and outw() for 16-bits ports.
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> If you include these macros and include the io.h file nothing will happen unless you use
     -O2 compiler flag; this option force the macros to be expanded.
</td>
</tr>
</td>
</tr>
</td>
</tr>
</td>
</tr>
</table>
<p align="justify">  Here is a simple code that write a value to the parallel port. </p>
<pre>
------------- simplepp.c -----------------

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/version.h>
#include <asm/io.h>

#define LPT 0x378

int var = 20;
MODULE_PARM(var,"i");

void write_lpt (unsigned char byte)
{
        outb(byte, LPT);
}

int init_module(void)
{
        printk("\n Variable Value: %d\n\n", var);
        write_lpt((unsigned char) var & 0xff);
        return 0;
}

void cleanup_module(void)
{
        write_lpt((unsigned char) 0);
        printk("\n Bye \n\n");
}

------------------------------------------
</pre>
<p><font size="+1"><b> RTAI Modules.</b></font></p>
<p align="justify">  To use RTAI, you have to load the modules that implement whatever RTAI
capabilities you need. According to 1.3 release, available are the following
core modules: </p>
<table border="0" summary="">
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> rtai
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> rtai_sched
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> rtai_fifos
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> rtai_shm
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> lxrt
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> rtai_pqueue
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> rtai_pthread
<tr>
  <td valign="top">
    <img src="../../images/M_bluedark.gif" alt="" width="10" height="10"><img src="../../images/M_empty.gif" alt="" width="10" height="10">
  </td>
  <td valign="top"> rtai_utils
</td>
</tr>
</td>
</tr>
</td>
</tr>
</td>
</tr>
</td>
</tr>
</td>
</tr>
</td>
</tr>
</td>
</tr>
</table>
<p>Let's examine one by one. </p>
<p>1) It is <i>the really core module</i> and nothing about the real time services can be
done without it. <br>
&nbsp;&nbsp;&nbsp;&nbsp; <font face="Courier New,Courier">rtai </font>initializes all of
its control variables and structures, makes a copy of the <font face="Courier New,Courier">idt_table
</font>and <br>
&nbsp;&nbsp;&nbsp;&nbsp; of the Linux irq handlers entry addresses and initializes the
interrupts chips (ic) management <br>
&nbsp;&nbsp;&nbsp;&nbsp; specific functions. But when you install <font
face="Courier New,Courier">rtai</font> with the usual <font face="Courier New,Courier">insmod
rtai </font>command nothing <br>
&nbsp;&nbsp;&nbsp;&nbsp; happens, as <font face="Courier New,Courier">rtai</font> is a
dormant module. You must specifically mount it when is needed by <br>
&nbsp;&nbsp;&nbsp;&nbsp; other modules calling <font face="Courier New,Courier">rt_mount_rtai()</font>
to activate it. You must unmount it as well when <br>
&nbsp;&nbsp;&nbsp;&nbsp; it is not required anymore, by calling <font
face="Courier New,Courier">rt_umount_rtai()</font>, which put <font
face="Courier New,Courier">rtai</font> back into its <br>
&nbsp;&nbsp;&nbsp;&nbsp; bed to sleep. The mount call activates <font
face="Courier New,Courier">rtai</font> and, even if you do not use any of its services
Linux <br>
&nbsp;&nbsp;&nbsp;&nbsp; work toward the hardware is filtered by <font
face="Courier New,Courier">rtai</font>. The most important thing happening when you <br>
&nbsp;&nbsp;&nbsp;&nbsp; mount RTAI is that from that very instant Linux is no more in
power of disabling/enabling <br>
&nbsp;&nbsp;&nbsp;&nbsp; interrupts. From that point on <font face="Courier New,Courier">rtai</font>
will assure that interrupt enables/disables will be consistent <br>
&nbsp;&nbsp;&nbsp;&nbsp; intra Linux but Linux could be preempted at any time by the
higher authority of <font face="Courier New,Courier">rtai</font>, the only <br>
&nbsp;&nbsp;&nbsp;&nbsp; master of the hardware. </p>
<p>2) The<i> real time scheduler module</i>, which is in charge of distributing the CPU to
different tasks <br>
&nbsp;&nbsp;&nbsp;&nbsp; present in the system, including Linux. The scheduling occurs
when tasks perform certain <br>
&nbsp;&nbsp;&nbsp;&nbsp; system calls and on timer handler activation (each 8254
interrupt) (for an explanation of timers <br>
&nbsp;&nbsp;&nbsp;&nbsp; and interrupts see&nbsp; <a href="#timers_irq">RTAI
Timers and Interrupts</a> ). The scheduler makes it elected the first <br>
&nbsp;&nbsp;&nbsp;&nbsp; highest priority task in a READY state. RTAI considers the
priority <font face="Courier New,Courier">0</font> as the highest priority <br>
&nbsp;&nbsp;&nbsp;&nbsp; and <font face="Courier New,Courier">0x3fffFfff </font>the
lowest. Linux is given priority <font face="Courier New,Courier">0x7fffFfff</font>. Given
a priority level, <br>
&nbsp;&nbsp;&nbsp;&nbsp; the first initialized task will be the first elected and will run
to completion unless a task with a <br>
&nbsp;&nbsp;&nbsp;&nbsp; higher priority is elected or it terminates or the task calls a
blocking system function. RTAI <br>
&nbsp;&nbsp;&nbsp;&nbsp; supports both periodic and oneshot mode for the real time
scheduler. <br>
&nbsp;&nbsp;&nbsp;&nbsp; You have three different schedulers: <br>
&nbsp;&nbsp;&nbsp;&nbsp; - <i>UP</i> , only for uniprocessors <br>
&nbsp;&nbsp;&nbsp;&nbsp; - <i>SMP</i> , for multiprocessors <br>
&nbsp;&nbsp;&nbsp;&nbsp; - <i>MUP</i> , only for multiprocessors <br>
&nbsp;&nbsp;&nbsp;&nbsp; The scheduler services are: <br>
&nbsp;&nbsp;&nbsp;<i>&nbsp; - Task functions</i> <br>
<i>&nbsp;&nbsp;&nbsp;&nbsp; - Timing functions</i> <br>
<i>&nbsp;&nbsp;&nbsp;&nbsp; - Semaphore functions</i> <br>
<i>&nbsp;&nbsp;&nbsp;&nbsp; - Mailbox functions</i> <br>
<i>&nbsp;&nbsp;&nbsp;&nbsp; - Intertask communication functions</i> <br>
&nbsp;&nbsp;&nbsp;&nbsp; All the functions can be used with any scheduler. Note that when
you load <font face="Courier New,Courier">rtai_sched</font>, <br>
&nbsp;&nbsp;&nbsp;&nbsp; automatically rtai is mounted. </p>
<p>3) The module that implements the fifo services for RTAI. Many applications appear to <br>
&nbsp;&nbsp;&nbsp;&nbsp; benefit from a synergy between the real-time system side and the
Linux side, for example <br>
&nbsp;&nbsp;&nbsp;&nbsp; for managing the data logging and displaying. Simple fifo buffers
are used to do this; they are <br>
&nbsp;&nbsp;&nbsp;&nbsp; called <i>real time fifos. </i>The real-time task interface
includes creation, destruction, reading and <br>
&nbsp;&nbsp;&nbsp;&nbsp; writing functions, performed by the <font
face="Courier New,Courier">rtai_fifos</font> module. Linux user processes, on the other <br>
&nbsp;&nbsp;&nbsp;&nbsp; hand, see rt-fifos as ordinary character devices. Note that on
the module side you always have <br>
&nbsp;&nbsp;&nbsp;&nbsp; only non blocking put/get, so that any different policy should be
enforced by using appropriate <br>
&nbsp;&nbsp;&nbsp;&nbsp; user handler functions. Available are an old and a new (strongly
recommended) fifo <br>
&nbsp;&nbsp;&nbsp;&nbsp; implementation. The last one is based on the mailboxes concepts,
symmetrically usable from <br>
&nbsp;&nbsp;&nbsp;&nbsp; kernel modules and Linux processes. Even if fifos are strictly no
more required in RTAI, <br>
&nbsp;&nbsp;&nbsp;&nbsp; because of the availability of LXRT (see below), fifos are kept
for both compatibility reasons <br>
&nbsp;&nbsp;&nbsp;&nbsp; and because they are very useful tools to be used to communicate
with interrupt handlers, <br>
&nbsp;&nbsp;&nbsp;&nbsp; since they do not require any scheduler to be installed.
In this sense <br>
&nbsp;&nbsp;&nbsp;&nbsp; you can see this new implementation of fifos as a kind of
universal form of device drivers, <br>
&nbsp;&nbsp;&nbsp;&nbsp; since once you have your interrupt handler installed you can use
fifo services to do all the rest. </p>
<p>4) The RTAI specific module that allows sharing memory among different real time tasks
and <br>
&nbsp;&nbsp;&nbsp;&nbsp; Linux processes, simoultaneously (it is another mechanism
available to users, in addition <br>
&nbsp;&nbsp;&nbsp;&nbsp; to fifos). The services are symmetrical, i.e. the same calls can
be used both in real time tasks, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i.e. within the kernel, and Linux processes. The first
allocation does a real allocation, any <br>
&nbsp;&nbsp;&nbsp;&nbsp; subsequent call to allocate with the same name from Linux
processes just maps the area <br>
&nbsp;&nbsp;&nbsp;&nbsp; to the user space or return the related pointer to the already
allocated space in kernel space. <br>
&nbsp;&nbsp;&nbsp;&nbsp; Analogously the freeing calls have just the effect of unmapping
till the last is done, as that is <br>
&nbsp;&nbsp;&nbsp;&nbsp; the one the really frees allocated memory. Clearly cooperating
users have to use the same <br>
&nbsp;&nbsp;&nbsp;&nbsp; name. </p>
<p>5) The LX(Linux)RT(RealTime) module, which implements services to make available any <br>
&nbsp;&nbsp;&nbsp;&nbsp; of the RTAI schedulers functions to Linux processes, so that a
fully symmetric implementation <br>
&nbsp;&nbsp;&nbsp;&nbsp; of real time services is possible. To state it more clearly, that
means that you can share memory, <br>
&nbsp;&nbsp;&nbsp;&nbsp; send messages, use semaphores and timings: Linux&lt;-&gt;Linux,
Linux&lt;-&gt;RTAI and, naturally, <br>
&nbsp;&nbsp;&nbsp;&nbsp; RTAI&lt;-&gt;RTAI.
</p>
<p>6x) Posix RTAI modules. <font face="Courier New,Courier">rtai_pthread.o</font> provides
hard real-time threads, where each <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; thread is a RTAI task. All threads execute in the
same address space and hence can work <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; concurrently on shared data. <font
face="Courier New,Courier">rtai_pqueue.o</font> provides kernel-safe message queues.
</a>
<p><font size="+1"><b> Timers and Interrupts </b></font></p>
<a name="timers_irq"></a>
<p align="justify">  Correct timing and interrupt management represent the really challenge of
a real time system, and hence of RTAI. But how can I get time from a PC? What
is an interrupt and how can I manage it? From now on we will refer to Intel
architecture (RTAI 1.3 runs on x86 machines). </p>
<p><b> Timers </b></p>
<p align="justify">  UPs provide a specific chip to solve the problem of generating accurate
time delays under software control. It is called 8254 and is a programmable
interval timer/counter, that can be treated as an array of four I/O ports in
the system software (from 0x40 to 0x43). Three are indipendent 16-bit counters
and the fourth is a control register for mode programming. The programmer
configures the 8254 to match his/her requirements (select the mode) and
programs one of the counters for the desired delay. After this delay, the 8254
will interrupt the CPU. Note that the counters are fully indipendent, so each
counter may operate in a different mode. Linux programs the timer with mode 2
(rate generator, periodic pace) and loads the counter0 with the macro HZ
defined in /usr/src/linux/include/asm/param.h (usually 100 hz). The counter 2
is used instead for beeping frequency. </p>
<p align="justify">  RTAI provides both a periodic (mode 2 of the 8254) and a oneshot timer
(mode 0), using the counter0 to load the initial count. In the oneshot mode
the clock is reprogrammed every interrupt, while in the periodic one it is
programmed only at beginning and then generates interrupts periodically. It is
up to you which one to choose in relation to the application at hand. The
periodic mode is much more efficient when you have one or many (but with a
common period) tasks that take regular samples, while the onsehot mode is more
flexible, because it allows for example to time several tasks with no large
common divisor in their periods or to trigger off some external event. Note
that in the RTAI oneshot mode the time is measured on the base of the CPU time
stamp clock (TSC) and neither on the 8254 chip, which is used only to generate
oneshot interrupts. This allows to reprogram the counter with only 2 I/O
instructions, i.e. approximately 3 us. Since the TSC is not available on 486
machines for them RTAI uses a form of emulation of the "read time stamp clock"
(rdtsc) assembler instruction based on counter2 of the 8254. So you can use
RTAI also on such machines. Be warned that the oneshot timer on 486 is a
performance overkill because of the need of reading the tsc, i.e. 8254
counter2 in this case, 2/3 times. MPs provides another facility to get time. In
addition to 8254 chip, which is one per box, there is a LOCAL APIC per CPU.
</p>
<p><b> Interrupts </b></p>
[... not yet available]
<p><font size="+1"><b> RTAI example 1 </b></font></p>
<p>This program is developed for the RTAI-1.4 version. You can find a
<em>Makefile</em>, one kernel module (<em>rt_process.c</em>) and a Linux
process (<em>scope.c</em>). By means of the scipt <em>Run</em> you can run the
program.<font FACE="Courier New" SIZE="2"></p>
<p></font>The program simply generates a sine signal and displays the istant
values on the screen.<font FACE="Courier New" SIZE="2">&nbsp; </p>
<p>&nbsp;</p>
<p>------------- MAKEFILE --------------------</p>
<p>all: scope rt_process.o </p>
<p>LINUX_HOME = /usr/src/linux</p>
<p>RTAI_HOME = /home/rtai-1.4</p>
<p>INCLUDE = -I/include -I/include</p>
<p>MODFLAGS = -D__KERNEL__ -DMODULE -O2 -Wall</p>
<p>scope: scope.c</p>
<p>&nbsp;&nbsp;&nbsp; gcc -o $@ $&lt; </p>
<p>rt_process.o: rt_process.c</p>
<p>&nbsp;&nbsp;&nbsp; gcc -c -o $@ $&lt;</p>
<p>clean:</p>
<p>&nbsp;&nbsp;&nbsp; rm -f rt_process.o scope </p>
<p>&nbsp;</p>
<p>-------------- RT_PROCESS.C -------------------</p>
<p>\#include &lt;linux/module.h&gt;</p>
<p>\#include &lt;asm/io.h&gt;</p>
<p>\#include &lt;math.h&gt;</p>
<p>\#include &lt;rtai.h&gt;</p>
<p>\#include &lt;rtai_sched.h&gt;</p>
<p>\#include &lt;rtai_fifos.h&gt;</p>
<p>&nbsp;</p>
<p>\#define TICK_PERIOD 1000000</p>
<p>\#define TASK_PRIORITY 1</p>
<p>\#define STACK_SIZE 10000</p>
<p>\#define FIFO 0</p>
<p>&nbsp;</p>
<p>static RT_TASK rt_task;</p>
<p>&nbsp;</p>
<p>static void fun(int t)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; int counter = 0;</p>
<p>&nbsp;&nbsp;&nbsp; float sin_value;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp; while (1) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sin_value =
sin(2*M_PI*1*rt_get_cpu_time_ns()/1E9);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtf_put(FIFO, &amp;counter,
sizeof(counter));</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtf_put(FIFO, &amp;sin_value,
sizeof(sin_value));</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; counter++;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rt_task_wait_period();</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>}</p>
<p>int init_module(void)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; RTIME tick_period;</p>
<p>&nbsp;&nbsp;&nbsp; rt_set_periodic_mode();</p>
<p>&nbsp;&nbsp;&nbsp; rt_task_init(&amp;rt_task, fun, 1, STACK_SIZE, TASK_PRIORITY, 1, 0);</p>
<p>&nbsp;&nbsp;&nbsp; rtf_create(FIFO, 8000);</p>
<p>&nbsp;&nbsp;&nbsp; tick_period = start_rt_timer(nano2count(TICK_PERIOD));</p>
<p>&nbsp;&nbsp;&nbsp; rt_task_make_periodic(&amp;rt_task, rt_get_time() + tick_period,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tick_period);</p>
<p>&nbsp;&nbsp;&nbsp; return 0;</p>
<p>}</p>
<p>void cleanup_module(void)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; stop_rt_timer();</p>
<p>&nbsp;&nbsp;&nbsp; rtf_destroy(FIFO);</p>
<p>&nbsp;&nbsp;&nbsp; rt_task_delete(&amp;rt_task);</p>
<p>&nbsp;&nbsp;&nbsp; return;</p>
<p>}</p>
<p>&nbsp;</p>
<p>-------------------- SCOPE.C ----------------------</p>
<p>\#include &lt;stdio.h&gt;</p>
<p>\#include &lt;unistd.h&gt;</p>
<p>\#include &lt;sys/types.h&gt;</p>
<p>\#include &lt;sys/mman.h&gt;</p>
<p>\#include &lt;sys/stat.h&gt;</p>
<p>\#include &lt;fcntl.h&gt;</p>
<p>\#include &lt;signal.h&gt;</p>
<p>&nbsp;</p>
<p>static int end;</p>
<p>static void endme(int dummy) { end=1; }</p>
<p>&nbsp;</p>
<p>int main (void)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; int fifo, counter;</p>
<p>&nbsp;&nbsp;&nbsp; float sin_value;</p>
<p>&nbsp;&nbsp;&nbsp; if ((fifo = open(&quot;/dev/rtf0&quot;, O_RDONLY)) &lt; 0) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf(stderr, &quot;Error opening
/dev/rtf0\n&quot;);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit(1);</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; signal(SIGINT, endme);</p>
<p>&nbsp;&nbsp;&nbsp; while (!end) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read(fifo, &amp;counter, sizeof(counter));</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read(fifo, &amp;sin_value,
sizeof(sin_value));</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot; Counter : %d Seno : %f
\n&quot;, counter, sin_value);</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; return 0;</p>
<p>}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>-------------------- RUN ----------------------</p>
<p>sync</p>
<p>insmod /home/rtai-1.4/modules/rtai.o</p>
<p>insmod /home/rtai-1.4/modules/rtai_sched.o</p>
<p>insmod /home/rtai-1.4/modules/rtai_shm.o</p>
<p>insmod /home/rtai-1.4/modules/rtai_fifos.o</p>
<p>insmod rt_process.o</p>
<p>./scope</p>
<p>rmmod rt_process</p>
<p>rmmod rtai_shm</p>
<p>rmmod rtai_fifos</p>
<p>rmmod rtai_sched</p>
<p>rmmod rtai</font></p>
<p><font size="+1"><b> RTAI example 2 </b></font></p>
<p>This example is like the first one, but it uses the shared memory, instead of fifos, to
communicate between Linux and the RTAI-layer. The common data space is declared in the
header file <em>parameters.h</em>. <font FACE="Courier New" SIZE="2"></p>
<p>------------------ MAKEFILE -------------------------</p>
<p>all: scope rt_process.o </p>
<p>LINUX_HOME = /usr/src/linux</p>
<p>RTAI_HOME = /home/rtai-1.4</p>
<p>INCLUDE = -I/include -I/include</p>
<p>MODFLAGS = -D__KERNEL__ -DMODULE -O2 -Wall</p>
<p>scope: scope.c</p>
<p>&nbsp;&nbsp;&nbsp; gcc -o $@ $&lt; </p>
<p>rt_process.o: rt_process.c parameters.h</p>
<p>&nbsp;&nbsp;&nbsp; gcc -c -o $@ $&lt;</p>
<p>clean:</p>
<p>&nbsp;&nbsp;&nbsp; rm -f rt_process.o scope </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>------------------- RT_PROCESS.C ----------------------&nbsp;</p>
<p>\#include &lt;linux/module.h&gt;</p>
<p>\#include &lt;asm/io.h&gt;</p>
<p>\#include &lt;math.h&gt;</p>
<p>\#include &lt;rtai.h&gt;</p>
<p>\#include &lt;rtai_shm.h&gt;</p>
<p>\#include &lt;rtai_sched.h&gt;</p>
<p>\#include &quot;parameters.h&quot;</p>
<p>&nbsp;</p>
<p>static RT_TASK rt_task;</p>
<p>static struct data_str *data;</p>
<p>&nbsp;</p>
<p>static void fun(int t)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; unsigned int count = 0;</p>
<p>&nbsp;&nbsp;&nbsp; float seno,coseno;</p>
<p>&nbsp;&nbsp;&nbsp; while (1) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data-&gt;indx_counter = count;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seno =
sin(2*M_PI*1*rt_get_cpu_time_ns()/1E9);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coseno =
cos(2*M_PI*1*rt_get_cpu_time_ns()/1E9);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data-&gt;sin_value = seno;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data-&gt;cos_value = coseno;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count++;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rt_task_wait_period();</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>}</p>
<p>int init_module(void)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; RTIME tick_period;</p>
<p>&nbsp;&nbsp;&nbsp; rt_set_periodic_mode();</p>
<p>&nbsp;&nbsp;&nbsp; rt_task_init(&amp;rt_task, fun, 1, STACK_SIZE, TASK_PRIORITY, 1, 0);</p>
<p>&nbsp;&nbsp;&nbsp; data = rtai_kmalloc(nam2num(SHMNAM), sizeof(struct data_str));</p>
<p>&nbsp;&nbsp;&nbsp; tick_period = start_rt_timer(nano2count(TICK_PERIOD));</p>
<p>&nbsp;&nbsp;&nbsp; rt_task_make_periodic(&amp;rt_task, rt_get_time() + tick_period,
tick_period);</p>
<p>&nbsp;&nbsp;&nbsp; return 0;</p>
<p>}</p>
<p>void cleanup_module(void)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; stop_rt_timer();</p>
<p>&nbsp;&nbsp;&nbsp; rt_task_delete(&amp;rt_task);</p>
<p>&nbsp;&nbsp;&nbsp; rtai_kfree(nam2num(SHMNAM));</p>
<p>&nbsp;&nbsp;&nbsp; return;</p>
<p>}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>---------------------- SCOPE.C ----------------------------</p>
<p>\#include &lt;stdio.h&gt;</p>
<p>\#include &lt;unistd.h&gt;</p>
<p>\#include &lt;sys/types.h&gt;</p>
<p>\#include &lt;sys/mman.h&gt;</p>
<p>\#include &lt;sys/stat.h&gt;</p>
<p>\#include &lt;fcntl.h&gt;</p>
<p>\#include &lt;signal.h&gt;</p>
<p>\#include &lt;rtai_shm.h&gt;</p>
<p>\#include &quot;parameters.h&quot;</p>
<p>&nbsp;</p>
<p>static int end;</p>
<p>static void endme(int dummy) { end=1; }</p>
<p>&nbsp;</p>
<p>int main (void)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; struct data_str *data;</p>
<p>&nbsp;&nbsp;&nbsp; signal(SIGINT, endme);</p>
<p>&nbsp;&nbsp;&nbsp; data = rtai_malloc (nam2num(SHMNAM),1);</p>
<p>&nbsp;&nbsp;&nbsp; while (!end) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot; Counter : %d Sine : %f Cosine
: %f \n&quot;, data-&gt;indx_counter, data-&gt;sin_value, &nbsp;&nbsp;&nbsp;
data-&gt;cos_value);</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; rtai_free (nam2num(SHMNAM), &amp;data);</p>
<p>&nbsp;&nbsp;&nbsp; return 0;</p>
<p>}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>---------------- PARAMETERS.H -----------------------&nbsp;</p>
<p>\#define TICK_PERIOD 1000000</p>
<p>\#define TASK_PRIORITY 1</p>
<p>\#define STACK_SIZE 10000</p>
<p>\#define SHMNAM &quot;MIRSHM&quot;</p>
<p>struct data_str</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; int indx_counter;</p>
<p>&nbsp;&nbsp;&nbsp; float sin_value;</p>
<p>&nbsp;&nbsp;&nbsp; float cos_value;</p>
<p>};</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>----------------------- RUN ------------------------</p>
<p>sync</p>
<p>insmod /home/rtai-1.4/modules/rtai.o</p>
<p>insmod /home/rtai-1.4/modules/rtai_sched.o</p>
<p>insmod /home/rtai-1.4/modules/rtai_shm.o</p>
<p>insmod /home/rtai-1.4/modules/rtai_fifos.o</p>
<p>insmod rt_process.o</p>
<p>./scope</p>
<p>rmmod rt_process</p>
<p>rmmod rtai_shm</p>
<p>rmmod rtai_fifos</p>
<p>rmmod rtai_sched</p>
<p>rmmod rtai</font></p>
<br>
<div><vspace 20></div>
<hr noshade size="1">
<div align="right"><font size="-1" color="#a0a0a0">
  &copy; 2002 The RTAI Development Team
  <hspace 10>-<hspace 10>
  Fri Dec 12 10:22:47 2003</small></font>
</div>
</td>
<td><img src="../../images/M_empty.gif" width="20" height="1" alt=""></td>
</tr>
</table>
</body>
</html>
